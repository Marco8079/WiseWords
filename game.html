<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echoes of the Mind</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #0a0a0f;
            font-family: 'Arial', sans-serif;
            color: #ffffff;
            overflow: auto !important;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
            touch-action: auto !important;
            -webkit-overflow-scrolling: touch !important;
            position: fixed; /* Prevent body from scrolling */
        }
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: 100vh;
            overflow-y: auto !important;
            touch-action: auto !important;
            -webkit-overflow-scrolling: touch !important;
        }
    
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent;
        }
        
        #background-canvas {
            z-index: 1;
        }
        
        #main-canvas {
            z-index: 2;
        }
        
        #ui-canvas {
            z-index: 3;
        }
        
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10;
            overflow-y: auto !important;
            -webkit-overflow-scrolling: touch !important;
            touch-action: auto !important;
        }
        
        .menu-hidden {
            display: none !important;
        }
        
        h1 {
            font-size: 3rem;
            margin-bottom: 2rem;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            letter-spacing: 3px;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
                margin-bottom: 1.5rem;
            }
        }
        
        .btn {
            background-color: transparent;
            border: 2px solid #ffffff;
            color: #ffffff;
            padding: 0.8rem 2rem;
            margin: 0.5rem;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
            min-width: 200px;
            text-align: center;
            touch-action: auto !important;
            -webkit-tap-highlight-color: rgba(255,255,255,0.3);
        }
        
        .btn:hover, .btn:active {
            background-color: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }
        
        #level-select {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Changed from center to flex-start */
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9;
            padding: 20px;
            overflow-y: auto !important;
            -webkit-overflow-scrolling: touch !important;
            touch-action: auto !important;
        }
        
        .level-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            margin-top: 20px;
            max-width: 800px;
            width: 100%;
            padding-bottom: 80px; /* Add extra padding at the bottom for better scrolling */
            padding-top: 60px; /* Add padding at the top to ensure first items are visible */
        }
        
        @media (max-width: 768px) {
            .level-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 500px) {
            .level-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        .level-btn {
            width: 100%;
            aspect-ratio: 1/1;
            border: 2px solid #ffffff;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            background-color: rgba(255, 255, 255, 0.1);
            position: relative;
            touch-action: auto !important;
            -webkit-tap-highlight-color: rgba(255,255,255,0.3);
        }
        
        .level-btn:hover, .level-btn:active {
            background-color: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }
        
        .level-locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .level-completed {
            border-color: #4CAF50;
        }
        
        .level-completed::after {
            content: "✓";
            position: absolute;
            top: 5px;
            right: 5px;
            color: #4CAF50;
            font-size: 1rem;
        }
        
        .level-quiz {
            border-color: #FFD700;
            background-color: rgba(255, 215, 0, 0.2);
        }
        
        .level-quiz::after {
            content: "?";
            position: absolute;
            top: 5px;
            right: 5px;
            color: #FFD700;
            font-size: 1rem;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 4;
            display: flex;
            flex-direction: column;
        }
        
        #echo-counter {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .echo-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #ffffff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            margin-right: 10px;
        }
        
        #time-fracture-meter {
            width: 150px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
        }
        
        #time-fracture-fill {
            height: 100%;
            width: 100%;
            background-color: #4fc3f7;
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        #level-complete {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 8;
            overflow-y: auto !important;
            -webkit-overflow-scrolling: touch !important;
            touch-action: auto !important;
        }
        
        .star {
            font-size: 3rem;
            color: #FFD700;
            margin: 0 5px;
        }
        
        .star-empty {
            color: rgba(255, 255, 255, 0.3);
        }
        
        #controls-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 5;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s ease;
        }
        
        #mobile-controls {
            display: none;
            width: 100%;
            justify-content: space-between;
        }
        
        @media (max-width: 768px) {
            #mobile-controls.active {
                display: flex;
            }
            
            #keyboard-controls {
                display: none;
            }
        }
        
        .control-group {
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: auto !important;
            -webkit-tap-highlight-color: rgba(255,255,255,0.3);
        }
        
        .control-btn:active {
            background-color: rgba(255, 255, 255, 0.4);
        }
        
        #keyboard-controls {
            width: 100%;
            text-align: center;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .key {
            display: inline-block;
            padding: 2px 8px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin: 0 3px;
        }
        
        #pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 7;
            overflow-y: auto !important;
            -webkit-overflow-scrolling: touch !important;
            touch-action: auto !important;
        }
        
        .particle {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            pointer-events: none;
        }
        
        #hamburger-menu {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            cursor: pointer;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 5px;
            touch-action: auto !important;
            -webkit-tap-highlight-color: rgba(255,255,255,0.3);
        }
        
        .hamburger-line {
            width: 25px;
            height: 3px;
            background-color: white;
            transition: all 0.3s ease;
        }
        
        #menu-dropdown {
            position: absolute;
            top: 70px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            border-radius: 5px;
            padding: 10px;
            z-index: 19;
            display: none;
            overflow-y: auto !important;
            -webkit-overflow-scrolling: touch !important;
            touch-action: auto !important;
        }
        
        #menu-dropdown.active {
            display: block;
        }
        
        .menu-item {
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            touch-action: auto !important;
            -webkit-tap-highlight-color: rgba(255,255,255,0.3);
        }
        
        .menu-item:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        #about-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Changed from center to flex-start */
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 11;
            padding: 20px;
            overflow-y: auto !important;
            -webkit-overflow-scrolling: touch !important;
            touch-action: auto !important;
        }
        
        .about-content {
            max-width: 600px;
            text-align: center;
            margin-bottom: 20px;
            margin-top: 60px; /* Add margin at the top to ensure content is visible */
        }
        
        .about-content p {
            margin-bottom: 15px;
            line-height: 1.6;
        }
        
        #settings-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Changed from center to flex-start */
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 12;
            padding: 20px;
            overflow-y: auto !important;
            -webkit-overflow-scrolling: touch !important;
            touch-action: auto !important;
        }
        
        .settings-section {
            margin-bottom: 30px;
            width: 100%;
            max-width: 500px;
            margin-top: 60px; /* Add margin at the top to ensure content is visible */
        }
        
        .settings-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .settings-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
        
        .settings-label {
            font-size: 1.1rem;
        }
        
        .settings-control {
            display: flex;
            align-items: center;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #4fc3f7;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        .radio-group {
            display: flex;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
        }
        
        .radio-option {
            flex: 1;
            text-align: center;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: auto !important;
            -webkit-tap-highlight-color: rgba(255,255,255,0.3);
        }
        
        .radio-option.selected {
            background-color: #4fc3f7;
            color: #000;
        }
        
        #quiz-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Changed from center to flex-start */
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 13;
            padding: 20px;
            overflow-y: auto !important;
            -webkit-overflow-scrolling: touch !important;
            touch-action: auto !important;
        }
        
        .quiz-container {
            max-width: 700px;
            width: 100%;
            text-align: center;
            padding-bottom: 80px; /* Add extra padding at the bottom for better scrolling */
            margin-top: 60px; /* Add margin at the top to ensure content is visible */
        }
        
        .quiz-title {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #FFD700;
        }
        
        .quiz-question {
            font-size: 1.3rem;
            margin-bottom: 30px;
            line-height: 1.6;
        }
        
        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .quiz-option {
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            touch-action: auto !important;
            -webkit-tap-highlight-color: rgba(255,255,255,0.3);
        }
        
        .quiz-option:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .quiz-option.selected {
            border-color: #4fc3f7;
            background-color: rgba(79, 195, 247, 0.2);
        }
        
        .quiz-option.correct {
            border-color: #4CAF50;
            background-color: rgba(76, 175, 80, 0.2);
        }
        
        .quiz-option.incorrect {
            border-color: #f44336;
            background-color: rgba(244, 67, 54, 0.2);
        }
        
        .quiz-feedback {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            font-size: 1.1rem;
            display: none;
        }
        
        .quiz-feedback.correct {
            background-color: rgba(76, 175, 80, 0.2);
            border: 2px solid #4CAF50;
            display: block;
        }
        
        .quiz-feedback.incorrect {
            background-color: rgba(244, 67, 54, 0.2);
            border: 2px solid #f44336;
            display: block;
        }
        
        .quiz-explanation {
            margin-top: 15px;
            font-style: italic;
            line-height: 1.5;
        }
        
        #swipe-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 4;
            display: none;
            overflow-y: auto !important;
            -webkit-overflow-scrolling: touch !important;
            touch-action: auto !important;
        }
        
        #swipe-overlay.active {
            display: block;
        }
        
        #zoom-controls {
            position: absolute;
            top: 80px;
            right: 20px;
            z-index: 6;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            touch-action: auto !important;
            -webkit-tap-highlight-color: rgba(255,255,255,0.3);
        }
        
        .zoom-btn:hover {
            background-color: rgba(0, 0, 0, 0.7);
        }
        
        #minimap {
            position: absolute;
            bottom: 80px;
            right: 20px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            z-index: 6;
            overflow: hidden;
            display: none;
        }
        
        #minimap-canvas {
            width: 100%;
            height: 100%;
        }
        
        #level-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 1.1rem;
            z-index: 6;
        }

        /* Additional fixes for iOS devices */
        @supports (-webkit-touch-callout: none) {
            body, 
            #game-container,
            #level-select,
            #quiz-screen,
            #pause-screen,
            #level-complete,
            #about-screen,
            #settings-screen,
            #menu,
            #swipe-overlay {
                -webkit-overflow-scrolling: touch !important;
                overflow-y: auto !important;
                touch-action: auto !important;
            }
            
            .quiz-option,
            .level-btn,
            .btn,
            .control-btn,
            .menu-item,
            .radio-option,
            .zoom-btn,
            #hamburger-menu {
                cursor: pointer;
                -webkit-tap-highlight-color: rgba(255,255,255,0.3);
                touch-action: auto !important;
            }
        }

        
    </style>

</head>
<body>
    <audio id="background-music" src="Gamesong.mp3" autoplay loop></audio>
    <div id="game-container">
        <canvas id="background-canvas"></canvas>
        <canvas id="main-canvas"></canvas>
        <canvas id="ui-canvas"></canvas>
        
        <div id="hud">
            <div id="echo-counter">
                <div class="echo-icon"></div>
                <span id="echo-count">0/5</span>
            </div>
            <div id="time-fracture-meter">
                <div id="time-fracture-fill"></div>
            </div>
        </div>
        
        <div id="level-indicator">Level 1</div>
        
        <div id="controls-container">
            <div id="mobile-controls" class="active">
                <div class="control-group">
                    <div class="control-btn" id="left-btn">←</div>
                    <div class="control-group" style="flex-direction: column; align-items: center;">
                        <div class="control-btn" id="up-btn">↑</div>
                        <div class="control-btn" id="down-btn">↓</div>
                    </div>
                    <div class="control-btn" id="right-btn">→</div>
                </div>
                <div class="control-group">
                    <div class="control-btn" id="time-btn">⏱</div>
                    <div class="control-btn" id="pause-btn">⏸</div>
                </div>
            </div>
            <div id="keyboard-controls">
                Move: <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> or <span class="key">↑</span><span class="key">←</span><span class="key">↓</span><span class="key">→</span> | Time Fracture: <span class="key">SPACE</span> | Pause: <span class="key">ESC</span>
            </div>
        </div>
        
        <div id="swipe-overlay"></div>
        
        <div id="zoom-controls">
            <div class="zoom-btn" id="zoom-in">+</div>
            <div class="zoom-btn" id="zoom-out">-</div>
        </div>
        
        <div id="minimap">
            <canvas id="minimap-canvas"></canvas>
        </div>
        
        <div id="hamburger-menu">
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
        </div>
        
        <div id="menu-dropdown">
            <div class="menu-item" id="menu-home">Home</div>
            <div class="menu-item" id="menu-restart">Restart Level</div>
            <div class="menu-item" id="menu-levels">Level Select</div>
            <div class="menu-item" id="menu-settings">Settings</div>
            <div class="menu-item" id="menu-about">About</div>
        </div>
        
        <div id="menu">
            <h1>ECHOES OF THE MIND</h1>
            <button class="btn" id="start-btn">Start Game</button>
            <button class="btn" id="level-select-btn">Level Select</button>
            <button class="btn" id="settings-btn">Settings</button>
            <button class="btn" id="about-btn">About</button>
        </div>
        
        <div id="level-select" class="menu-hidden">
            <h1>SELECT LEVEL</h1>
            <div class="level-grid">
                <!-- Level buttons will be generated dynamically -->
            </div>
            <button class="btn" id="back-to-menu">Back to Menu</button>
        </div>
        
        <div id="level-complete" class="menu-hidden">
            <h1>LEVEL COMPLETE</h1>
            <div id="stars-container">
                <span class="star">★</span>
                <span class="star star-empty">★</span>
                <span class="star star-empty">★</span>
            </div>
            <p id="completion-message">You collected 3/5 echoes!</p>
            <button class="btn" id="next-level-btn">Next Level</button>
            <button class="btn" id="retry-level-btn">Retry</button>
            <button class="btn" id="level-menu-btn">Level Select</button>
        </div>
        
        <div id="pause-screen" class="menu-hidden">
            <h1>PAUSED</h1>
            <button class="btn" id="resume-btn">Resume</button>
            <button class="btn" id="restart-btn">Restart Level</button>
            <button class="btn" id="pause-settings-btn">Settings</button>
            <button class="btn" id="pause-menu-btn">Main Menu</button>
        </div>
        
        <div id="about-screen" class="menu-hidden">
            <h1>ABOUT THE GAME</h1>
            <div class="about-content">
                <p>Echoes of the Mind is a puzzle game that explores the concepts of consciousness, time, and perception.</p>
                <p>Navigate through challenging levels, collect echoes, and use your time fracture ability to overcome obstacles.</p>
                <p>Each level represents a different aspect of the mind and challenges you to think differently about how you interact with the world.</p>
                <p>Every 10 levels, you'll encounter a quiz about Stoicism and self-improvement principles to test your knowledge and provide insights for personal growth.</p>
            </div>
            <button class="btn" id="about-back-btn">Back to Menu</button>
        </div>
        
        <div id="settings-screen" class="menu-hidden">
            <h1>SETTINGS</h1>
            <div class="settings-section">
                <h2 class="settings-title">Controls</h2>
                <div class="settings-option">
                    <span class="settings-label">Control Type</span>
                    <div class="settings-control">
                        <div class="radio-group">
                            <div class="radio-option selected" data-value="buttons">Buttons</div>
                            <div class="radio-option" data-value="swipe">Swipe</div>
                        </div>
                    </div>
                </div>
                <div class="settings-option">
                    <span class="settings-label">Show Controls</span>
                    <div class="settings-control">
                        <label class="toggle-switch">
                            <input type="checkbox" id="show-controls-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="settings-section">
                <h2 class="settings-title">Display</h2>
                <div class="settings-option">
                    <span class="settings-label">Show Minimap</span>
                    <div class="settings-control">
                        <label class="toggle-switch">
                            <input type="checkbox" id="show-minimap-toggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                <div class="settings-option">
                    <span class="settings-label">Visual Effects</span>
                    <div class="settings-control">
                        <label class="toggle-switch">
                            <input type="checkbox" id="visual-effects-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>
            <button class="btn" id="settings-back-btn">Save & Back</button>
        </div>
        
        <div id="quiz-screen" class="menu-hidden">
            <div class="quiz-container">
                <h2 class="quiz-title">Stoicism Quiz</h2>
                <p class="quiz-question" id="quiz-question">Question text will appear here</p>
                <div class="quiz-options" id="quiz-options">
                    <!-- Options will be generated dynamically -->
                </div>
                <div class="quiz-feedback" id="quiz-feedback">
                    <p id="feedback-text">Feedback text will appear here</p>
                    <p class="quiz-explanation" id="quiz-explanation">Explanation text will appear here</p>
                </div>
                <button class="btn" id="quiz-submit-btn">Submit Answer</button>
                <button class="btn" id="quiz-continue-btn" style="display: none;">Continue</button>
            </div>
        </div>
    </div>

    <script>

        /* Add this JavaScript to fix scrolling issues */
        /* This will be executed when the page loads */
        document.addEventListener('DOMContentLoaded', function() {
            // Fix for level select scrolling
            const levelSelect = document.getElementById('level-select');
            if (levelSelect) {
                // Make sure the first items are visible by scrolling to top
                levelSelect.scrollTop = 0;
            }
            
            // Fix for quiz screen scrolling
            const quizScreen = document.getElementById('quiz-screen');
            if (quizScreen) {
                // Make sure the first items are visible by scrolling to top
                quizScreen.scrollTop = 0;
            }
            
            // Prevent body scrolling but allow container scrolling
            document.body.style.overflow = 'hidden';
            
            // Add event listeners to ensure proper scrolling on all screens
            const scrollableContainers = [
                'level-select', 
                'quiz-screen', 
                'about-screen', 
                'settings-screen',
                'menu',
                'pause-screen',
                'level-complete'
            ];
            
            scrollableContainers.forEach(function(id) {
                const container = document.getElementById(id);
                if (container) {
                    // Reset scroll position when container becomes visible
                    const observer = new MutationObserver(function(mutations) {
                        mutations.forEach(function(mutation) {
                            if (mutation.attributeName === 'style' || 
                                mutation.attributeName === 'class') {
                                if (container.style.display !== 'none' && 
                                    !container.classList.contains('menu-hidden')) {
                                    container.scrollTop = 0;
                                }
                            }
                        });
                    });
                    
                    observer.observe(container, { attributes: true });
                }
            });
        });
        // Game constants
        const PLAYER_SIZE = 20;
        const PLAYER_SPEED = 5;
        const ECHO_SIZE = 15;
        const OBSTACLE_SPEED = 2;
        const TIME_FRACTURE_DURATION = 2000; // 2 seconds
        const TIME_FRACTURE_COOLDOWN = 5000; // 5 seconds
        const QUIZ_INTERVAL = 10; // Quiz every 10 levels
        
        // Canvas dimensions (will be set dynamically)
        let CANVAS_WIDTH;
        let CANVAS_HEIGHT;
        
        // Camera and zoom settings
        let camera = {
            x: 0,
            y: 0,
            zoom: 1,
            targetZoom: 1,
            zoomSpeed: 0.05,
            minZoom: 0.5,
            maxZoom: 2
        };
        
        // Game settings
        let settings = {
            controlType: 'buttons', // 'buttons' or 'swipe'
            showControls: true,
            showMinimap: false,
            visualEffects: true
        };
        
        // Game state
        let gameState = {
            currentLevel: 1,
            maxUnlockedLevel: 1,
            completedLevels: [],
            isPlaying: false,
            isPaused: false,
            timeFracture: {
                active: false,
                cooldown: 0,
                lastUsed: 0
            }
        };
        
        // Try to load saved game state and settings from localStorage
        try {
            const savedState = localStorage.getItem('echoesGameState');
            if (savedState) {
                const parsedState = JSON.parse(savedState);
                gameState.maxUnlockedLevel = parsedState.maxUnlockedLevel || 1;
                gameState.completedLevels = parsedState.completedLevels || [];
            }
            
            const savedSettings = localStorage.getItem('echoesGameSettings');
            if (savedSettings) {
                settings = { ...settings, ...JSON.parse(savedSettings) };
            }
        } catch (e) {
            console.error("Could not load saved data:", e);
        }
        
        // Player state
        let player = {
            x: 0,
            y: 0,
            size: PLAYER_SIZE,
            speed: PLAYER_SPEED,
            color: '#ffffff',
            glowColor: 'rgba(255, 255, 255, 0.5)',
            glowSize: 10,
            velocityX: 0,
            velocityY: 0
        };
        
        // Swipe control state
        let swipe = {
            startX: 0,
            startY: 0,
            endX: 0,
            endY: 0,
            isActive: false,
            direction: null,
            threshold: 30 // minimum distance to detect a swipe
        };
        
        // Level data
        const levels = [
            // Level 1
            {
                id: 1,
                name: "Control what you can",
                description: "Only move when enemies move",
                backgroundColor: '#0a0a2a',
                echoes: [
                    { x: 0.125, y: 0.167, collected: false }, // Using relative positions (0-1)
                    { x: 0.875, y: 0.167, collected: false },
                    { x: 0.125, y: 0.833, collected: false },
                    { x: 0.875, y: 0.833, collected: false },
                    { x: 0.5, y: 0.5, collected: false }
                ],
                obstacles: [
                    { x: 0.25, y: 0.333, width: 0.0625, height: 0.0833, color: '#ff5555', velocityX: 1, velocityY: 0, pattern: 'horizontal' },
                    { x: 0.75, y: 0.667, width: 0.0625, height: 0.0833, color: '#ff5555', velocityX: 0, velocityY: 1, pattern: 'vertical' }
                ],
                playerStart: { x: 0.5, y: 0.917 },
                exit: { x: 0.5, y: 0.083, width: 0.075, height: 0.033 },
                mapSize: { width: 1, height: 1 } // Standard size
            },
            // Level 2
            {
                id: 2,
                name: "Memento Mori",
                description: "World fades unless you keep moving",
                backgroundColor: '#1a1a3a',
                echoes: [
                    { x: 0.188, y: 0.25, collected: false },
                    { x: 0.813, y: 0.25, collected: false },
                    { x: 0.5, y: 0.5, collected: false },
                    { x: 0.188, y: 0.75, collected: false },
                    { x: 0.813, y: 0.75, collected: false }
                ],
                obstacles: [
                    { x: 0.375, y: 0.167, width: 0.25, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.375, y: 0.833, width: 0.25, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.125, y: 0.5, width: 0.0375, height: 0.333, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.838, y: 0.5, width: 0.0375, height: 0.333, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' }
                ],
                playerStart: { x: 0.5, y: 0.917 },
                exit: { x: 0.5, y: 0.083, width: 0.075, height: 0.033 },
                mapSize: { width: 1, height: 1 }
            },
            // Level 3
            {
                id: 3,
                name: "Ego vs Reason",
                description: "Clone of yourself mimics & blocks progress",
                backgroundColor: '#2a1a2a',
                echoes: [
                    { x: 0.25, y: 0.167, collected: false },
                    { x: 0.75, y: 0.167, collected: false },
                    { x: 0.5, y: 0.417, collected: false },
                    { x: 0.25, y: 0.667, collected: false },
                    { x: 0.75, y: 0.667, collected: false }
                ],
                obstacles: [
                    { x: 0.5, y: 0.5, width: 0.05, height: 0.067, color: 'rgba(255, 255, 255, 0.5)', velocityX: 0, velocityY: 0, pattern: 'mirror' }
                ],
                playerStart: { x: 0.5, y: 0.917 },
                exit: { x: 0.5, y: 0.083, width: 0.075, height: 0.033 },
                mapSize: { width: 1, height: 1 }
            },
            // Level 4
            {
                id: 4,
                name: "Nature is Cyclical",
                description: "Time loops unless you change your pattern",
                backgroundColor: '#1a2a1a',
                echoes: [
                    { x: 0.188, y: 0.25, collected: false },
                    { x: 0.813, y: 0.25, collected: false },
                    { x: 0.188, y: 0.75, collected: false },
                    { x: 0.813, y: 0.75, collected: false },
                    { x: 0.5, y: 0.5, collected: false }
                ],
                obstacles: [
                    { x: 0.375, y: 0.333, width: 0.05, height: 0.067, color: '#ff5555', velocityX: 1, velocityY: 0, pattern: 'loop' },
                    { x: 0.625, y: 0.667, width: 0.05, height: 0.067, color: '#ff5555', velocityX: -1, velocityY: 0, pattern: 'loop' }
                ],
                playerStart: { x: 0.5, y: 0.917 },
                exit: { x: 0.5, y: 0.083, width: 0.075, height: 0.033 },
                mapSize: { width: 1, height: 1 }
            },
            // Level 5
            {
                id: 5,
                name: "Accept Fate",
                description: "Jumping backwards moves you forward",
                backgroundColor: '#2a2a1a',
                echoes: [
                    { x: 0.125, y: 0.167, collected: false },
                    { x: 0.875, y: 0.167, collected: false },
                    { x: 0.5, y: 0.333, collected: false },
                    { x: 0.25, y: 0.667, collected: false },
                    { x: 0.75, y: 0.667, collected: false }
                ],
                obstacles: [
                    { x: 0.375, y: 0.5, width: 0.25, height: 0.033, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.5, y: 0.583, width: 0.025, height: 0.167, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' }
                ],
                playerStart: { x: 0.5, y: 0.917 },
                exit: { x: 0.5, y: 0.083, width: 0.075, height: 0.033 },
                mapSize: { width: 1, height: 1 }
            },
            // Level 6
            {
                id: 6,
                name: "Quantum Entanglement",
                description: "Two particles, one fate",
                backgroundColor: '#1a0a2a',
                echoes: [
                    { x: 0.2, y: 0.2, collected: false },
                    { x: 0.8, y: 0.2, collected: false },
                    { x: 0.5, y: 0.4, collected: false },
                    { x: 0.3, y: 0.7, collected: false },
                    { x: 0.7, y: 0.7, collected: false }
                ],
                obstacles: [
                    { x: 0.3, y: 0.5, width: 0.4, height: 0.033, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.5, y: 0.3, width: 0.033, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.2, y: 0.3, width: 0.05, height: 0.05, color: '#5555ff', velocityX: 1, velocityY: 0, pattern: 'quantum', pair: 0 },
                    { x: 0.8, y: 0.7, width: 0.05, height: 0.05, color: '#5555ff', velocityX: -1, velocityY: 0, pattern: 'quantum', pair: 0 }
                ],
                playerStart: { x: 0.5, y: 0.917 },
                exit: { x: 0.5, y: 0.083, width: 0.075, height: 0.033 },
                mapSize: { width: 1, height: 1 }
            },
            // Level 7
            {
                id: 7,
                name: "Parallel Thoughts",
                description: "Multiple paths, one destination",
                backgroundColor: '#0a1a2a',
                echoes: [
                    { x: 0.1, y: 0.2, collected: false },
                    { x: 0.5, y: 0.2, collected: false },
                    { x: 0.9, y: 0.2, collected: false },
                    { x: 0.3, y: 0.5, collected: false },
                    { x: 0.7, y: 0.5, collected: false }
                ],
                obstacles: [
                    { x: 0.2, y: 0.4, width: 0.6, height: 0.033, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.2, y: 0.6, width: 0.6, height: 0.033, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.3, y: 0.7, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0.5, velocityY: 0.5, pattern: 'bounce' },
                    { x: 0.7, y: 0.3, width: 0.05, height: 0.05, color: '#ff5555', velocityX: -0.5, velocityY: -0.5, pattern: 'bounce' }
                ],
                playerStart: { x: 0.5, y: 0.917 },
                exit: { x: 0.5, y: 0.083, width: 0.075, height: 0.033 },
                mapSize: { width: 1, height: 1 }
            },
            // Level 8
            {
                id: 8,
                name: "Singularity",
                description: "All paths converge",
                backgroundColor: '#1a0a1a',
                echoes: [
                    { x: 0.2, y: 0.2, collected: false },
                    { x: 0.8, y: 0.2, collected: false },
                    { x: 0.2, y: 0.8, collected: false },
                    { x: 0.8, y: 0.8, collected: false },
                    { x: 0.5, y: 0.5, collected: false }
                ],
                obstacles: [
                    { x: 0.3, y: 0.3, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0.7, velocityY: 0.7, pattern: 'gravity' },
                    { x: 0.7, y: 0.3, width: 0.05, height: 0.05, color: '#ff5555', velocityX: -0.7, velocityY: 0.7, pattern: 'gravity' },
                    { x: 0.3, y: 0.7, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0.7, velocityY: -0.7, pattern: 'gravity' },
                    { x: 0.7, y: 0.7, width: 0.05, height: 0.05, color: '#ff5555', velocityX: -0.7, velocityY: -0.7, pattern: 'gravity' }
                ],
                playerStart: { x: 0.5, y: 0.917 },
                exit: { x: 0.5, y: 0.083, width: 0.075, height: 0.033 },
                mapSize: { width: 1, height: 1 }
            },
            // Level 9
            {
                id: 9,
                name: "Labyrinth of Thought",
                description: "Navigate the maze of your mind",
                backgroundColor: '#0a0a2a',
                echoes: [
                    { x: 0.1, y: 0.1, collected: false },
                    { x: 0.9, y: 0.1, collected: false },
                    { x: 0.1, y: 0.9, collected: false },
                    { x: 0.9, y: 0.9, collected: false },
                    { x: 0.5, y: 0.5, collected: false }
                ],
                obstacles: [
                    // Maze walls
                    { x: 0.2, y: 0.2, width: 0.6, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' }, // obere Wand
                    { x: 0.2, y: 0.8, width: 0.6, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' }, // untere Wand
                    { x: 0.2, y: 0.4, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' }, // linke Wand unten halb hoch
                    { x: 0.8, y: 0.4, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' }, // rechte Wand unten halb hoch
                    // Innere Mauern als kleine Barrieren, die Wege offenlassen
                    { x: 0.4, y: 0.3, width: 0.2, height: 0.02, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.4, y: 0.6, width: 0.2, height: 0.02, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' }
                ],
                playerStart: { x: 0.5, y: 0.917 },
                exit: { x: 0.5, y: 0.083, width: 0.075, height: 0.033 },
                mapSize: { width: 1, height: 1 }
            },
            // Level 10 - Quiz Level
            {
                id: 10,
                name: "Stoic Wisdom",
                description: "Test your knowledge of Stoicism",
                backgroundColor: '#1a1a3a',
                echoes: [],
                obstacles: [],
                playerStart: { x: 0.5, y: 0.5 },
                exit: { x: 0.5, y: 0.5, width: 0, height: 0 },
                isQuiz: true,
                mapSize: { width: 1, height: 1 }
            },
            // Level 11
            {
                id: 11,
                name: "Expanding Horizons",
                description: "The world grows larger",
                backgroundColor: '#1a2a2a',
                echoes: [
                    { x: 0.1, y: 0.1, collected: false },
                    { x: 0.9, y: 0.1, collected: false },
                    { x: 0.1, y: 0.9, collected: false },
                    { x: 0.9, y: 0.9, collected: false },
                    { x: 0.5, y: 0.5, collected: false },
                    { x: 1.1, y: 0.5, collected: false },
                    { x: 1.5, y: 0.5, collected: false }
                ],
                obstacles: [
                    { x: 0.3, y: 0.3, width: 0.4, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.7, y: 0.7, width: 0.4, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 0.3, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.3, y: 0.7, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.5, y: 0.2, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0.5, velocityY: 0, pattern: 'horizontal' },
                    { x: 1.2, y: 0.8, width: 0.05, height: 0.05, color: '#ff5555', velocityX: -0.5, velocityY: 0, pattern: 'horizontal' }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 1.7, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 1.8, height: 1 } // Wider map
            },
            // Level 12
            {
                id: 12,
                name: "Temporal Distortion",
                description: "Time moves differently in different spaces",
                backgroundColor: '#2a1a2a',
                echoes: [
                    { x: 0.2, y: 0.2, collected: false },
                    { x: 0.8, y: 0.2, collected: false },
                    { x: 0.2, y: 0.8, collected: false },
                    { x: 0.8, y: 0.8, collected: false },
                    { x: 0.5, y: 0.5, collected: false },
                    { x: 1.2, y: 0.5, collected: false }
                ],
                obstacles: [
                    { x: 0.5, y: 0.5, width: 0.03, height: 0.5, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 0.25, width: 0.03, height: 0.5, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.3, y: 0.3, width: 0.05, height: 0.05, color: '#5555ff', velocityX: 0.3, velocityY: 0.3, pattern: 'timeZone', timeMultiplier: 2 },
                    { x: 0.7, y: 0.7, width: 0.05, height: 0.05, color: '#5555ff', velocityX: -0.3, velocityY: -0.3, pattern: 'timeZone', timeMultiplier: 0.5 }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 1.4, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 1.5, height: 1 }
            },
            // Level 13
            {
                id: 13,
                name: "Perspective Shift",
                description: "Change your viewpoint to solve the puzzle",
                backgroundColor: '#0a2a1a',
                echoes: [
                    { x: 0.2, y: 0.2, collected: false },
                    { x: 0.8, y: 0.2, collected: false },
                    { x: 0.2, y: 0.8, collected: false },
                    { x: 0.8, y: 0.8, collected: false },
                    { x: 1.2, y: 0.2, collected: false },
                    { x: 1.2, y: 0.8, collected: false }
                ],
                obstacles: [
                    { x: 0.5, y: 0.5, width: 0.5, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 0.5, width: 0.5, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.5, y: 0.3, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: 0.5, pattern: 'vertical' },
                    { x: 1.0, y: 0.7, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: -0.5, pattern: 'vertical' },
                    { x: 0.7, y: 0.2, width: 0.05, height: 0.05, color: '#5555ff', velocityX: 0.3, velocityY: 0, pattern: 'teleport', targetX: 1.2, targetY: 0.5 }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 1.5, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 1.6, height: 1 }
            },
            // Level 14
            {
                id: 14,
                name: "Chaos Theory",
                description: "Small changes lead to unpredictable results",
                backgroundColor: '#1a0a1a',
                echoes: [
                    { x: 0.3, y: 0.3, collected: false },
                    { x: 0.7, y: 0.3, collected: false },
                    { x: 0.3, y: 0.7, collected: false },
                    { x: 0.7, y: 0.7, collected: false },
                    { x: 1.3, y: 0.3, collected: false },
                    { x: 1.3, y: 0.7, collected: false }
                ],
                obstacles: [
                    { x: 0.5, y: 0.5, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0.5, velocityY: 0.5, pattern: 'chaos' },
                    { x: 1.0, y: 0.5, width: 0.05, height: 0.05, color: '#ff5555', velocityX: -0.5, velocityY: -0.5, pattern: 'chaos' },
                    { x: 1.5, y: 0.5, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: 0.7, pattern: 'chaos' }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 1.7, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 1.8, height: 1 }
            },
            // Level 15
            {
                id: 15,
                name: "Duality",
                description: "Two sides of the same reality",
                backgroundColor: '#2a2a2a',
                echoes: [
                    { x: 0.2, y: 0.2, collected: false },
                    { x: 0.8, y: 0.2, collected: false },
                    { x: 0.2, y: 0.8, collected: false },
                    { x: 0.8, y: 0.8, collected: false },
                    { x: 0.5, y: 0.5, collected: false },
                    { x: 1.5, y: 0.5, collected: false }
                ],
                obstacles: [
                    { x: 0.5, y: 0.0, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.5, y: 0.6, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 0.3, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 0.9, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.5, y: 0.0, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.5, y: 0.6, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.3, y: 0.5, width: 0.05, height: 0.05, color: '#5555ff', velocityX: 0.3, velocityY: 0, pattern: 'duality', pair: 0 },
                    { x: 1.3, y: 0.5, width: 0.05, height: 0.05, color: '#5555ff', velocityX: -0.3, velocityY: 0, pattern: 'duality', pair: 0 }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 1.8, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 2, height: 1 }
            },
            // Level 16
            {
                id: 16,
                name: "Expanding Mind",
                description: "Your consciousness grows beyond boundaries",
                backgroundColor: '#0a1a2a',
                echoes: [
                    { x: 0.2, y: 0.2, collected: false },
                    { x: 0.8, y: 0.2, collected: false },
                    { x: 0.2, y: 0.8, collected: false },
                    { x: 0.8, y: 0.8, collected: false },
                    { x: 1.2, y: 0.2, collected: false },
                    { x: 1.8, y: 0.2, collected: false },
                    { x: 1.2, y: 0.8, collected: false },
                    { x: 1.8, y: 0.8, collected: false }
                ],
                obstacles: [
                    { x: 0.5, y: 0.5, width: 0.5, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 0.5, width: 0.5, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.5, y: 0.5, width: 0.5, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.3, y: 0.3, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0.5, velocityY: 0, pattern: 'horizontal' },
                    { x: 1.3, y: 0.7, width: 0.05, height: 0.05, color: '#ff5555', velocityX: -0.5, velocityY: 0, pattern: 'horizontal' },
                    { x: 1.7, y: 0.3, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: 0.5, pattern: 'vertical' }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 1.9, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 2, height: 1 }
            },
            // Level 17
            {
                id: 17,
                name: "Fractal Patterns",
                description: "Patterns within patterns",
                backgroundColor: '#1a2a1a',
                echoes: [
                    { x: 0.2, y: 0.2, collected: false },
                    { x: 0.8, y: 0.2, collected: false },
                    { x: 0.2, y: 0.8, collected: false },
                    { x: 0.8, y: 0.8, collected: false },
                    { x: 1.2, y: 0.2, collected: false },
                    { x: 1.8, y: 0.2, collected: false },
                    { x: 1.2, y: 0.8, collected: false },
                    { x: 1.8, y: 0.8, collected: false }
                ],
                obstacles: [
                    // Fractal pattern obstacles
                    { x: 0.5, y: 0.5, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0.3, velocityY: 0.3, pattern: 'fractal', spawnTime: 3000, spawnCount: 2 },
                    { x: 1.5, y: 0.5, width: 0.05, height: 0.05, color: '#ff5555', velocityX: -0.3, velocityY: -0.3, pattern: 'fractal', spawnTime: 3000, spawnCount: 2 }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 1.9, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 2, height: 1 }
            },
            // Level 18
            {
                id: 18,
                name: "Dimensional Shift",
                description: "Navigate through multiple dimensions",
                backgroundColor: '#2a0a2a',
                echoes: [
                    { x: 0.2, y: 0.2, collected: false },
                    { x: 0.8, y: 0.2, collected: false },
                    { x: 0.2, y: 0.8, collected: false },
                    { x: 0.8, y: 0.8, collected: false },
                    { x: 1.2, y: 0.2, collected: false },
                    { x: 1.8, y: 0.2, collected: false },
                    { x: 1.2, y: 0.8, collected: false },
                    { x: 1.8, y: 0.8, collected: false }
                ],
                obstacles: [
                    { x: 0.5, y: 0.0, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.5, y: 0.6, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 0.3, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 0.9, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.5, y: 0.0, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.5, y: 0.6, width: 0.03, height: 0.4, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.3, y: 0.5, width: 0.1, height: 0.1, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'portal', targetX: 1.3, targetY: 0.5 },
                    { x: 1.7, y: 0.5, width: 0.1, height: 0.1, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'portal', targetX: 0.7, targetY: 0.5 }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 1.9, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 2, height: 1 }
            },
            // Level 19
            {
                id: 19,
                name: "Cognitive Dissonance",
                description: "Contradictory beliefs create tension",
                backgroundColor: '#1a1a2a',
                echoes: [
                    { x: 0.2, y: 0.2, collected: false },
                    { x: 0.8, y: 0.2, collected: false },
                    { x: 0.2, y: 0.8, collected: false },
                    { x: 0.8, y: 0.8, collected: false },
                    { x: 1.2, y: 0.2, collected: false },
                    { x: 1.8, y: 0.2, collected: false },
                    { x: 1.2, y: 0.8, collected: false },
                    { x: 1.8, y: 0.8, collected: false }
                ],
                obstacles: [
                    { x: 0.5, y: 0.5, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0.5, velocityY: 0, pattern: 'repel' },
                    { x: 1.0, y: 0.3, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: 0.5, pattern: 'repel' },
                    { x: 1.5, y: 0.7, width: 0.05, height: 0.05, color: '#ff5555', velocityX: -0.5, velocityY: 0, pattern: 'repel' },
                    { x: 0.3, y: 0.3, width: 0.05, height: 0.05, color: '#5555ff', velocityX: 0.3, velocityY: 0.3, pattern: 'attract' },
                    { x: 1.7, y: 0.7, width: 0.05, height: 0.05, color: '#5555ff', velocityX: -0.3, velocityY: -0.3, pattern: 'attract' }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 1.9, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 2, height: 1 }
            },
            // Level 20 - Quiz Level
            {
                id: 20,
                name: "Self-Improvement Wisdom",
                description: "Test your knowledge of personal growth",
                backgroundColor: '#1a2a2a',
                echoes: [],
                obstacles: [],
                playerStart: { x: 0.5, y: 0.5 },
                exit: { x: 0.5, y: 0.5, width: 0, height: 0 },
                isQuiz: true,
                mapSize: { width: 1, height: 1 }
            },
            // Additional levels can be added here...
            // Level 21
            {
                id: 21,
                name: "Inner Reflection",
                description: "Look within to find your path",
                backgroundColor: '#2a1a0a',
                echoes: [
                    { x: 0.2, y: 0.3, collected: false },
                    { x: 0.4, y: 0.7, collected: false },
                    { x: 0.6, y: 0.3, collected: false },
                    { x: 0.8, y: 0.7, collected: false },
                    { x: 1.0, y: 0.3, collected: false },
                    { x: 1.2, y: 0.7, collected: false },
                    { x: 1.4, y: 0.3, collected: false },
                    { x: 1.6, y: 0.7, collected: false }
                ],
                obstacles: [
                    { x: 0.5, y: 0.5, width: 1.0, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 0.25, width: 0.03, height: 0.5, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.3, y: 0.2, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0.4, velocityY: 0, pattern: 'horizontal', bounds: { min: 0.3, max: 0.7 } },
                    { x: 1.3, y: 0.8, width: 0.05, height: 0.05, color: '#ff5555', velocityX: -0.4, velocityY: 0, pattern: 'horizontal', bounds: { min: 1.1, max: 1.5 } },
                    { x: 0.7, y: 0.4, width: 0.05, height: 0.05, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'mirror', reflectX: true, reflectY: false },
                    { x: 1.2, y: 0.4, width: 0.05, height: 0.05, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'mirror', reflectX: false, reflectY: true }
                ],
                playerStart: { x: 0.1, y: 0.2 },
                exit: { x: 1.9, y: 0.8, width: 0.075, height: 0.1 },
                mapSize: { width: 2, height: 1 }
            },
            // Level 22
            {
                id: 22,
                name: "Adaptive Mindset",
                description: "Change your approach as the environment changes",
                backgroundColor: '#0a2a1a',
                echoes: [
                    { x: 0.2, y: 0.2, collected: false },
                    { x: 0.5, y: 0.5, collected: false },
                    { x: 0.8, y: 0.2, collected: false },
                    { x: 0.2, y: 0.8, collected: false },
                    { x: 0.8, y: 0.8, collected: false },
                    { x: 1.3, y: 0.3, collected: false },
                    { x: 1.7, y: 0.7, collected: false },
                    { x: 1.3, y: 0.7, collected: false }
                ],
                obstacles: [
                    { x: 0.5, y: 0.5, width: 0.5, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'phase', phaseTime: 3000 },
                    { x: 1.0, y: 0.5, width: 0.03, height: 0.5, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'phase', phaseTime: 5000 },
                    { x: 1.5, y: 0.5, width: 0.5, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'phase', phaseTime: 7000 },
                    { x: 0.3, y: 0.3, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0.3, velocityY: 0.3, pattern: 'chase', chaseSpeed: 0.1 },
                    { x: 1.3, y: 0.5, width: 0.05, height: 0.05, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'timeZone', timeMultiplier: 0.3, radius: 0.2 }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 1.9, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 2, height: 1 }
            },

            // Level 23
            {
                id: 23,
                name: "Balancing Act",
                description: "Find harmony between opposing forces",
                backgroundColor: '#1a0a2a',
                echoes: [
                    { x: 0.2, y: 0.2, collected: false },
                    { x: 0.2, y: 0.8, collected: false },
                    { x: 0.8, y: 0.5, collected: false },
                    { x: 1.2, y: 0.2, collected: false },
                    { x: 1.2, y: 0.8, collected: false },
                    { x: 1.8, y: 0.5, collected: false },
                    { x: 2.2, y: 0.2, collected: false },
                    { x: 2.2, y: 0.8, collected: false },
                    { x: 2.8, y: 0.5, collected: false }
                ],
                obstacles: [
                    { x: 0.5, y: 0.5, width: 0.03, height: 0.6, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'rotate', centerX: 0.5, centerY: 0.5, speed: 0.02 },
                    { x: 1.5, y: 0.5, width: 0.03, height: 0.6, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'rotate', centerX: 1.5, centerY: 0.5, speed: -0.02 },
                    { x: 2.5, y: 0.5, width: 0.03, height: 0.6, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'rotate', centerX: 2.5, centerY: 0.5, speed: 0.03 },
                    { x: 1.0, y: 0.2, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: 0.4, pattern: 'vertical', bounds: { min: 0.2, max: 0.8 } },
                    { x: 2.0, y: 0.8, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: -0.4, pattern: 'vertical', bounds: { min: 0.2, max: 0.8 } },
                    { x: 1.0, y: 0.5, width: 0.1, height: 0.1, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'gravity', strength: 0.02, radius: 0.3 },
                    { x: 2.0, y: 0.5, width: 0.1, height: 0.1, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'antigravity', strength: 0.02, radius: 0.3 }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 2.9, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 3, height: 1 }
            },

            // Level 24
            {
                id: 24,
                name: "Paradigm Shift",
                description: "Sometimes you must change your entire perspective",
                backgroundColor: '#2a2a0a',
                echoes: [
                    { x: 0.3, y: 0.3, collected: false },
                    { x: 0.7, y: 0.7, collected: false },
                    { x: 1.3, y: 0.3, collected: false },
                    { x: 1.7, y: 0.7, collected: false },
                    { x: 2.3, y: 0.3, collected: false },
                    { x: 2.7, y: 0.7, collected: false },
                    { x: 0.7, y: 1.3, collected: false },
                    { x: 1.3, y: 1.7, collected: false },
                    { x: 2.3, y: 1.3, collected: false }
                ],
                obstacles: [
                    // Horizontal barriers
                    { x: 1.0, y: 0.5, width: 0.6, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 2.0, y: 0.5, width: 0.6, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 1.5, width: 0.6, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 2.0, y: 1.5, width: 0.6, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    
                    // Vertical barriers
                    { x: 0.5, y: 1.0, width: 0.03, height: 0.6, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.5, y: 1.0, width: 0.03, height: 0.6, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 2.5, y: 1.0, width: 0.03, height: 0.6, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    
                    // Moving obstacles
                    { x: 0.8, y: 0.3, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0.3, velocityY: 0, pattern: 'horizontal', bounds: { min: 0.3, max: 1.3 } },
                    { x: 1.8, y: 0.7, width: 0.05, height: 0.05, color: '#ff5555', velocityX: -0.3, velocityY: 0, pattern: 'horizontal', bounds: { min: 1.3, max: 2.3 } },
                    { x: 1.2, y: 1.3, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: 0.3, pattern: 'vertical', bounds: { min: 0.8, max: 1.8 } },
                    
                    // Dimension shifters
                    { x: 0.5, y: 0.5, width: 0.1, height: 0.1, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'dimensionShift', targetX: 0.5, targetY: 1.5, shiftAxis: 'y' },
                    { x: 1.5, y: 0.5, width: 0.1, height: 0.1, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'dimensionShift', targetX: 2.5, targetY: 0.5, shiftAxis: 'x' },
                    { x: 2.5, y: 1.5, width: 0.1, height: 0.1, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'dimensionShift', targetX: 0.5, targetY: 0.5, shiftAxis: 'both' }
                ],
                playerStart: { x: 0.1, y: 0.1 },
                exit: { x: 2.9, y: 1.9, width: 0.075, height: 0.1 },
                mapSize: { width: 3, height: 2 }
            },
            // Level 25
            {
                id: 25,
                name: "Quantum Entanglement",
                description: "Connected across space and time",
                backgroundColor: '#0a0a2a',
                echoes: [
                    { x: 0.3, y: 0.3, collected: false },
                    { x: 0.7, y: 0.3, collected: false },
                    { x: 0.3, y: 0.7, collected: false },
                    { x: 0.7, y: 0.7, collected: false },
                    { x: 1.3, y: 0.3, collected: false },
                    { x: 1.7, y: 0.3, collected: false },
                    { x: 1.3, y: 0.7, collected: false },
                    { x: 1.7, y: 0.7, collected: false },
                    { x: 2.3, y: 0.3, collected: false },
                    { x: 2.3, y: 0.7, collected: false }
                ],
                obstacles: [
                    // Static barriers
                    { x: 1.0, y: 0.5, width: 0.03, height: 1.0, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 2.0, y: 0.5, width: 0.03, height: 1.0, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    
                    // Quantum entangled obstacles - move in sync
                    { x: 0.3, y: 0.5, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: 0.3, pattern: 'entangled', pair: 0, bounds: { min: 0.2, max: 0.8 } },
                    { x: 1.3, y: 0.5, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: 0.3, pattern: 'entangled', pair: 0, bounds: { min: 0.2, max: 0.8 } },
                    
                    // Quantum entangled obstacles - move opposite
                    { x: 0.7, y: 0.2, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0.3, velocityY: 0, pattern: 'entangled', pair: 1, bounds: { min: 0.2, max: 0.8 }, reverseSync: true },
                    { x: 1.7, y: 0.8, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0.3, velocityY: 0, pattern: 'entangled', pair: 1, bounds: { min: 1.2, max: 1.8 }, reverseSync: true },
                    
                    // Quantum tunnels - probability-based teleportation
                    { x: 0.5, y: 0.5, width: 0.1, height: 0.1, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'quantumTunnel', probability: 0.3, destinations: [
                        { x: 1.5, y: 0.5 },
                        { x: 2.5, y: 0.5 }
                    ]},
                    
                    // Uncertainty zone - player movement becomes probabilistic
                    { x: 2.5, y: 0.5, width: 0.3, height: 0.3, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'uncertainty', strength: 0.4 }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 2.9, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 3, height: 1 }
            },

            // Level 26
            {
                id: 26,
                name: "Memory Palace",
                description: "Build a mental structure to organize knowledge",
                backgroundColor: '#0a0a0a',
                echoes: [
                    { x: 0.5, y: 0.2, collected: false },
                    { x: 1.5, y: 0.2, collected: false },
                    { x: 2.5, y: 0.2, collected: false },
                    { x: 0.5, y: 0.8, collected: false },
                    { x: 1.5, y: 0.8, collected: false },
                    { x: 2.5, y: 0.8, collected: false },
                    { x: 0.5, y: 1.4, collected: false },
                    { x: 1.5, y: 1.4, collected: false },
                    { x: 2.5, y: 1.4, collected: false },
                    { x: 0.5, y: 2.0, collected: false },
                    { x: 1.5, y: 2.0, collected: false },
                    { x: 2.5, y: 2.0, collected: false }
                ],
                obstacles: [
                    // Memory palace chambers - each must be visited in sequence
                    { x: 0.5, y: 0.5, width: 0.5, height: 0.5, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'memoryRoom', sequence: 1, activationTime: 2000 },
                    { x: 1.5, y: 0.5, width: 0.5, height: 0.5, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'memoryRoom', sequence: 2, activationTime: 2000 },
                    { x: 2.5, y: 0.5, width: 0.5, height: 0.5, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'memoryRoom', sequence: 3, activationTime: 2000 },
                    { x: 2.5, y: 1.5, width: 0.5, height: 0.5, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'memoryRoom', sequence: 4, activationTime: 2000 },
                    { x: 1.5, y: 1.5, width: 0.5, height: 0.5, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'memoryRoom', sequence: 5, activationTime: 2000 },
                    { x: 0.5, y: 1.5, width: 0.5, height: 0.5, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'memoryRoom', sequence: 6, activationTime: 2000 },
                    
                    // Memory guardians - obstacles that patrol the paths between chambers
                    { x: 1.0, y: 0.5, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: 0.3, pattern: 'vertical', bounds: { min: 0.2, max: 0.8 } },
                    { x: 2.0, y: 0.5, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: 0.3, pattern: 'vertical', bounds: { min: 0.2, max: 0.8 } },
                    { x: 2.5, y: 1.0, width: 0.05, height: 0.05, color: '#ff5555', velocityX: -0.3, velocityY: 0, pattern: 'horizontal', bounds: { min: 2.2, max: 2.8 } },
                    { x: 2.0, y: 1.5, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: -0.3, pattern: 'vertical', bounds: { min: 1.2, max: 1.8 } },
                    { x: 1.0, y: 1.5, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: -0.3, pattern: 'vertical', bounds: { min: 1.2, max: 1.8 } },
                    
                    // Forgetting mist - causes player to "forget" (reset) memory room sequence if touched
                    { x: 1.5, y: 1.0, width: 0.3, height: 0.1, color: '#ff5555', velocityX: 0.1, velocityY: 0, pattern: 'forgettingMist', bounds: { min: 1.0, max: 2.0 } }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 0.1, y: 1.5, width: 0.075, height: 0.1 },
                mapSize: { width: 3, height: 2 }
            },
            // Level 27
            {
                id: 27,
                name: "Quantum Superposition",
                description: "Exist in multiple states simultaneously",
                backgroundColor: '#1a1a2a',
                echoes: [
                    { x: 0.3, y: 0.3, collected: false },
                    { x: 0.7, y: 0.3, collected: false },
                    { x: 1.7, y: 0.3, collected: false },
                    { x: 0.3, y: 0.7, collected: false },
                    { x: 1.3, y: 0.7, collected: false },
                    { x: 1.7, y: 0.7, collected: false },
                    { x: 1.0, y: 0.5, collected: false },
                    { x: 2.0, y: 0.5, collected: false }
                ],
                obstacles: [
                    // Central barrier with a small gap
                    { x: 1.0, y: 0.2, width: 0.03, height: 0.2, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 0.8, width: 0.03, height: 0.2, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    
                    // Quantum barriers - only exist in one reality at a time
                    { x: 0.5, y: 0.5, width: 0.5, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'quantum', phaseTime: 1500, phaseOffset: 0 },
                    { x: 1.5, y: 0.5, width: 0.5, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'quantum', phaseTime: 1500, phaseOffset: 750 },
                    
                    // Reality flippers - change which quantum obstacles are visible
                    { x: 0.8, y: 0.5, width: 0.08, height: 0.08, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'realityFlipper', flipTime: 500 },
                    { x: 1.2, y: 0.5, width: 0.08, height: 0.08, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'realityFlipper', flipTime: 500 },
                    
                    // Patrolling obstacles with wave pattern
                    { x: 0.5, y: 0.2, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0.15, velocityY: 0.1, pattern: 'wave', amplitude: 0.2, frequency: 0.05 },
                    { x: 1.5, y: 0.8, width: 0.05, height: 0.05, color: '#ff5555', velocityX: -0.15, velocityY: -0.1, pattern: 'wave', amplitude: 0.2, frequency: 0.05 }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 2.4, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 2.5, height: 1 }
            },

            // Level 28
            {
                id: 28,
                name: "Labyrinth of Thought",
                description: "Follow the thread through the maze of your mind",
                backgroundColor: '#0a1a2a',
                echoes: [
                    { x: 0.5, y: 0.2, collected: false },
                    { x: 0.2, y: 0.5, collected: false },
                    { x: 0.5, y: 0.8, collected: false },
                    { x: 0.8, y: 0.5, collected: false },
                    { x: 1.5, y: 0.2, collected: false },
                    { x: 1.2, y: 0.5, collected: false },
                    { x: 1.5, y: 0.8, collected: false },
                    { x: 1.8, y: 0.5, collected: false },
                    { x: 2.5, y: 0.2, collected: false },
                    { x: 2.2, y: 0.5, collected: false }
                ],
                obstacles: [
                    // Labyrinth walls
                    { x: 0.5, y: 0.4, width: 0.6, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.5, y: 0.6, width: 0.6, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.3, y: 0.5, width: 0.03, height: 0.2, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.7, y: 0.5, width: 0.03, height: 0.2, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    
                    { x: 1.5, y: 0.4, width: 0.6, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.5, y: 0.6, width: 0.6, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.3, y: 0.5, width: 0.03, height: 0.2, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.7, y: 0.5, width: 0.03, height: 0.2, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    
                    { x: 2.5, y: 0.4, width: 0.6, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 2.5, y: 0.6, width: 0.6, height: 0.03, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 2.3, y: 0.5, width: 0.03, height: 0.2, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 2.7, y: 0.5, width: 0.03, height: 0.2, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'static' },
                    
                    // Portals between chambers
                    { x: 0.9, y: 0.3, width: 0.08, height: 0.08, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'portal', targetX: 1.1, targetY: 0.3, cooldown: 1000 },
                    { x: 0.9, y: 0.7, width: 0.08, height: 0.08, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'portal', targetX: 1.1, targetY: 0.7, cooldown: 1000 },
                    { x: 1.9, y: 0.3, width: 0.08, height: 0.08, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'portal', targetX: 2.1, targetY: 0.3, cooldown: 1000 },
                    { x: 1.9, y: 0.7, width: 0.08, height: 0.08, color: '#5555ff', velocityX: 0, velocityY: 0, pattern: 'portal', targetX: 2.1, targetY: 0.7, cooldown: 1000 },
                    
                    // Guardian that follows a complex path
                    { x: 0.5, y: 0.5, width: 0.06, height: 0.06, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'path', 
                    path: [
                        { x: 0.5, y: 0.5 }, { x: 0.5, y: 0.3 }, { x: 0.5, y: 0.5 }, { x: 0.3, y: 0.5 }, 
                        { x: 0.5, y: 0.5 }, { x: 0.5, y: 0.7 }, { x: 0.5, y: 0.5 }, { x: 0.7, y: 0.5 }
                    ],
                    speed: 0.2
                    },
                    { x: 1.5, y: 0.5, width: 0.06, height: 0.06, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'path', 
                    path: [
                        { x: 1.5, y: 0.5 }, { x: 1.5, y: 0.3 }, { x: 1.5, y: 0.5 }, { x: 1.3, y: 0.5 }, 
                        { x: 1.5, y: 0.5 }, { x: 1.5, y: 0.7 }, { x: 1.5, y: 0.5 }, { x: 1.7, y: 0.5 }
                    ],
                    speed: 0.3
                    },
                    { x: 2.5, y: 0.5, width: 0.06, height: 0.06, color: '#ff5555', velocityX: 0, velocityY: 0, pattern: 'path', 
                    path: [
                        { x: 2.5, y: 0.5 }, { x: 2.5, y: 0.3 }, { x: 2.5, y: 0.5 }, { x: 2.3, y: 0.5 }, 
                        { x: 2.5, y: 0.5 }, { x: 2.5, y: 0.7 }, { x: 2.5, y: 0.5 }, { x: 2.7, y: 0.5 }
                    ],
                    speed: 0.4
                    }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 2.9, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 3, height: 1 }
            },
            // Level 29
            {
                id: 29,
                name: "Temporal Paradox",
                description: "Your past and future selves collide",
                backgroundColor: '#1a0030',
                echoes: [
                    { x: 0.2, y: 0.2, collected: false },
                    { x: 0.8, y: 0.2, collected: false },
                    { x: 1.5, y: 0.2, collected: false },
                    { x: 2.2, y: 0.2, collected: false },
                    { x: 0.2, y: 0.8, collected: false },
                    { x: 0.8, y: 0.8, collected: false },
                    { x: 1.5, y: 0.8, collected: false },
                    { x: 2.2, y: 0.8, collected: false },
                    { x: 1.2, y: 0.5, collected: false },
                    { x: 2.5, y: 0.5, collected: false }
                ],
                obstacles: [
                    // Time barrier - only passable during "time shift"
                    { x: 1.0, y: 0.5, width: 0.05, height: 1.0, color: '#8800ff', velocityX: 0, velocityY: 0, pattern: 'timeBarrier', phase: 3000 },
                    { x: 2.0, y: 0.5, width: 0.05, height: 1.0, color: '#8800ff', velocityX: 0, velocityY: 0, pattern: 'timeBarrier', phase: 4000 },
                    
                    // Echo enemies - they mimic your previous movements with delay
                    { x: 0.5, y: 0.5, width: 0.06, height: 0.06, color: '#ff2288', velocityX: 0, velocityY: 0, pattern: 'echo', delay: 2000, duration: 10000 },
                    { x: 1.5, y: 0.5, width: 0.06, height: 0.06, color: '#ff2288', velocityX: 0, velocityY: 0, pattern: 'echo', delay: 1500, duration: 8000 },
                    { x: 2.5, y: 0.5, width: 0.06, height: 0.06, color: '#ff2288', velocityX: 0, velocityY: 0, pattern: 'echo', delay: 1000, duration: 6000 },
                    
                    // Time vortexes - teleport player forward or backward in time (position)
                    { x: 0.3, y: 0.5, width: 0.1, height: 0.1, color: '#22ffff', velocityX: 0, velocityY: 0, pattern: 'timeVortex', destination: { x: 1.7, y: 0.5 }, cooldown: 2000 },
                    { x: 1.3, y: 0.3, width: 0.1, height: 0.1, color: '#22ffff', velocityX: 0, velocityY: 0, pattern: 'timeVortex', destination: { x: 2.3, y: 0.7 }, cooldown: 2000 },
                    { x: 2.7, y: 0.3, width: 0.1, height: 0.1, color: '#22ffff', velocityX: 0, velocityY: 0, pattern: 'timeVortex', destination: { x: 0.7, y: 0.7 }, cooldown: 2000 },
                    
                    // Time distortion fields - movement speed changes
                    { x: 0.6, y: 0.3, width: 0.3, height: 0.2, color: 'rgba(255, 150, 255, 0.2)', velocityX: 0, velocityY: 0, pattern: 'timeField', speedFactor: 0.5 },
                    { x: 1.6, y: 0.7, width: 0.3, height: 0.2, color: 'rgba(150, 255, 255, 0.2)', velocityX: 0, velocityY: 0, pattern: 'timeField', speedFactor: 1.5 },
                    
                    // Synced obstacles - move at impossible speeds but with predictable patterns
                    { x: 0.2, y: 0.5, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0.8, velocityY: 0, pattern: 'blink', blinkRate: 500, pauseTime: 200 },
                    { x: 1.2, y: 0.3, width: 0.05, height: 0.05, color: '#ff5555', velocityX: 0, velocityY: 0.8, pattern: 'blink', blinkRate: 400, pauseTime: 200 },
                    { x: 2.7, y: 0.5, width: 0.05, height: 0.05, color: '#ff5555', velocityX: -0.8, velocityY: 0, pattern: 'blink', blinkRate: 300, pauseTime: 200 }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 2.9, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 3, height: 1 }
            },
            

            // Level 30
            {
                id: 30,
                name: "Recursion Paradox",
                description: "The part contains the whole, infinitely reflected",
                backgroundColor: '#15151f',
                echoes: [
                    { x: 0.3, y: 0.3, collected: false },
                    { x: 0.7, y: 0.3, collected: false },
                    { x: 0.3, y: 0.7, collected: false },
                    { x: 0.7, y: 0.7, collected: false },
                    { x: 1.3, y: 0.3, collected: false },
                    { x: 1.7, y: 0.3, collected: false },
                    { x: 1.3, y: 0.7, collected: false },
                    { x: 1.7, y: 0.7, collected: false },
                    { x: 0.5, y: 0.5, collected: false },
                    { x: 1.5, y: 0.5, collected: false }
                ],
                obstacles: [
                    // Fractal generator - creates smaller versions of the level inside itself
                    { x: 1.0, y: 0.5, width: 0.1, height: 0.1, color: '#00ffaa', velocityX: 0, velocityY: 0, pattern: 'fractalNode', 
                    iterations: 2, scaleFactor: 0.3, rotationPerIteration: Math.PI/4
                    },
                    
                    // Recursion portal - teleports player to scaled copy of the level
                    { x: 0.5, y: 0.5, width: 0.15, height: 0.15, color: 'rgba(100, 255, 200, 0.5)', velocityX: 0, velocityY: 0, pattern: 'recursionPortal', 
                    scaleFactor: 0.5, destination: { x: 1.25, y: 0.25 }, escapeTimer: 5000
                    },
                    { x: 1.5, y: 0.5, width: 0.15, height: 0.15, color: 'rgba(100, 255, 200, 0.5)', velocityX: 0, velocityY: 0, pattern: 'recursionPortal', 
                    scaleFactor: 2.0, destination: { x: 0.25, y: 0.25 }, escapeTimer: 5000
                    },
                    
                    // Nested barriers
                    { x: 0.5, y: 0.3, width: 0.6, height: 0.03, color: '#ff3366', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.5, y: 0.7, width: 0.6, height: 0.03, color: '#ff3366', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.3, y: 0.5, width: 0.03, height: 0.4, color: '#ff3366', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.7, y: 0.5, width: 0.03, height: 0.4, color: '#ff3366', velocityX: 0, velocityY: 0, pattern: 'static' },
                    
                    { x: 1.5, y: 0.3, width: 0.6, height: 0.03, color: '#ff3366', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.5, y: 0.7, width: 0.6, height: 0.03, color: '#ff3366', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.3, y: 0.5, width: 0.03, height: 0.4, color: '#ff3366', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.7, y: 0.5, width: 0.03, height: 0.4, color: '#ff3366', velocityX: 0, velocityY: 0, pattern: 'static' },
                    
                    // Self-referential objects - they reference their own state in the past/future
                    { x: 0.1, y: 0.1, width: 0.05, height: 0.05, color: '#ffaa33', velocityX: 0.1, velocityY: 0.1, pattern: 'selfReferential', 
                    timeOffset: -1000, interactionType: 'reflection', bounds: { xMin: 0.1, xMax: 0.9, yMin: 0.1, yMax: 0.9 }
                    },
                    { x: 1.1, y: 0.1, width: 0.05, height: 0.05, color: '#33aaff', velocityX: 0.1, velocityY: 0.1, pattern: 'selfReferential', 
                    timeOffset: 1000, interactionType: 'avoidance', bounds: { xMin: 1.1, xMax: 1.9, yMin: 0.1, yMax: 0.9 }
                    },
                    
                    // Recursive obstacle - its movement depends on its own pattern
                    { x: 1.0, y: 0.1, width: 0.05, height: 0.05, color: '#ff55ff', velocityX: 0, velocityY: 0.2, pattern: 'recursiveMovement', 
                    functionType: 'mandelbrot', maxIterations: 20, escapeRadius: 2, range: { xMin: 0.0, xMax: 2.0, yMin: 0.0, yMax: 1.0 }
                    }
                ],
                playerStart: { x: 0.1, y: 0.5 },
                exit: { x: 1.9, y: 0.5, width: 0.075, height: 0.1 },
                mapSize: { width: 2, height: 1 }
            },
            
            // Level 31
            {
                id: 31,
                name: "Mind's Labyrinth",
                description: "The path is clear only when you understand the pattern - 'Discipline is choosing between what you want now and what you want most.'",
                backgroundColor: '#0a0a20',
                echoes: [
                    // Echoes placed strategically along the correct path
                    { x: 0.15, y: 0.15, collected: false },
                    { x: 0.15, y: 0.5, collected: false },
                    { x: 0.3, y: 0.85, collected: false },
                    { x: 0.5, y: 0.85, collected: false },
                    { x: 0.7, y: 0.7, collected: false },
                    { x: 0.85, y: 0.5, collected: false },
                    { x: 0.85, y: 0.3, collected: false },
                    { x: 1.15, y: 0.15, collected: false },
                    { x: 1.3, y: 0.3, collected: false },
                    { x: 1.5, y: 0.5, collected: false },
                    { x: 1.7, y: 0.7, collected: false },
                    { x: 1.85, y: 0.85, collected: false }
                ],
                obstacles: [
                    // Main labyrinth walls - creating a clear but challenging path
                    // Outer walls
                    { x: 0.5, y: 0.1, width: 0.8, height: 0.03, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.5, y: 0.9, width: 0.8, height: 0.03, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.1, y: 0.5, width: 0.03, height: 0.8, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.9, y: 0.5, width: 0.03, height: 0.8, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    
                    // Inner maze structure - left side
                    { x: 0.3, y: 0.3, width: 0.4, height: 0.03, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.3, y: 0.5, width: 0.4, height: 0.03, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.3, y: 0.7, width: 0.4, height: 0.0, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.3, y: 0.4, width: 0.03, height: 0.2, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.5, y: 0.6, width: 0.03, height: 0.2, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 0.7, y: 0.4, width: 0.03, height: 0.2, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    
                    // Center divider with timed gate
                    { x: 1.0, y: 0.3, width: 0.03, height: 0.4, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 0.8, width: 0.03, height: 0.2, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    
                    // Timed gate in the center
                    { x: 1.0, y: 0.6, width: 0.03, height: 0.2, color: 'rgba(66, 135, 245, 0.7)', velocityX: 0, velocityY: 0, pattern: 'timedGate', 
                    openInterval: 3000, closedInterval: 2000, initialState: 'closed'
                    },
                    
                    // Right side maze structure - mirrored but with different timing
                    { x: 1.7, y: 0.3, width: 0.4, height: 0.03, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.7, y: 0.5, width: 0.4, height: 0.03, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.7, y: 0.7, width: 0.4, height: 0.03, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.3, y: 0.4, width: 0.03, height: 0.2, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.5, y: 0.6, width: 0.03, height: 0.2, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.7, y: 0.4, width: 0.03, height: 0.2, color: '#4287f5', velocityX: 0, velocityY: 0, pattern: 'static' },
                    
                    // Moving obstacle that follows a predictable pattern - requires timing to pass
                    { x: 0.5, y: 0.2, width: 0.05, height: 0.05, color: '#ff3366', velocityX: 0, velocityY: 0.1, pattern: 'patrol', 
                    pathPoints: [
                        { x: 0.5, y: 0.2 },
                        { x: 0.5, y: 0.8 },
                        { x: 0.8, y: 0.8 },
                        { x: 0.8, y: 0.2 }
                    ],
                    speed: 0.1,
                    waitTime: 500
                    },
                    
                    // Second patrolling obstacle on the right side
                    { x: 1.5, y: 0.2, width: 0.05, height: 0.05, color: '#ff3366', velocityX: 0, velocityY: 0.1, pattern: 'patrol', 
                    pathPoints: [
                        { x: 1.5, y: 0.2 },
                        { x: 1.5, y: 0.8 },
                        { x: 1.2, y: 0.8 },
                        { x: 1.2, y: 0.2 }
                    ],
                    speed: 0.1,
                    waitTime: 500
                    },
                    
                    // Boundary walls
                    { x: 0.0, y: 0.5, width: 0.02, height: 1.0, color: '#ffffff', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 2.0, y: 0.5, width: 0.02, height: 1.0, color: '#ffffff', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 0.0, width: 2.0, height: 0.02, color: '#ffffff', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 1.0, width: 2.0, height: 0.02, color: '#ffffff', velocityX: 0, velocityY: 0, pattern: 'static' }
                ],
                playerStart: { x: 0.05, y: 0.05 },
                exit: { x: 1.95, y: 0.95, width: 0.075, height: 0.1 },
                mapSize: { width: 2, height: 1 }
            },

            // Level 32
            {
                id: 32,
                name: "Patience's Reward",
                description: "Timing is everything - 'Patience is not the ability to wait, but the ability to keep a good attitude while waiting.'",
                backgroundColor: '#0f1a2a',
                echoes: [
                    // Echoes placed in timing-critical locations
                    { x: 0.2, y: 0.2, collected: false },
                    { x: 0.5, y: 0.2, collected: false },
                    { x: 0.8, y: 0.2, collected: false },
                    { x: 0.2, y: 0.5, collected: false },
                    { x: 0.8, y: 0.5, collected: false },
                    { x: 0.2, y: 0.8, collected: false },
                    { x: 0.5, y: 0.8, collected: false },
                    { x: 0.8, y: 0.8, collected: false },
                    { x: 1.2, y: 0.2, collected: false },
                    { x: 1.5, y: 0.2, collected: false },
                    { x: 1.8, y: 0.2, collected: false },
                    { x: 1.2, y: 0.5, collected: false },
                    { x: 1.8, y: 0.5, collected: false },
                    { x: 1.2, y: 0.8, collected: false },
                    { x: 1.5, y: 0.8, collected: false },
                    { x: 1.8, y: 0.8, collected: false }
                ],
                obstacles: [
                    // Synchronized barrier system - requires precise timing to navigate
                    // Horizontal barriers that move up and down in sequence
                    { x: 0.5, y: 0.25, width: 0.8, height: 0.03, color: '#ff3366', velocityX: 0, velocityY: 0.05, pattern: 'oscillate', 
                    axis: 'y', amplitude: 0.15, period: 4000, phase: 0
                    },
                    { x: 0.5, y: 0.5, width: 0.8, height: 0.03, color: '#ff3366', velocityX: 0, velocityY: 0.05, pattern: 'oscillate', 
                    axis: 'y', amplitude: 0.15, period: 4000, phase: Math.PI/2
                    },
                    { x: 0.5, y: 0.75, width: 0.8, height: 0.03, color: '#ff3366', velocityX: 0, velocityY: 0.05, pattern: 'oscillate', 
                    axis: 'y', amplitude: 0.15, period: 4000, phase: Math.PI
                    },
                    
                    // Right side barriers - offset timing
                    { x: 1.5, y: 0.25, width: 0.8, height: 0.03, color: '#ff3366', velocityX: 0, velocityY: 0.05, pattern: 'oscillate', 
                    axis: 'y', amplitude: 0.15, period: 4000, phase: Math.PI/4
                    },
                    { x: 1.5, y: 0.5, width: 0.8, height: 0.03, color: '#ff3366', velocityX: 0, velocityY: 0.05, pattern: 'oscillate', 
                    axis: 'y', amplitude: 0.15, period: 4000, phase: 3*Math.PI/4
                    },
                    { x: 1.5, y: 0.75, width: 0.8, height: 0.03, color: '#ff3366', velocityX: 0, velocityY: 0.05, pattern: 'oscillate', 
                    axis: 'y', amplitude: 0.15, period: 4000, phase: 5*Math.PI/4
                    },
                    
                    // Vertical barriers that move left and right in sequence
                    { x: 0.25, y: 0.5, width: 0.03, height: 0.8, color: '#4287f5', velocityX: 0.05, velocityY: 0, pattern: 'oscillate', 
                    axis: 'x', amplitude: 0.15, period: 4000, phase: 0
                    },
                    { x: 0.5, y: 0.5, width: 0.03, height: 0.8, color: '#4287f5', velocityX: 0.05, velocityY: 0, pattern: 'oscillate', 
                    axis: 'x', amplitude: 0.15, period: 4000, phase: Math.PI/2
                    },
                    { x: 0.75, y: 0.5, width: 0.03, height: 0.8, color: '#4287f5', velocityX: 0.05, velocityY: 0, pattern: 'oscillate', 
                    axis: 'x', amplitude: 0.15, period: 4000, phase: Math.PI
                    },
                    
                    // Right side vertical barriers
                    { x: 1.25, y: 0.5, width: 0.03, height: 0.8, color: '#4287f5', velocityX: 0.05, velocityY: 0, pattern: 'oscillate', 
                    axis: 'x', amplitude: 0.15, period: 4000, phase: Math.PI/4
                    },
                    { x: 1.5, y: 0.5, width: 0.03, height: 0.8, color: '#4287f5', velocityX: 0.05, velocityY: 0, pattern: 'oscillate', 
                    axis: 'x', amplitude: 0.15, period: 4000, phase: 3*Math.PI/4
                    },
                    { x: 1.75, y: 0.5, width: 0.03, height: 0.8, color: '#4287f5', velocityX: 0.05, velocityY: 0, pattern: 'oscillate', 
                    axis: 'x', amplitude: 0.15, period: 4000, phase: 5*Math.PI/4
                    },
                    
                    // Center barrier with timed gate
                    { x: 1.0, y: 0.5, width: 0.03, height: 0.8, color: '#ffffff', velocityX: 0, velocityY: 0, pattern: 'static' },
                    
                    // Timed gate in the center - opens briefly on a cycle
                    { x: 1.0, y: 0.2, width: 0.03, height: 0.2, color: 'rgba(255, 255, 255, 0.5)', velocityX: 0, velocityY: 0, pattern: 'timedGate', 
                    openInterval: 2000, closedInterval: 3000, initialState: 'closed'
                    },
                    
                    // Boundary walls
                    { x: 0.0, y: 0.5, width: 0.02, height: 1.0, color: '#ffffff', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 2.0, y: 0.5, width: 0.02, height: 1.0, color: '#ffffff', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 0.0, width: 2.0, height: 0.02, color: '#ffffff', velocityX: 0, velocityY: 0, pattern: 'static' },
                    { x: 1.0, y: 1.0, width: 2.0, height: 0.02, color: '#ffffff', velocityX: 0, velocityY: 0, pattern: 'static' }
                ],
                playerStart: { x: 0.05, y: 0.05 },
                exit: { x: 1.95, y: 0.95, width: 0.075, height: 0.1 },
                mapSize: { width: 2, height: 1 }
            },

            
            
            



         


            
        ];
        
        // Quiz data
        const quizzes = [
            // Stoicism Quiz (Level 10)
            {
                title: "Stoicism Quiz",
                questions: [
                    {
                        question: "According to Stoicism, what is the only thing we truly have control over?",
                        options: [
                            "External events and circumstances",
                            "Our own thoughts, judgments, and actions",
                            "Other people's opinions of us",
                            "The outcome of our efforts"
                        ],
                        correctAnswer: 1,
                        explanation: "Stoicism teaches that we only have control over our own thoughts, judgments, and actions. Everything else is outside our control and should be accepted with equanimity."
                    },
                    {
                        question: "Which of these is a core principle of Stoic philosophy?",
                        options: [
                            "Pursuing pleasure as the highest good",
                            "Avoiding all forms of emotional attachment",
                            "Distinguishing between what we can and cannot control",
                            "Rejecting all material possessions"
                        ],
                        correctAnswer: 2,
                        explanation: "A fundamental principle of Stoicism is the dichotomy of control - clearly distinguishing between what is in our power and what is not, then focusing our energy only on what we can control."
                    },
                    {
                        question: "According to Marcus Aurelius, how should we view obstacles in our path?",
                        options: [
                            "As unfair punishments to be endured",
                            "As opportunities for growth and practice of virtue",
                            "As signs that we should change direction",
                            "As evidence that the gods are against us"
                        ],
                        correctAnswer: 1,
                        explanation: "Marcus Aurelius taught that obstacles are actually opportunities - 'The impediment to action advances action. What stands in the way becomes the way.'"
                    }
                ]
            },
            // Self-Improvement Quiz (Level 20)
            {
                title: "Self-Improvement Quiz",
                questions: [
                    {
                        question: "What is the 'growth mindset' as described by psychologist Carol Dweck?",
                        options: [
                            "The belief that intelligence and abilities are fixed traits",
                            "The belief that intelligence and abilities can be developed through dedication and hard work",
                            "The idea that growth only happens during childhood and adolescence",
                            "The concept that personal growth requires external validation"
                        ],
                        correctAnswer: 1,
                        explanation: "A growth mindset is the belief that abilities can be developed through dedication and hard work. This view creates a love of learning and resilience essential for great accomplishment."
                    },
                    {
                        question: "What is the concept of 'deliberate practice' in skill development?",
                        options: [
                            "Practicing whenever you feel inspired",
                            "Focused, structured practice designed to improve performance with immediate feedback",
                            "Practicing for long hours without breaks",
                            "Practicing multiple skills simultaneously"
                        ],
                        correctAnswer: 1,
                        explanation: "Deliberate practice is purposeful, systematic, and focused on improvement. It involves getting immediate feedback, working on specific aspects of performance, and pushing beyond comfort zones."
                    },
                    {
                        question: "According to research on habit formation, what is the most effective way to build new habits?",
                        options: [
                            "Relying solely on willpower and motivation",
                            "Setting ambitious goals to push yourself",
                            "Linking new habits to existing routines and making them obvious and easy",
                            "Focusing on multiple habit changes simultaneously"
                        ],
                        correctAnswer: 2,
                        explanation: "Research shows that the most effective way to build habits is to make them obvious, attractive, easy, and satisfying. Linking new habits to existing routines (habit stacking) and starting with tiny changes increases success rates."
                    }
                ]
            }
        ];
        
        // Current level data
        let currentLevel = null;
        let echoes = [];
        let obstacles = [];
        let exit = null;
        let currentQuiz = null;
        let selectedQuizAnswer = null;
        
        // Input handling
        const keys = {
            up: false,
            down: false,
            left: false,
            right: false,
            space: false
        };
        
        // Touch controls state
        let touchControls = {
            up: false,
            down: false,
            left: false,
            right: false,
            time: false
        };
        
        // Canvas and context
        const backgroundCanvas = document.getElementById('background-canvas');
        const mainCanvas = document.getElementById('main-canvas');
        const uiCanvas = document.getElementById('ui-canvas');
        const minimapCanvas = document.getElementById('minimap-canvas');
        
        const bgCtx = backgroundCanvas.getContext('2d');
        const ctx = mainCanvas.getContext('2d');
        const uiCtx = uiCanvas.getContext('2d');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        // UI elements
        const menu = document.getElementById('menu');
        const levelSelect = document.getElementById('level-select');
        const levelComplete = document.getElementById('level-complete');
        const pauseScreen = document.getElementById('pause-screen');
        const aboutScreen = document.getElementById('about-screen');
        const settingsScreen = document.getElementById('settings-screen');
        const quizScreen = document.getElementById('quiz-screen');
        const echoCount = document.getElementById('echo-count');
        const timeFractureFill = document.getElementById('time-fracture-fill');
        const hamburgerMenu = document.getElementById('hamburger-menu');
        const menuDropdown = document.getElementById('menu-dropdown');
        const controlsContainer = document.getElementById('controls-container');
        const mobileControls = document.getElementById('mobile-controls');
        const swipeOverlay = document.getElementById('swipe-overlay');
        const minimap = document.getElementById('minimap');
        const levelIndicator = document.getElementById('level-indicator');
        
        // Mobile control buttons
        const upBtn = document.getElementById('up-btn');
        const downBtn = document.getElementById('down-btn');
        const leftBtn = document.getElementById('left-btn');
        const rightBtn = document.getElementById('right-btn');
        const timeBtn = document.getElementById('time-btn');
        const pauseBtn = document.getElementById('pause-btn');
        
        // Settings controls
        const controlTypeOptions = document.querySelectorAll('.radio-option');
        const showControlsToggle = document.getElementById('show-controls-toggle');
        const showMinimapToggle = document.getElementById('show-minimap-toggle');
        const visualEffectsToggle = document.getElementById('visual-effects-toggle');
        
        // Zoom controls
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        
        // Particles system
        let particles = [];
        
        // Game loop variables
        let lastTime = 0;
        let animationFrameId;
        
        // Visibility change detection
        let documentHidden = false;
        
        // Initialize the game
        function init() {
            // Set canvas dimensions
            resizeGame();
            
            // Generate level select buttons
            generateLevelButtons();
            
            // Apply settings
            applySettings();
            
            // Event listeners for menu buttons
            document.getElementById('start-btn').addEventListener('click', () => {
                startGame(1);
            });
            
            document.getElementById('level-select-btn').addEventListener('click', () => {
                menu.classList.add('menu-hidden');
                levelSelect.classList.remove('menu-hidden');
                updateLevelSelectUI();
            });
            
            document.getElementById('settings-btn').addEventListener('click', () => {
                menu.classList.add('menu-hidden');
                settingsScreen.classList.remove('menu-hidden');
            });
            
            document.getElementById('about-btn').addEventListener('click', () => {
                menu.classList.add('menu-hidden');
                aboutScreen.classList.remove('menu-hidden');
            });
            
            document.getElementById('about-back-btn').addEventListener('click', () => {
                aboutScreen.classList.add('menu-hidden');
                menu.classList.remove('menu-hidden');
            });
            
            document.getElementById('settings-back-btn').addEventListener('click', () => {
                saveSettings();
                settingsScreen.classList.add('menu-hidden');
                
                // Return to the appropriate screen
                if (gameState.isPaused) {
                    pauseScreen.classList.remove('menu-hidden');
                } else {
                    menu.classList.remove('menu-hidden');
                }
            });
            
            document.getElementById('back-to-menu').addEventListener('click', () => {
                levelSelect.classList.add('menu-hidden');
                menu.classList.remove('menu-hidden');
            });
            
            document.getElementById('next-level-btn').addEventListener('click', () => {
                const nextLevelId = currentLevel.id + 1;
                if (nextLevelId <= levels.length) {
                    startGame(nextLevelId);
                } else {
                    // Game completed
                    levelComplete.classList.add('menu-hidden');
                    menu.classList.remove('menu-hidden');
                }
            });
            
            document.getElementById('retry-level-btn').addEventListener('click', () => {
                startGame(currentLevel.id);
            });
            
            document.getElementById('level-menu-btn').addEventListener('click', () => {
                levelComplete.classList.add('menu-hidden');
                levelSelect.classList.remove('menu-hidden');
                updateLevelSelectUI();
            });
            
            document.getElementById('resume-btn').addEventListener('click', () => {
                resumeGame();
            });
            
            document.getElementById('restart-btn').addEventListener('click', () => {
                startGame(currentLevel.id);
            });
            
            document.getElementById('pause-settings-btn').addEventListener('click', () => {
                pauseScreen.classList.add('menu-hidden');
                settingsScreen.classList.remove('menu-hidden');
            });
            
            document.getElementById('pause-menu-btn').addEventListener('click', () => {
                pauseScreen.classList.add('menu-hidden');
                menu.classList.remove('menu-hidden');
                gameState.isPlaying = false;
                cancelAnimationFrame(animationFrameId);
            });
            
            // Quiz buttons
            document.getElementById('quiz-submit-btn').addEventListener('click', () => {
                if (selectedQuizAnswer !== null) {
                    checkQuizAnswer();
                }
            });
            
            document.getElementById('quiz-continue-btn').addEventListener('click', () => {
                completeQuizLevel();
            });
            
            // Hamburger menu
            hamburgerMenu.addEventListener('click', () => {
                menuDropdown.classList.toggle('active');
            });
            
            document.getElementById('menu-home').addEventListener('click', () => {
                window.location.href = 'index.html';
            });
            
            document.getElementById('menu-restart').addEventListener('click', () => {
                if (gameState.isPlaying) {
                    startGame(currentLevel.id);
                }
                menuDropdown.classList.remove('active');
            });
            
            document.getElementById('menu-levels').addEventListener('click', () => {
                pauseGame();
                pauseScreen.classList.add('menu-hidden');
                levelSelect.classList.remove('menu-hidden');
                updateLevelSelectUI();
                menuDropdown.classList.remove('active');
            });
            
            document.getElementById('menu-settings').addEventListener('click', () => {
                if (gameState.isPlaying) {
                    pauseGame();
                }
                pauseScreen.classList.add('menu-hidden');
                settingsScreen.classList.remove('menu-hidden');
                menuDropdown.classList.remove('active');
            });
            
            document.getElementById('menu-about').addEventListener('click', () => {
                if (gameState.isPlaying) {
                    pauseGame();
                }
                pauseScreen.classList.add('menu-hidden');
                aboutScreen.classList.remove('menu-hidden');
                menuDropdown.classList.remove('active');
            });
            
            // Settings controls
            controlTypeOptions.forEach(option => {
                option.addEventListener('click', () => {
                    controlTypeOptions.forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                });
            });
            
            // Zoom controls
            zoomInBtn.addEventListener('click', () => {
                camera.targetZoom = Math.min(camera.maxZoom, camera.targetZoom + 0.2);
            });
            
            zoomOutBtn.addEventListener('click', () => {
                camera.targetZoom = Math.max(camera.minZoom, camera.targetZoom - 0.2);
            });
            
            // Keyboard event listeners
            window.addEventListener('keydown', (e) => {
                updateKeys(e, true);
            });
            
            window.addEventListener('keyup', (e) => {
                updateKeys(e, false);
            });
            
            // Mobile control events
            setupMobileControls();
            
            // Window resize event
            window.addEventListener('resize', resizeGame);
            
            // Visibility change event
            document.addEventListener('visibilitychange', handleVisibilityChange);
            
            // Draw the background for the menu
            drawMenuBackground();
        }
        
        function generateLevelButtons() {
            const levelGrid = document.querySelector('.level-grid');
            levelGrid.innerHTML = '';
            
            for (let i = 0; i < levels.length; i++) {
                const levelBtn = document.createElement('div');
                levelBtn.className = 'level-btn';
                if (levels[i].isQuiz) {
                    levelBtn.classList.add('level-quiz');
                }
                levelBtn.setAttribute('data-level', levels[i].id);
                levelBtn.textContent = levels[i].id;
                
                levelGrid.appendChild(levelBtn);
            }
            
            // Add event listeners to level buttons
            const levelButtons = document.querySelectorAll('.level-btn');
            levelButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const levelId = parseInt(button.getAttribute('data-level'));
                    if (levelId <= gameState.maxUnlockedLevel) {
                        startGame(levelId);
                    }
                });
            });
        }
        
        function applySettings() {
            // Apply control type
            if (settings.controlType === 'swipe') {
                mobileControls.classList.remove('active');
                swipeOverlay.classList.add('active');
                document.querySelector('.radio-option[data-value="swipe"]').classList.add('selected');
                document.querySelector('.radio-option[data-value="buttons"]').classList.remove('selected');
            } else {
                mobileControls.classList.add('active');
                swipeOverlay.classList.remove('active');
                document.querySelector('.radio-option[data-value="buttons"]').classList.add('selected');
                document.querySelector('.radio-option[data-value="swipe"]').classList.remove('selected');
            }
            
            // Apply show controls setting
            showControlsToggle.checked = settings.showControls;
            controlsContainer.style.opacity = settings.showControls ? '1' : '0';
            
            // Apply minimap setting
            showMinimapToggle.checked = settings.showMinimap;
            minimap.style.display = settings.showMinimap ? 'block' : 'none';
            
            // Apply visual effects setting
            visualEffectsToggle.checked = settings.visualEffects;
        }
        
        function saveSettings() {
            // Save control type
            settings.controlType = document.querySelector('.radio-option.selected').getAttribute('data-value');
            
            // Save other settings
            settings.showControls = showControlsToggle.checked;
            settings.showMinimap = showMinimapToggle.checked;
            settings.visualEffects = visualEffectsToggle.checked;
            
            // Apply settings
            applySettings();
            
            // Save to localStorage
            try {
                localStorage.setItem('echoesGameSettings', JSON.stringify(settings));
            } catch (e) {
                console.error("Could not save settings:", e);
            }
        }

        



















        
        function resizeGame() {
            const container = document.getElementById('game-container');
            CANVAS_WIDTH = container.clientWidth;
            CANVAS_HEIGHT = container.clientHeight;
            
            backgroundCanvas.width = CANVAS_WIDTH;
            backgroundCanvas.height = CANVAS_HEIGHT;
            mainCanvas.width = CANVAS_WIDTH;
            mainCanvas.height = CANVAS_HEIGHT;
            uiCanvas.width = CANVAS_WIDTH;
            uiCanvas.height = CANVAS_HEIGHT;
            minimapCanvas.width = 150;
            minimapCanvas.height = 150;
            
            // Redraw background if we're on the menu
            if (!gameState.isPlaying) {
                drawMenuBackground();
            } else if (currentLevel) {
                drawLevelBackground();
            }
        }
        
        function handleVisibilityChange() {
            documentHidden = document.hidden;
            
            if (documentHidden && gameState.isPlaying && !gameState.isPaused) {
                pauseGame();
            }
        }
        
        function setupMobileControls() {
            // Touch events for directional buttons
            upBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchControls.up = true;
            });
            upBtn.addEventListener('touchend', () => {
                touchControls.up = false;
            });
            
            downBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchControls.down = true;
            });
            downBtn.addEventListener('touchend', () => {
                touchControls.down = false;
            });
            
            leftBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchControls.left = true;
            });
            leftBtn.addEventListener('touchend', () => {
                touchControls.left = false;
            });
            
            rightBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchControls.right = true;
            });
            rightBtn.addEventListener('touchend', () => {
                touchControls.right = false;
            });
            
            // Time fracture button
            timeBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState.isPlaying && !gameState.isPaused) {
                    activateTimeFracture();
                }
            });
            
            // Pause button
            pauseBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState.isPlaying) {
                    togglePause();
                }
            });
            
            // Swipe controls
            swipeOverlay.addEventListener('touchstart', (e) => {
                if (settings.controlType === 'swipe' && gameState.isPlaying && !gameState.isPaused) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    swipe.startX = touch.clientX;
                    swipe.startY = touch.clientY;
                    swipe.isActive = true;
                }
            });
            
            swipeOverlay.addEventListener('touchmove', (e) => {
                if (settings.controlType === 'swipe' && swipe.isActive) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    swipe.endX = touch.clientX;
                    swipe.endY = touch.clientY;
                    
                    const dx = swipe.endX - swipe.startX;
                    const dy = swipe.endY - swipe.startY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > swipe.threshold) {
                        // Determine direction
                        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                        
                        // Reset all directions
                        touchControls.up = false;
                        touchControls.down = false;
                        touchControls.left = false;
                        touchControls.right = false;
                        
                        // Set direction based on angle
                        if (angle > -45 && angle < 45) {
                            touchControls.right = true;
                            swipe.direction = 'right';
                        } else if (angle >= 45 && angle < 135) {
                            touchControls.down = true;
                            swipe.direction = 'down';
                        } else if (angle >= 135 || angle < -135) {
                            touchControls.left = true;
                            swipe.direction = 'left';
                        } else {
                            touchControls.up = true;
                            swipe.direction = 'up';
                        }
                    }
                }
            });
            
            swipeOverlay.addEventListener('touchend', () => {
                if (settings.controlType === 'swipe') {
                    swipe.isActive = false;
                    swipe.direction = null;
                    
                    // Reset all directions
                    touchControls.up = false;
                    touchControls.down = false;
                    touchControls.left = false;
                    touchControls.right = false;
                }
            });
            
            // Double tap for time fracture
            let lastTap = 0;
            swipeOverlay.addEventListener('touchend', (e) => {
                if (settings.controlType === 'swipe' && gameState.isPlaying && !gameState.isPaused) {
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    if (tapLength < 300 && tapLength > 0) {
                        // Double tap detected
                        activateTimeFracture();
                        e.preventDefault();
                    }
                    lastTap = currentTime;
                }
            });
        }
        
        function updateKeys(e, isPressed) {
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    keys.up = isPressed;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    keys.down = isPressed;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keys.left = isPressed;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keys.right = isPressed;
                    break;
                case ' ':
                    keys.space = isPressed;
                    if (isPressed && gameState.isPlaying && !gameState.isPaused) {
                        activateTimeFracture();
                    }
                    break;
                case 'Escape':
                    if (isPressed && gameState.isPlaying) {
                        togglePause();
                    }
                    break;
            }
        }
        
        function togglePause() {
            if (gameState.isPaused) {
                resumeGame();
            } else {
                pauseGame();
            }
        }
        
        function pauseGame() {
            gameState.isPaused = true;
            pauseScreen.classList.remove('menu-hidden');
        }
        
        function resumeGame() {
            gameState.isPaused = false;
            pauseScreen.classList.add('menu-hidden');
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }
        
        function drawMenuBackground() {
            bgCtx.fillStyle = '#0a0a1a';
            bgCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw stars
            const starCount = Math.floor((CANVAS_WIDTH * CANVAS_HEIGHT) / 5000);
            for (let i = 0; i < starCount; i++) {
                const x = Math.random() * CANVAS_WIDTH;
                const y = Math.random() * CANVAS_HEIGHT;
                const size = Math.random() * 2 + 1;
                const opacity = Math.random() * 0.8 + 0.2;
                
                bgCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                bgCtx.beginPath();
                bgCtx.arc(x, y, size, 0, Math.PI * 2);
                bgCtx.fill();
            }
            
            // Draw nebula-like shapes
            const nebulaCount = Math.floor((CANVAS_WIDTH * CANVAS_HEIGHT) / 80000) + 2;
            for (let i = 0; i < nebulaCount; i++) {
                const x = Math.random() * CANVAS_WIDTH;
                const y = Math.random() * CANVAS_HEIGHT;
                const radius = Math.random() * (CANVAS_WIDTH / 8) + (CANVAS_WIDTH / 16);
                
                const gradient = bgCtx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(100, 100, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(100, 100, 255, 0)');
                
                bgCtx.fillStyle = gradient;
                bgCtx.beginPath();
                bgCtx.arc(x, y, radius, 0, Math.PI * 2);
                bgCtx.fill();
            }
        }
        
        function updateLevelSelectUI() {
            const levelButtons = document.querySelectorAll('.level-btn');
            levelButtons.forEach(button => {
                const levelId = parseInt(button.getAttribute('data-level'));
                
                // Reset classes
                button.classList.remove('level-locked', 'level-completed');
                
                // Apply appropriate classes
                if (levelId > gameState.maxUnlockedLevel) {
                    button.classList.add('level-locked');
                } else if (gameState.completedLevels.includes(levelId)) {
                    button.classList.add('level-completed');
                }
                
                // Keep quiz class if it's a quiz level
                if (levels[levelId - 1].isQuiz) {
                    button.classList.add('level-quiz');
                }
            });
        }
        
        function startGame(levelId) {
            // Hide all menus
            menu.classList.add('menu-hidden');
            levelSelect.classList.add('menu-hidden');
            levelComplete.classList.add('menu-hidden');
            pauseScreen.classList.add('menu-hidden');
            aboutScreen.classList.add('menu-hidden');
            settingsScreen.classList.add('menu-hidden');
            quizScreen.classList.add('menu-hidden');
            menuDropdown.classList.remove('active');
            
            // Load level data
            currentLevel = levels.find(level => level.id === levelId);
            
            // Update level indicator
            levelIndicator.textContent = `Level ${currentLevel.id}`;
            
            // Check if it's a quiz level
            if (currentLevel.isQuiz) {
                startQuizLevel();
                return;
            }
            
            // Reset camera
            camera.x = 0;
            camera.y = 0;
            camera.zoom = 1;
            camera.targetZoom = 1;
            
            // Reset level data
            echoes = JSON.parse(JSON.stringify(currentLevel.echoes));
            obstacles = JSON.parse(JSON.stringify(currentLevel.obstacles));
            exit = { ...currentLevel.exit, unlocked: false };
            
            // Convert relative positions to absolute positions
            convertToAbsolutePositions();
            
            // Reset player position
            player.x = currentLevel.playerStart.x * CANVAS_WIDTH;
            player.y = currentLevel.playerStart.y * CANVAS_HEIGHT;
            player.velocityX = 0;
            player.velocityY = 0;
            
            // Reset time fracture
            gameState.timeFracture.active = false;
            gameState.timeFracture.cooldown = 0;
            gameState.timeFracture.lastUsed = 0;
            
            // Update HUD
            updateEchoCounter();
            
            // Show/hide minimap based on settings
            minimap.style.display = settings.showMinimap ? 'block' : 'none';
            
            // Show/hide zoom controls for larger maps
            const zoomControls = document.getElementById('zoom-controls');
            if (currentLevel.mapSize.width > 1 || currentLevel.mapSize.height > 1) {
                zoomControls.style.display = 'flex';
            } else {
                zoomControls.style.display = 'none';
            }
            
            // Draw background for the level
            drawLevelBackground();
            
            // Start the game loop
            gameState.isPlaying = true;
            gameState.isPaused = false;
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }
        
        function startQuizLevel() {
            // Get the appropriate quiz
            const quizIndex = Math.floor((currentLevel.id - 1) / QUIZ_INTERVAL);
            if (quizIndex < quizzes.length) {
                currentQuiz = quizzes[quizIndex];
                
                // Select a random question from the quiz
                const questionIndex = Math.floor(Math.random() * currentQuiz.questions.length);
                const question = currentQuiz.questions[questionIndex];
                
                // Update quiz UI
                document.querySelector('.quiz-title').textContent = currentQuiz.title;
                document.getElementById('quiz-question').textContent = question.question;
                
                // Generate options
                const optionsContainer = document.getElementById('quiz-options');
                optionsContainer.innerHTML = '';
                
                question.options.forEach((option, index) => {
                    const optionElement = document.createElement('div');
                    optionElement.className = 'quiz-option';
                    optionElement.textContent = option;
                    optionElement.setAttribute('data-index', index);
                    
                    optionElement.addEventListener('click', () => {
                        // Remove selected class from all options
                        document.querySelectorAll('.quiz-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        
                        // Add selected class to clicked option
                        optionElement.classList.add('selected');
                        selectedQuizAnswer = index;
                    });
                    
                    optionsContainer.appendChild(optionElement);
                });
                
                // Reset feedback
                document.getElementById('quiz-feedback').className = 'quiz-feedback';
                document.getElementById('quiz-submit-btn').style.display = 'block';
                document.getElementById('quiz-continue-btn').style.display = 'none';
                selectedQuizAnswer = null;
                
                // Show quiz screen
                quizScreen.classList.remove('menu-hidden');
            } else {
                // No quiz available, skip to next level
                completeQuizLevel();
            }
        }
        
        function checkQuizAnswer() {
            const quizIndex = Math.floor((currentLevel.id - 1) / QUIZ_INTERVAL);
            const questionIndex = Math.floor(Math.random() * currentQuiz.questions.length);
            const question = currentQuiz.questions[questionIndex];
            
            const feedback = document.getElementById('quiz-feedback');
            const feedbackText = document.getElementById('feedback-text');
            const explanation = document.getElementById('quiz-explanation');
            
            if (selectedQuizAnswer === question.correctAnswer) {
                // Correct answer
                feedback.className = 'quiz-feedback correct';
                feedbackText.textContent = 'Correct! Well done.';
            } else {
                // Incorrect answer
                feedback.className = 'quiz-feedback incorrect';
                feedbackText.textContent = 'Not quite right. The correct answer is: ' + question.options[question.correctAnswer];
                
                // Mark the correct and incorrect options
                document.querySelectorAll('.quiz-option').forEach(opt => {
                    const index = parseInt(opt.getAttribute('data-index'));
                    if (index === question.correctAnswer) {
                        opt.classList.add('correct');
                    } else if (index === selectedQuizAnswer) {
                        opt.classList.add('incorrect');
                    }
                });
            }
            
            // Show explanation
            explanation.textContent = question.explanation;
            
            // Hide submit button, show continue button
            document.getElementById('quiz-submit-btn').style.display = 'none';
            document.getElementById('quiz-continue-btn').style.display = 'block';
        }
        
        function completeQuizLevel() {
            // Mark level as completed
            if (!gameState.completedLevels.includes(currentLevel.id)) {
                gameState.completedLevels.push(currentLevel.id);
            }
            
            // Unlock next level
            if (currentLevel.id === gameState.maxUnlockedLevel && currentLevel.id < levels.length) {
                gameState.maxUnlockedLevel++;
            }
            
            // Save game state
            try {
                localStorage.setItem('echoesGameState', JSON.stringify({
                    maxUnlockedLevel: gameState.maxUnlockedLevel,
                    completedLevels: gameState.completedLevels
                }));
            } catch (e) {
                console.error("Could not save game state:", e);
            }
            
            // Go to next level
            const nextLevelId = currentLevel.id + 1;
            if (nextLevelId <= levels.length) {
                startGame(nextLevelId);
            } else {
                // Game completed
                quizScreen.classList.add('menu-hidden');
                menu.classList.remove('menu-hidden');
            }
        }
        
        function convertToAbsolutePositions() {
            // Calculate base dimensions
            const baseWidth = CANVAS_WIDTH;
            const baseHeight = CANVAS_HEIGHT;
            
            // Convert echo positions
            echoes.forEach(echo => {
                echo.x = echo.x * baseWidth;
                echo.y = echo.y * baseHeight;
            });
            
            // Convert obstacle positions and dimensions
            obstacles.forEach(obstacle => {
                obstacle.x = obstacle.x * baseWidth;
                obstacle.y = obstacle.y * baseHeight;
                obstacle.width = obstacle.width * baseWidth;
                obstacle.height = obstacle.height * baseHeight;
                
                // Scale velocities based on canvas size
                if (obstacle.velocityX) {
                    obstacle.velocityX = obstacle.velocityX * (baseWidth / 800);
                }
                if (obstacle.velocityY) {
                    obstacle.velocityY = obstacle.velocityY * (baseHeight / 600);
                }
                
                // Convert teleport target coordinates if present
                if (obstacle.pattern === 'teleport' || obstacle.pattern === 'portal') {
                    if (obstacle.targetX !== undefined) {
                        obstacle.targetX = obstacle.targetX * baseWidth;
                    }
                    if (obstacle.targetY !== undefined) {
                        obstacle.targetY = obstacle.targetY * baseHeight;
                    }
                }
            });
            
            // Convert exit position and dimensions
            exit.x = exit.x * baseWidth;
            exit.y = exit.y * baseHeight;
            exit.width = exit.width * baseWidth;
            exit.height = exit.height * baseHeight;
        }
        
        function drawLevelBackground() {
            bgCtx.fillStyle = currentLevel.backgroundColor;
            bgCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Apply camera transformation
            bgCtx.save();
            bgCtx.translate(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            bgCtx.scale(camera.zoom, camera.zoom);
            bgCtx.translate(-CANVAS_WIDTH / 2 - camera.x, -CANVAS_HEIGHT / 2 - camera.y);
            
            // Draw grid lines
            bgCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            bgCtx.lineWidth = 1;
            
            const gridSize = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 12;
            const mapWidth = CANVAS_WIDTH * currentLevel.mapSize.width;
            const mapHeight = CANVAS_HEIGHT * currentLevel.mapSize.height;
            
            // Vertical lines
            for (let x = 0; x <= mapWidth; x += gridSize) {
                bgCtx.beginPath();
                bgCtx.moveTo(x, 0);
                bgCtx.lineTo(x, mapHeight);
                bgCtx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y <= mapHeight; y += gridSize) {
                bgCtx.beginPath();
                bgCtx.moveTo(0, y);
                bgCtx.lineTo(mapWidth, y);
                bgCtx.stroke();
            }
            
            // Restore context
            bgCtx.restore();
            
            // Draw level name (not affected by camera)
            bgCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            bgCtx.font = `${Math.max(16, Math.min(24, CANVAS_WIDTH / 30))}px Arial`;
            bgCtx.textAlign = 'center';
            bgCtx.fillText(currentLevel.name, CANVAS_WIDTH / 2, CANVAS_HEIGHT * 0.067);
            
            // Draw level description
            bgCtx.font = `${Math.max(12, Math.min(16, CANVAS_WIDTH / 45))}px Arial`;
            bgCtx.fillText(currentLevel.description, CANVAS_WIDTH / 2, CANVAS_HEIGHT * 0.117);
            
            // Draw minimap
            updateMinimap();
        }
        
        function updateMinimap() {
            if (!settings.showMinimap) return;
            
            const ctx = minimapCanvas.getContext('2d');
            const mapWidth = 150;
            const mapHeight = 150;
            
            // Clear minimap
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, mapWidth, mapHeight);
            
            // Calculate scale factors
            const scaleX = mapWidth / (CANVAS_WIDTH * currentLevel.mapSize.width);
            const scaleY = mapHeight / (CANVAS_HEIGHT * currentLevel.mapSize.height);
            
            // Draw echoes
            echoes.forEach(echo => {
                if (!echo.collected) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(echo.x * scaleX, echo.y * scaleY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw obstacles
            obstacles.forEach(obstacle => {
                ctx.fillStyle = obstacle.color;
                ctx.fillRect(
                    obstacle.x * scaleX,
                    obstacle.y * scaleY,
                    obstacle.width * scaleX,
                    obstacle.height * scaleY
                );
            });
            
            // Draw exit
            ctx.fillStyle = exit.unlocked ? 'rgba(100, 255, 100, 0.8)' : 'rgba(150, 150, 150, 0.5)';
            ctx.fillRect(
                exit.x * scaleX,
                exit.y * scaleY,
                exit.width * scaleX,
                exit.height * scaleY
            );
            
            // Draw player
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(player.x * scaleX, player.y * scaleY, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw viewport rectangle
            const viewportX = (camera.x + CANVAS_WIDTH / 2 * (1 - 1/camera.zoom)) * scaleX;
            const viewportY = (camera.y + CANVAS_HEIGHT / 2 * (1 - 1/camera.zoom)) * scaleY;
            const viewportWidth = (CANVAS_WIDTH / camera.zoom) * scaleX;
            const viewportHeight = (CANVAS_HEIGHT / camera.zoom) * scaleY;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.strokeRect(viewportX, viewportY, viewportWidth, viewportHeight);
        }
        
        function updateEchoCounter() {
            const collected = echoes.filter(echo => echo.collected).length;
            const total = echoes.length;
            echoCount.textContent = `${collected}/${total}`;
        }
        
        function activateTimeFracture() {
            const currentTime = performance.now();
            
            // Check if time fracture is available
            if (currentTime - gameState.timeFracture.lastUsed < TIME_FRACTURE_COOLDOWN) {
                return;
            }
            
            gameState.timeFracture.active = true;
            gameState.timeFracture.lastUsed = currentTime;
            
            // Create time fracture effect
            if (settings.visualEffects) {
                createTimeFractureEffect();
            }
            
            // Deactivate time fracture after duration
            setTimeout(() => {
                gameState.timeFracture.active = false;
            }, TIME_FRACTURE_DURATION);
        }
        
        function createTimeFractureEffect() {
            // Create particles for time fracture effect
            for (let i = 0; i < 50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                const size = Math.random() * 3 + 1;
                const lifespan = Math.random() * 1000 + 1000;
                const color = `rgba(77, 195, 247, ${Math.random() * 0.5 + 0.5})`;
                
                particles.push({
                    x: player.x,
                    y: player.y,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    size: size,
                    color: color,
                    lifespan: lifespan,
                    createdAt: performance.now()
                });
            }
        }
        
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            if (!gameState.isPaused && !documentHidden) {
                update(deltaTime);
                render();
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }
        
        function update(deltaTime) {
            // Update camera zoom
            camera.zoom += (camera.targetZoom - camera.zoom) * camera.zoomSpeed;
            
            // Update time fracture cooldown
            updateTimeFractureMeter();
            
            // Update player movement
            updatePlayerMovement();
            
            // Update camera position to follow player
            updateCamera();
            
            // Update obstacles
            updateObstacles(deltaTime);
            
            // Check collisions
            checkCollisions();
            
            // Update particles
            if (settings.visualEffects) {
                updateParticles(deltaTime);
            }
            
            // Level-specific mechanics
            updateLevelMechanics(deltaTime);
            
            // Update minimap
            if (settings.showMinimap) {
                updateMinimap();
            }
        }
        
        function updateCamera() {
            // Calculate target camera position (centered on player)
            const targetX = player.x - CANVAS_WIDTH / 2;
            const targetY = player.y - CANVAS_HEIGHT / 2;
            
            // Smooth camera movement
            camera.x += (targetX - camera.x) * 0.1;
            camera.y += (targetY - camera.y) * 0.1;
            
            // Limit camera to map boundaries
            const mapWidth = CANVAS_WIDTH * currentLevel.mapSize.width;
            const mapHeight = CANVAS_HEIGHT * currentLevel.mapSize.height;
            
            const viewWidth = CANVAS_WIDTH / camera.zoom;
            const viewHeight = CANVAS_HEIGHT / camera.zoom;
            
            // Adjust boundaries based on zoom level
            const minX = 0;
            const maxX = mapWidth - viewWidth;
            const minY = 0;
            const maxY = mapHeight - viewHeight;
            
            // Apply boundaries if map is larger than view
            if (mapWidth > viewWidth) {
                camera.x = Math.max(minX, Math.min(maxX, camera.x));
            } else {
                camera.x = (mapWidth - viewWidth) / 2; // Center horizontally
            }
            
            if (mapHeight > viewHeight) {
                camera.y = Math.max(minY, Math.min(maxY, camera.y));
            } else {
                camera.y = (mapHeight - viewHeight) / 2; // Center vertically
            }
        }
        
        function updateLevelMechanics(deltaTime) {
            // Level 2: "Memento Mori" - World fades unless you keep moving
            if (currentLevel && currentLevel.id === 2) {
                // If player is not moving, gradually fade the world
                // (Implemented in render function)
            }
        }
        
        function updateTimeFractureMeter() {
            const currentTime = performance.now();
            const timeSinceLastUse = currentTime - gameState.timeFracture.lastUsed;
            const cooldownProgress = Math.min(timeSinceLastUse / TIME_FRACTURE_COOLDOWN, 1);
            
            timeFractureFill.style.width = `${cooldownProgress * 100}%`;
        }
        
        function updatePlayerMovement() {
            // Reset velocity
            player.velocityX = 0;
            player.velocityY = 0;
            
            // Apply keyboard input
            if (keys.up) player.velocityY = -player.speed;
            if (keys.down) player.velocityY = player.speed;
            if (keys.left) player.velocityX = -player.speed;
            if (keys.right) player.velocityX = player.speed;
            
            // Apply touch input
            if (touchControls.up) player.velocityY = -player.speed;
            if (touchControls.down) player.velocityY = player.speed;
            if (touchControls.left) player.velocityX = -player.speed;
            if (touchControls.right) player.velocityX = player.speed;
            
            // Apply special level mechanics
            if (currentLevel.id === 5 && !gameState.timeFracture.active) {
                // Level 5: "Accept Fate" - Reverse controls
                player.velocityX *= -1;
                player.velocityY *= -1;
            }
            
            // Update position
            player.x += player.velocityX;
            player.y += player.velocityY;
            
            // Keep player within map boundaries
            const mapWidth = CANVAS_WIDTH * currentLevel.mapSize.width;
            const mapHeight = CANVAS_HEIGHT * currentLevel.mapSize.height;
            
            player.x = Math.max(player.size, Math.min(mapWidth - player.size, player.x));
            player.y = Math.max(player.size, Math.min(mapHeight - player.size, player.y));
            
            // Create movement particles
            if (settings.visualEffects && (player.velocityX !== 0 || player.velocityY !== 0)) {
                createMovementParticles();
            }
        }
        
        function createMovementParticles() {
            // Only create particles occasionally
            if (Math.random() > 0.3) return;
            
            const angle = Math.atan2(-player.velocityY, -player.velocityX);
            const distance = player.size * 0.8;
            const x = player.x + Math.cos(angle) * distance;
            const y = player.y + Math.sin(angle) * distance;
            
            particles.push({
                x: x,
                y: y,
                velocityX: Math.cos(angle) * 0.5,
                velocityY: Math.sin(angle) * 0.5,
                size: Math.random() * 2 + 1,
                color: 'rgba(255, 255, 255, 0.7)',
                lifespan: 500,
                createdAt: performance.now()
            });
        }
        
        function updateObstacles(deltaTime) {
            obstacles.forEach(obstacle => {
                // Skip static obstacles
                if (obstacle.pattern === 'static') return;
                
                // Handle mirror pattern (follows player with delay)
                if (obstacle.pattern === 'mirror') {
                    const mapWidth = CANVAS_WIDTH * currentLevel.mapSize.width;
                    const mapHeight = CANVAS_HEIGHT * currentLevel.mapSize.height;
                    
                    const targetX = mapWidth - player.x;
                    const targetY = mapHeight - player.y;
                    const speed = 0.05;
                    
                    obstacle.x += (targetX - obstacle.x - obstacle.width/2) * speed;
                    obstacle.y += (targetY - obstacle.y - obstacle.height/2) * speed;
                    return;
                }
                
                // Handle quantum pattern (paired obstacles move in sync)
                if (obstacle.pattern === 'quantum') {
                    // Find the paired obstacle
                    const pairedObstacle = obstacles.find(o => 
                        o.pattern === 'quantum' && 
                        o.pair === obstacle.pair && 
                        o !== obstacle
                    );
                    
                    if (pairedObstacle) {
                        // Move normally
                        obstacle.x += obstacle.velocityX * OBSTACLE_SPEED;
                        obstacle.y += obstacle.velocityY * OBSTACLE_SPEED;
                        
                        // Change direction if hitting boundaries
                        const mapWidth = CANVAS_WIDTH * currentLevel.mapSize.width;
                        const mapHeight = CANVAS_HEIGHT * currentLevel.mapSize.height;
                        
                        if (obstacle.x <= 0 || obstacle.x + obstacle.width >= mapWidth) {
                            obstacle.velocityX *= -1;
                            pairedObstacle.velocityX *= -1;
                        }
                        if (obstacle.y <= 0 || obstacle.y + obstacle.height >= mapHeight) {
                            obstacle.velocityY *= -1;
                            pairedObstacle.velocityY *= -1;
                        }
                    }
                    return;
                }
                
                // Handle duality pattern (paired obstacles move in opposite directions)
                if (obstacle.pattern === 'duality') {
                    // Find the paired obstacle
                    const pairedObstacle = obstacles.find(o => 
                        o.pattern === 'duality' && 
                        o.pair === obstacle.pair && 
                        o !== obstacle
                    );
                    
                    if (pairedObstacle) {
                        // Move normally
                        obstacle.x += obstacle.velocityX * OBSTACLE_SPEED;
                        obstacle.y += obstacle.velocityY * OBSTACLE_SPEED;
                        
                        // Change direction if hitting boundaries
                        const mapWidth = CANVAS_WIDTH * currentLevel.mapSize.width;
                        const mapHeight = CANVAS_HEIGHT * currentLevel.mapSize.height;
                        
                        if (obstacle.x <= 0 || obstacle.x + obstacle.width >= mapWidth) {
                            obstacle.velocityX *= -1;
                            pairedObstacle.velocityX *= -1;
                        }
                        if (obstacle.y <= 0 || obstacle.y + obstacle.height >= mapHeight) {
                            obstacle.velocityY *= -1;
                            pairedObstacle.velocityY *= -1;
                        }
                    }
                    return;
                }
                
                // Handle timeZone pattern (affects player speed when nearby)
                if (obstacle.pattern === 'timeZone') {
                    // Move normally
                    obstacle.x += obstacle.velocityX * OBSTACLE_SPEED;
                    obstacle.y += obstacle.velocityY * OBSTACLE_SPEED;
                    
                    // Change direction if hitting boundaries
                    const mapWidth = CANVAS_WIDTH * currentLevel.mapSize.width;
                    const mapHeight = CANVAS_HEIGHT * currentLevel.mapSize.height;
                    
                    if (obstacle.x <= 0 || obstacle.x + obstacle.width >= mapWidth) {
                        obstacle.velocityX *= -1;
                    }
                    if (obstacle.y <= 0 || obstacle.y + obstacle.height >= mapHeight) {
                        obstacle.velocityY *= -1;
                    }
                    
                    // Check if player is in time zone
                    const dx = player.x - (obstacle.x + obstacle.width/2);
                    const dy = player.y - (obstacle.y + obstacle.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < 100) {
                        // Apply time multiplier to player speed
                        player.speed = PLAYER_SPEED * obstacle.timeMultiplier;
                    } else {
                        // Reset player speed
                        player.speed = PLAYER_SPEED;
                    }
                    return;
                }
                
                // Handle bounce pattern
                if (obstacle.pattern === 'bounce') {
                    obstacle.x += obstacle.velocityX * OBSTACLE_SPEED;
                    obstacle.y += obstacle.velocityY * OBSTACLE_SPEED;
                    
                    const mapWidth = CANVAS_WIDTH * currentLevel.mapSize.width;
                    const mapHeight = CANVAS_HEIGHT * currentLevel.mapSize.height;
                    
                    if (obstacle.x <= 0 || obstacle.x + obstacle.width >= mapWidth) {
                        obstacle.velocityX *= -1;
                    }
                    if (obstacle.y <= 0 || obstacle.y + obstacle.height >= mapHeight) {
                        obstacle.velocityY *= -1;
                    }
                    return;
                }
                
                // Handle gravity pattern (attracted to player)
                if (obstacle.pattern === 'gravity') {
                    // Calculate direction to player
                    const dx = player.x - (obstacle.x + obstacle.width/2);
                    const dy = player.y - (obstacle.y + obstacle.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // Apply gravity if not too close
                    if (distance > 100) {
                        const gravityForce = 0.01;
                        obstacle.velocityX += (dx / distance) * gravityForce;
                        obstacle.velocityY += (dy / distance) * gravityForce;
                    }
                    
                    // Apply velocity with speed limit
                    const maxSpeed = 3;
                    const speed = Math.sqrt(obstacle.velocityX*obstacle.velocityX + obstacle.velocityY*obstacle.velocityY);
                    if (speed > maxSpeed) {
                        obstacle.velocityX = (obstacle.velocityX / speed) * maxSpeed;
                        obstacle.velocityY = (obstacle.velocityY / speed) * maxSpeed;
                    }
                    
                    obstacle.x += obstacle.velocityX;
                    obstacle.y += obstacle.velocityY;
                    
                    // Bounce off boundaries
                    const mapWidth = CANVAS_WIDTH * currentLevel.mapSize.width;
                    const mapHeight = CANVAS_HEIGHT * currentLevel.mapSize.height;
                    
                    if (obstacle.x <= 0 || obstacle.x + obstacle.width >= mapWidth) {
                        obstacle.velocityX *= -0.8;
                    }
                    if (obstacle.y <= 0 || obstacle.y + obstacle.height >= mapHeight) {
                        obstacle.velocityY *= -0.8;
                    }
                    return;
                }
                
                // Handle repel pattern (repels from player)
                if (obstacle.pattern === 'repel') {
                    // Calculate direction away from player
                    const dx = (obstacle.x + obstacle.width/2) - player.x;
                    const dy = (obstacle.y + obstacle.height/2) - player.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // Apply repel force if close
                    if (distance < 150) {
                        const repelForce = 0.05;
                        obstacle.velocityX += (dx / distance) * repelForce;
                        obstacle.velocityY += (dy / distance) * repelForce;
                    }
                    
                    // Apply velocity with speed limit
                    const maxSpeed = 3;
                    const speed = Math.sqrt(obstacle.velocityX*obstacle.velocityX + obstacle.velocityY*obstacle.velocityY);
                    if (speed > maxSpeed) {
                        obstacle.velocityX = (obstacle.velocityX / speed) * maxSpeed;
                        obstacle.velocityY = (obstacle.velocityY / speed) * maxSpeed;
                    }
                    
                    obstacle.x += obstacle.velocityX;
                    obstacle.y += obstacle.velocityY;
                    
                    // Bounce off boundaries
                    const mapWidth = CANVAS_WIDTH * currentLevel.mapSize.width;
                    const mapHeight = CANVAS_HEIGHT * currentLevel.mapSize.height;
                    
                    if (obstacle.x <= 0 || obstacle.x + obstacle.width >= mapWidth) {
                        obstacle.velocityX *= -0.8;
                    }
                    if (obstacle.y <= 0 || obstacle.y + obstacle.height >= mapHeight) {
                        obstacle.velocityY *= -0.8;
                    }
                    return;
                }
                
                // Handle attract pattern (attracted to player)
                if (obstacle.pattern === 'attract') {
                    // Calculate direction to player
                    const dx = player.x - (obstacle.x + obstacle.width/2);
                    const dy = player.y - (obstacle.y + obstacle.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // Apply attract force
                    const attractForce = 0.02;
                    obstacle.velocityX += (dx / distance) * attractForce;
                    obstacle.velocityY += (dy / distance) * attractForce;
                    
                    // Apply velocity with speed limit
                    const maxSpeed = 2;
                    const speed = Math.sqrt(obstacle.velocityX*obstacle.velocityX + obstacle.velocityY*obstacle.velocityY);
                    if (speed > maxSpeed) {
                        obstacle.velocityX = (obstacle.velocityX / speed) * maxSpeed;
                        obstacle.velocityY = (obstacle.velocityY / speed) * maxSpeed;
                    }
                    
                    obstacle.x += obstacle.velocityX;
                    obstacle.y += obstacle.velocityY;
                    
                    // Bounce off boundaries
                    const mapWidth = CANVAS_WIDTH * currentLevel.mapSize.width;
                    const mapHeight = CANVAS_HEIGHT * currentLevel.mapSize.height;
                    
                    if (obstacle.x <= 0 || obstacle.x + obstacle.width >= mapWidth) {
                        obstacle.velocityX *= -0.8;
                    }
                    if (obstacle.y <= 0 || obstacle.y + obstacle.height >= mapHeight) {
                        obstacle.velocityY *= -0.8;
                    }
                    return;
                }
                
                // Handle chaos pattern (random movement changes)
                if (obstacle.pattern === 'chaos') {
                    // Occasionally change direction randomly
                    if (Math.random() < 0.02) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 2 + 1;
                        obstacle.velocityX = Math.cos(angle) * speed;
                        obstacle.velocityY = Math.sin(angle) * speed;
                    }
                    
                    obstacle.x += obstacle.velocityX * OBSTACLE_SPEED;
                    obstacle.y += obstacle.velocityY * OBSTACLE_SPEED;
                    
                    // Bounce off boundaries
                    const mapWidth = CANVAS_WIDTH * currentLevel.mapSize.width;
                    const mapHeight = CANVAS_HEIGHT * currentLevel.mapSize.height;
                    
                    if (obstacle.x <= 0 || obstacle.x + obstacle.width >= mapWidth) {
                        obstacle.velocityX *= -1;
                    }
                    if (obstacle.y <= 0 || obstacle.y + obstacle.height >= mapHeight) {
                        obstacle.velocityY *= -1;
                    }
                    return;
                }
                
                // Handle fractal pattern (spawns smaller obstacles)
                if (obstacle.pattern === 'fractal') {
                    obstacle.x += obstacle.velocityX * OBSTACLE_SPEED;
                    obstacle.y += obstacle.velocityY * OBSTACLE_SPEED;
                    
                    // Bounce off boundaries
                    const mapWidth = CANVAS_WIDTH * currentLevel.mapSize.width;
                    const mapHeight = CANVAS_HEIGHT * currentLevel.mapSize.height;
                    
                    if (obstacle.x <= 0 || obstacle.x + obstacle.width >= mapWidth) {
                        obstacle.velocityX *= -1;
                    }
                    if (obstacle.y <= 0 || obstacle.y + obstacle.height >= mapHeight) {
                        obstacle.velocityY *= -1;
                    }
                    
                    // Spawn smaller obstacles periodically
                    if (!obstacle.lastSpawnTime) {
                        obstacle.lastSpawnTime = performance.now();
                        obstacle.spawnCount = obstacle.spawnCount || 2;
                    }
                    
                    const currentTime = performance.now();
                    if (currentTime - obstacle.lastSpawnTime > obstacle.spawnTime && obstacle.spawnCount > 0) {
                        // Spawn smaller obstacles
                        for (let i = 0; i < 2; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const newObstacle = {
                                x: obstacle.x + obstacle.width / 2,
                                y: obstacle.y + obstacle.height / 2,
                                width: obstacle.width * 0.6,
                                height: obstacle.height * 0.6,
                                color: obstacle.color,
                                velocityX: Math.cos(angle) * 2,
                                velocityY: Math.sin(angle) * 2,
                                pattern: 'bounce',
                                lifespan: 5000,
                                createdAt: currentTime
                            };
                            obstacles.push(newObstacle);
                        }
                        
                        obstacle.lastSpawnTime = currentTime;
                        obstacle.spawnCount--;
                    }
                    return;
                }
                
                // Handle loop pattern
                if (obstacle.pattern === 'loop') {
                    // Change direction if hitting boundaries
                    const mapWidth = CANVAS_WIDTH * currentLevel.mapSize.width;
                    const mapHeight = CANVAS_HEIGHT * currentLevel.mapSize.height;
                    
                    if (obstacle.x <= 0 || obstacle.x + obstacle.width >= mapWidth) {
                        obstacle.velocityX *= -1;
                    }
                    if (obstacle.y <= 0 || obstacle.y + obstacle.height >= mapHeight) {
                        obstacle.velocityY *= -1;
                    }
                }
                
                // Move obstacle
                obstacle.x += obstacle.velocityX * OBSTACLE_SPEED;
                obstacle.y += obstacle.velocityY * OBSTACLE_SPEED;
                
                // Handle horizontal pattern
                if (obstacle.pattern === 'horizontal') {
                    const mapWidth = CANVAS_WIDTH * currentLevel.mapSize.width;
                    
                    if (obstacle.x <= 0 || obstacle.x + obstacle.width >= mapWidth) {
                        obstacle.velocityX *= -1;
                    }
                }
                
                // Handle vertical pattern
                if (obstacle.pattern === 'vertical') {
                    const mapHeight = CANVAS_HEIGHT * currentLevel.mapSize.height;
                    
                    if (obstacle.y <= 0 || obstacle.y + obstacle.height >= mapHeight) {
                        obstacle.velocityY *= -1;
                    }
                }
            });
            
            // Remove obstacles with limited lifespan
            obstacles = obstacles.filter(obstacle => {
                if (obstacle.lifespan) {
                    return performance.now() - obstacle.createdAt < obstacle.lifespan;
                }
                return true;
            });
        }
        
        function checkCollisions() {
            // Check echo collisions
            echoes.forEach((echo, index) => {
                if (!echo.collected) {
                    const distance = Math.sqrt(
                        Math.pow(player.x - echo.x, 2) + 
                        Math.pow(player.y - echo.y, 2)
                    );
                    
                    if (distance < player.size + ECHO_SIZE) {
                        echo.collected = true;
                        if (settings.visualEffects) {
                            createEchoCollectEffect(echo.x, echo.y);
                        }
                        updateEchoCounter();
                        
                        // Check if all echoes are collected
                        const allCollected = echoes.every(e => e.collected);
                        if (allCollected) {
                            // Unlock exit
                            exit.unlocked = true;
                            if (settings.visualEffects) {
                                createExitUnlockEffect();
                            }
                        }
                    }
                }
            });
            
            // Check obstacle collisions
            obstacles.forEach(obstacle => {
                if (
                    player.x + player.size > obstacle.x &&
                    player.x - player.size < obstacle.x + obstacle.width &&
                    player.y + player.size > obstacle.y &&
                    player.y - player.size < obstacle.y + obstacle.height
                ) {
                    // Special handling for teleport/portal obstacles
                    if (obstacle.pattern === 'teleport' || obstacle.pattern === 'portal') {
                        if (obstacle.targetX !== undefined && obstacle.targetY !== undefined) {
                            player.x = obstacle.targetX;
                            player.y = obstacle.targetY;
                            if (settings.visualEffects) {
                                createTeleportEffect(player.x, player.y);
                            }
                            return;
                        }
                    }
                    
                    // Collision with obstacle - reset player position
                    player.x = currentLevel.playerStart.x * CANVAS_WIDTH;
                    player.y = currentLevel.playerStart.y * CANVAS_HEIGHT;
                    if (settings.visualEffects) {
                        createDeathEffect(player.x, player.y);
                    }
                }
            });
            
            // Check exit collision
            if (
                exit.unlocked &&
                player.x + player.size > exit.x &&
                player.x - player.size < exit.x + exit.width &&
                player.y + player.size > exit.y &&
                player.y - player.size < exit.y + exit.height
            ) {
                completeLevel();
            }
        }
        
        function createEchoCollectEffect(x, y) {
            // Create particles
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 2 + 1;
                const size = Math.random() * 3 + 2;
                const lifespan = Math.random() * 1000 + 500;
                
                particles.push({
                    x: x,
                    y: y,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    size: size,
                    color: 'rgba(255, 255, 255, 0.8)',
                    lifespan: lifespan,
                    createdAt: performance.now()
                });
            }
        }
        
        function createExitUnlockEffect() {
            // Create particles around the exit
            for (let i = 0; i < 50; i++) {
                const x = exit.x + Math.random() * exit.width;
                const y = exit.y + Math.random() * exit.height;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                const size = Math.random() * 3 + 2;
                const lifespan = Math.random() * 1500 + 1000;
                
                particles.push({
                    x: x,
                    y: y,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    size: size,
                    color: 'rgba(100, 255, 100, 0.8)',
                    lifespan: lifespan,
                    createdAt: performance.now()
                });
            }
        }
        
        function createDeathEffect(x, y) {
            // Create particles
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 2;
                const size = Math.random() * 4 + 2;
                const lifespan = Math.random() * 1000 + 500;
                
                particles.push({
                    x: x,
                    y: y,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    size: size,
                    color: 'rgba(255, 100, 100, 0.8)',
                    lifespan: lifespan,
                    createdAt: performance.now()
                });
            }
        }
        
        function createTeleportEffect(x, y) {
            // Create particles
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 2;
                const size = Math.random() * 3 + 2;
                const lifespan = Math.random() * 800 + 400;
                
                particles.push({
                    x: x,
                    y: y,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    size: size,
                    color: 'rgba(100, 100, 255, 0.8)',
                    lifespan: lifespan,
                    createdAt: performance.now()
                });
            }
        }
        
        function updateParticles(deltaTime) {
            const currentTime = performance.now();
            
            // Update existing particles
            particles = particles.filter(particle => {
                const age = currentTime - particle.createdAt;
                
                // Remove if expired
                if (age > particle.lifespan) {
                    return false;
                }
                
                // Update position
                particle.x += particle.velocityX;
                particle.y += particle.velocityY;
                
                // Slow down
                particle.velocityX *= 0.98;
                particle.velocityY *= 0.98;
                
                // Fade out
                const opacity = 1 - (age / particle.lifespan);
                particle.color = particle.color.replace(/[\d.]+\)$/g, `${opacity})`);
                
                return true;
            });
        }
        
        function completeLevel() {
            // Stop the game loop
            gameState.isPlaying = false;
            cancelAnimationFrame(animationFrameId);
            
            // Mark level as completed
            if (!gameState.completedLevels.includes(currentLevel.id)) {
                gameState.completedLevels.push(currentLevel.id);
            }
            
            // Unlock next level
            if (currentLevel.id === gameState.maxUnlockedLevel && currentLevel.id < levels.length) {
                gameState.maxUnlockedLevel++;
            }
            
            // Save game state
            try {
                localStorage.setItem('echoesGameState', JSON.stringify({
                    maxUnlockedLevel: gameState.maxUnlockedLevel,
                    completedLevels: gameState.completedLevels
                }));
            } catch (e) {
                console.error("Could not save game state:", e);
            }
            
            // Calculate stars based on echoes collected
            const collectedEchoes = echoes.filter(echo => echo.collected).length;
            const totalEchoes = echoes.length;
            const stars = Math.ceil((collectedEchoes / totalEchoes) * 3);
            
            // Update level complete UI
            document.getElementById('completion-message').textContent = `You collected ${collectedEchoes}/${totalEchoes} echoes!`;
            
            const starsContainer = document.getElementById('stars-container');
            starsContainer.innerHTML = '';
            
            for (let i = 0; i < 3; i++) {
                const star = document.createElement('span');
                star.classList.add('star');
                if (i >= stars) {
                    star.classList.add('star-empty');
                }
                star.textContent = '★';
                starsContainer.appendChild(star);
            }
            
            // Show level complete screen
            levelComplete.classList.remove('menu-hidden');
            
            // Hide next level button if this is the last level
            if (currentLevel.id === levels.length) {
                document.getElementById('next-level-btn').style.display = 'none';
            } else {
                document.getElementById('next-level-btn').style.display = 'block';
            }
        }
        
        function render() {
            // Clear canvases
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            uiCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Apply camera transformation
            ctx.save();
            ctx.translate(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-CANVAS_WIDTH / 2 - camera.x, -CANVAS_HEIGHT / 2 - camera.y);
            
            // Draw exit
            drawExit();
            
            // Draw echoes
            drawEchoes();
            
            // Draw obstacles
            drawObstacles();
            
            // Draw player
            drawPlayer();
            
            // Draw particles
            if (settings.visualEffects) {
                drawParticles();
            }
            
            // Restore context
            ctx.restore();
            
            // Draw time fracture effect (not affected by camera)
            if (gameState.timeFracture.active && settings.visualEffects) {
                drawTimeFractureEffect();
            }
            
            // Level-specific rendering
            if (currentLevel && currentLevel.id === 2) {
                // Level 2: "Memento Mori" - World fades unless you keep moving
                if (player.velocityX === 0 && player.velocityY === 0) {
                    // Add a fading overlay
                    const fadeIntensity = Math.min(0.7, (performance.now() % 3000) / 3000 * 0.7);
                    uiCtx.fillStyle = `rgba(0, 0, 0, ${fadeIntensity})`;
                    uiCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                }
            }
        }
        
        function drawExit() {
            ctx.fillStyle = exit.unlocked ? 'rgba(100, 255, 100, 0.8)' : 'rgba(150, 150, 150, 0.5)';
            ctx.fillRect(exit.x, exit.y, exit.width, exit.height);
            
            // Draw glow if unlocked
            if (exit.unlocked) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(100, 255, 100, 0.8)';
                ctx.fillRect(exit.x, exit.y, exit.width, exit.height);
                ctx.shadowBlur = 0;
            }
        }
        
        function drawEchoes() {
            echoes.forEach(echo => {
                if (!echo.collected) {
                    // Draw glow
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    
                    // Draw echo
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(echo.x, echo.y, ECHO_SIZE, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                    
                    // Draw inner circle
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.beginPath();
                    ctx.arc(echo.x, echo.y, ECHO_SIZE * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Pulsating effect
                    if (settings.visualEffects) {
                        const pulseSize = Math.sin(performance.now() / 500) * 5 + 5;
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(echo.x, echo.y, ECHO_SIZE + pulseSize, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
            });
        }
        
        function drawObstacles() {
            obstacles.forEach(obstacle => {
                // Draw shadow
                if (settings.visualEffects) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = obstacle.color;
                }
                
                // Draw obstacle
                ctx.fillStyle = obstacle.color;
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                
                // Reset shadow
                ctx.shadowBlur = 0;
                
                // Draw pattern indicator
                if (obstacle.pattern === 'mirror') {
                    // Draw mirror pattern indicator
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x + obstacle.width * 0.2, obstacle.y + obstacle.height * 0.2);
                    ctx.lineTo(obstacle.x + obstacle.width * 0.8, obstacle.y + obstacle.height * 0.8);
                    ctx.moveTo(obstacle.x + obstacle.width * 0.2, obstacle.y + obstacle.height * 0.8);
                    ctx.lineTo(obstacle.x + obstacle.width * 0.8, obstacle.y + obstacle.height * 0.2);
                    ctx.stroke();
                } else if (obstacle.pattern === 'loop') {
                    // Draw loop pattern indicator
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2, 
                             obstacle.width * 0.3, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (obstacle.pattern === 'quantum') {
                    // Draw quantum pattern indicator
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2, 
                             obstacle.width * 0.3, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw quantum connection line
                    const pairedObstacle = obstacles.find(o => 
                        o.pattern === 'quantum' && 
                        o.pair === obstacle.pair && 
                        o !== obstacle
                    );
                    
                    if (pairedObstacle) {
                        ctx.strokeStyle = 'rgba(100, 100, 255, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(
                            obstacle.x + obstacle.width / 2,
                            obstacle.y + obstacle.height / 2
                        );
                        ctx.lineTo(
                            pairedObstacle.x + pairedObstacle.width / 2,
                            pairedObstacle.y + pairedObstacle.height / 2
                        );
                        ctx.stroke();
                    }
                } else if (obstacle.pattern === 'gravity') {
                    // Draw gravity pattern indicator
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    
                    const centerX = obstacle.x + obstacle.width / 2;
                    const centerY = obstacle.y + obstacle.height / 2;
                    
                    // Draw arrows pointing inward
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * Math.PI / 2);
                        const startX = centerX + Math.cos(angle) * obstacle.width * 0.6;
                        const startY = centerY + Math.sin(angle) * obstacle.height * 0.6;
                        const endX = centerX + Math.cos(angle) * obstacle.width * 0.3;
                        const endY = centerY + Math.sin(angle) * obstacle.height * 0.3;
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                        
                        // Arrow head
                        const headSize = 3;
                        const headAngle1 = angle + Math.PI * 0.8;
                        const headAngle2 = angle - Math.PI * 0.8;
                        
                        ctx.beginPath();
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(
                            endX + Math.cos(headAngle1) * headSize,
                            endY + Math.sin(headAngle1) * headSize
                        );
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(
                            endX + Math.cos(headAngle2) * headSize,
                            endY + Math.sin(headAngle2) * headSize
                        );
                        ctx.stroke();
                    }
                } else if (obstacle.pattern === 'teleport' || obstacle.pattern === 'portal') {
                    // Draw portal pattern indicator
                    ctx.strokeStyle = 'rgba(100, 100, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2, 
                             obstacle.width * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw swirl
                    if (settings.visualEffects) {
                        const centerX = obstacle.x + obstacle.width / 2;
                        const centerY = obstacle.y + obstacle.height / 2;
                        const radius = obstacle.width * 0.3;
                        const startAngle = (performance.now() / 1000) % (Math.PI * 2);
                        
                        ctx.strokeStyle = 'rgba(100, 100, 255, 0.5)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, startAngle, startAngle + Math.PI);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius * 0.7, startAngle + Math.PI, startAngle + Math.PI * 2);
                        ctx.stroke();
                    }
                }
            });
        }
        
        function drawPlayer() {
            // Draw glow
            const glowRadius = player.size + player.glowSize;
            const gradient = ctx.createRadialGradient(
                player.x, player.y, player.size * 0.5,
                player.x, player.y, glowRadius
            );
            gradient.addColorStop(0, player.glowColor);
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(player.x, player.y, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw player
            if (settings.visualEffects) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            }
            
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
            ctx.fill();
            
            // Reset shadow
            ctx.shadowBlur = 0;
            
            // Draw inner circle
            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.size * 0.6, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw time fracture indicator
            if (gameState.timeFracture.active) {
                ctx.strokeStyle = 'rgba(77, 195, 247, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size * 1.5, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        function drawParticles() {
            particles.forEach(particle => {
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawTimeFractureEffect() {
            // Draw time fracture overlay
            uiCtx.fillStyle = 'rgba(77, 195, 247, 0.1)';
            uiCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw time fracture lines
            uiCtx.strokeStyle = 'rgba(77, 195, 247, 0.3)';
            uiCtx.lineWidth = 1;
            
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * CANVAS_WIDTH;
                const y = Math.random() * CANVAS_HEIGHT;
                const length = Math.random() * (CANVAS_WIDTH / 8) + (CANVAS_WIDTH / 16);
                const angle = Math.random() * Math.PI * 2;
                
                uiCtx.beginPath();
                uiCtx.moveTo(x, y);
                uiCtx.lineTo(
                    x + Math.cos(angle) * length,
                    y + Math.sin(angle) * length
                );
                uiCtx.stroke();
            }
            
            // Draw future paths
            if (player.velocityX !== 0 || player.velocityY !== 0) {
                // Apply camera transformation for player-relative effects
                uiCtx.save();
                uiCtx.translate(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                uiCtx.scale(camera.zoom, camera.zoom);
                uiCtx.translate(-CANVAS_WIDTH / 2 - camera.x, -CANVAS_HEIGHT / 2 - camera.y);
                
                uiCtx.strokeStyle = 'rgba(77, 195, 247, 0.5)';
                uiCtx.lineWidth = 2;
                
                // Draw straight path
                uiCtx.beginPath();
                uiCtx.moveTo(player.x, player.y);
                uiCtx.lineTo(
                    player.x + player.velocityX * 20,
                    player.y + player.velocityY * 20
                );
                uiCtx.stroke();
                
                // Draw alternative paths
                uiCtx.strokeStyle = 'rgba(77, 195, 247, 0.3)';
                uiCtx.lineWidth = 1;
                
                // Alternative path 1
                const angle1 = Math.atan2(player.velocityY, player.velocityX) + Math.PI / 6;
                uiCtx.beginPath();
                uiCtx.moveTo(player.x, player.y);
                uiCtx.lineTo(
                    player.x + Math.cos(angle1) * player.speed * 15,
                    player.y + Math.sin(angle1) * player.speed * 15
                );
                uiCtx.stroke();
                
                // Alternative path 2
                const angle2 = Math.atan2(player.velocityY, player.velocityX) - Math.PI / 6;
                uiCtx.beginPath();
                uiCtx.moveTo(player.x, player.y);
                uiCtx.lineTo(
                    player.x + Math.cos(angle2) * player.speed * 15,
                    player.y + Math.sin(angle2) * player.speed * 15
                );
                uiCtx.stroke();
                
                // Restore context
                uiCtx.restore();
            }
        }
        
        // Initialize the game when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
