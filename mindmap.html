<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Cosmic Mindmap | Professional</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Montserrat:wght@500;600;700&display=swap');

    :root {
      --primary: #3a86ff;
      --primary-light: rgba(58, 134, 255, 0.2);
      --primary-dark: #2563eb;
      --secondary: #8b5cf6;
      --accent: #f43f5e;
      --success: #10b981;
      --warning: #f59e0b;
      --background: #0f172a;
      --background-light: #1e293b;
      --foreground: #f8fafc;
      --foreground-muted: #94a3b8;
      --node-glow: 0 0 15px rgba(58, 134, 255, 0.4);
      --panel-bg: rgba(30, 41, 59, 0.85);
      --panel-border: 1px solid rgba(58, 134, 255, 0.2);
      --radius-sm: 4px;
      --radius-md: 6px;
      --radius-lg: 8px;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
      --transition-fast: 0.15s ease;
      --transition-normal: 0.3s ease;
      --header-height: 48px;
      --toolbar-height: 48px;
      --z-header: 50;
      --z-toolbar: 50;
      --z-panel: 100;
      --z-modal: 200;
      --z-toast: 300;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: var(--background);
      color: var(--foreground);
      overflow: hidden;
      height: 100vh;
      width: 100vw;
      touch-action: none;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .app-container {
      position: relative;
      width: 100%;
      height: 100%;
    }

    /* Cosmic Background */
    .cosmic-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      overflow: hidden;
    }

    .star {
      position: absolute;
      background-color: #fff;
      border-radius: 50%;
      opacity: 0.8;
      animation: twinkle 4s infinite ease-in-out;
    }

    .nebula {
      position: absolute;
      border-radius: 50%;
      filter: blur(40px);
      opacity: 0.08;
      background: radial-gradient(circle, var(--primary) 0%, transparent 70%);
      animation: pulse 15s infinite alternate;
    }

    @keyframes twinkle {
      0%, 100% { opacity: 0.2; }
      50% { opacity: 0.8; }
    }

    @keyframes pulse {
      0% { transform: scale(1); opacity: 0.05; }
      50% { transform: scale(1.05); opacity: 0.08; }
      100% { transform: scale(1); opacity: 0.05; }
    }

    /* Canvas */
    #mindmap-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      cursor: move;
    }

    /* Nodes */
    .node {
      position: absolute;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 500;
      cursor: pointer;
      box-shadow: var(--node-glow);
      transition: transform 0.3s, box-shadow 0.3s;
      z-index: 2;
      background: radial-gradient(circle at 30% 30%, var(--node-color) 0%, rgba(0, 0, 0, 0.5) 100%);
      overflow: hidden;
      user-select: none;
    }

    .node::after {
      content: '';
      position: absolute;
      top: -30%;
      left: -30%;
      width: 60%;
      height: 60%;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      filter: blur(5px);
    }

    .node:hover {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(58, 134, 255, 0.6);
    }

    .node.selected {
      box-shadow: 0 0 25px var(--accent);
    }

    .node-label {
      font-size: 12px;
      text-align: center;
      padding: 5px;
      pointer-events: none;
      text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .node.sun {
      --node-color: #ff9500;
      animation: pulse-sun 4s infinite alternate;
    }

    .node.planet {
      --node-color: var(--primary);
      animation: pulse-planet 6s infinite alternate;
    }

    .node.moon {
      --node-color: #94a3b8;
      animation: pulse-moon 8s infinite alternate;
    }

    .node.asteroid {
      --node-color: #cbd5e1;
      animation: pulse-asteroid 3s infinite alternate;
    }

    .node.blackhole {
      --node-color: #020617;
      animation: pulse-blackhole 5s infinite alternate;
    }

    @keyframes pulse-sun {
      0% { box-shadow: 0 0 20px rgba(255, 149, 0, 0.6); }
      100% { box-shadow: 0 0 30px rgba(255, 149, 0, 0.8); }
    }

    @keyframes pulse-planet {
      0% { box-shadow: 0 0 10px rgba(58, 134, 255, 0.5); }
      100% { box-shadow: 0 0 20px rgba(58, 134, 255, 0.7); }
    }

    @keyframes pulse-moon {
      0% { box-shadow: 0 0 5px rgba(148, 163, 184, 0.4); }
      100% { box-shadow: 0 0 15px rgba(148, 163, 184, 0.6); }
    }

    @keyframes pulse-asteroid {
      0% { box-shadow: 0 0 3px rgba(203, 213, 225, 0.3); }
      100% { box-shadow: 0 0 8px rgba(203, 213, 225, 0.5); }
    }

    @keyframes pulse-blackhole {
      0% { box-shadow: 0 0 15px rgba(139, 92, 246, 0.6); }
      100% { box-shadow: 0 0 25px rgba(139, 92, 246, 0.8); }
    }

    /* Connections */
    .connection {
      position: absolute;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(58, 134, 255, 0.5), transparent);
      transform-origin: 0 0;
      z-index: 1;
      pointer-events: none;
      opacity: 0.6;
    }

    .connection.strong {
      height: 3px;
      background: linear-gradient(90deg, transparent, rgba(58, 134, 255, 0.8), transparent);
      opacity: 0.8;
    }

    .connection.weak {
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(58, 134, 255, 0.3), transparent);
      opacity: 0.4;
    }

    /* Header */
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: var(--header-height);
      z-index: var(--z-header);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 8px;
      background: var(--panel-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-bottom: var(--panel-border);
      transition: transform var(--transition-normal);
    }

    .header.collapsed {
      transform: translateY(calc(-100% + 8px));
    }

    .header.collapsed:hover,
    .header.collapsed:focus-within {
      transform: translateY(0);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .header-center {
      flex: 1;
      display: flex;
      justify-content: center;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .logo {
      font-family: 'Montserrat', sans-serif;
      font-size: 16px;
      font-weight: 600;
      color: var(--primary);
      white-space: nowrap;
      letter-spacing: 0.5px;
    }

    .mindmap-title {
      padding: 6px 10px;
      background: rgba(58, 134, 255, 0.1);
      border: var(--panel-border);
      border-radius: var(--radius-md);
      width: 160px;
      max-width: 100%;
      font-size: 14px;
      color: var(--foreground);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }

    /* Toolbar */
    .toolbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: var(--toolbar-height);
      display: flex;
      justify-content: center;
      background: var(--panel-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-top: var(--panel-border);
      z-index: var(--z-toolbar);
      transition: transform var(--transition-normal);
    }

    .toolbar.collapsed {
      transform: translateY(calc(100% - 8px));
    }

    .toolbar.collapsed:hover,
    .toolbar.collapsed:focus-within {
      transform: translateY(0);
    }

    .toolbar-inner {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 0 8px;
      height: 100%;
      overflow-x: auto;
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE and Edge */
    }

    .toolbar-inner::-webkit-scrollbar {
      display: none; /* Chrome, Safari, Opera */
    }

    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 0 4px;
      border-right: 1px solid rgba(255, 255, 255, 0.1);
    }

    .toolbar-group:last-child {
      border-right: none;
    }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: none;
      background: transparent;
      color: var(--foreground);
      cursor: pointer;
      transition: all var(--transition-fast);
      border-radius: var(--radius-md);
      font-size: 14px;
      font-weight: 500;
      padding: 0;
      position: relative;
    }

    .btn:focus {
      outline: none;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-icon {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: transparent;
    }

    .btn-icon:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .btn-icon.active {
      background: var(--primary-light);
      color: var(--primary);
    }

    .btn-primary {
      background: var(--primary);
      color: white;
      padding: 6px 12px;
    }

    .btn-primary:hover {
      background: var(--primary-dark);
    }

    .btn-outline {
      border: 1px solid var(--foreground-muted);
      padding: 6px 12px;
    }

    .btn-outline:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .btn-danger {
      background: var(--accent);
      color: white;
      padding: 6px 12px;
    }

    .btn-danger:hover {
      opacity: 0.9;
    }

    .btn-sm {
      padding: 4px 8px;
      font-size: 12px;
    }

    /* Collapsible Panels */
    .panel {
      position: absolute;
      background: var(--panel-bg);
      border: var(--panel-border);
      border-radius: var(--radius-md);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: var(--shadow-md);
      z-index: var(--z-panel);
      transition: transform var(--transition-normal), opacity var(--transition-normal);
      overflow: hidden;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .panel-title {
      font-family: 'Montserrat', sans-serif;
      font-size: 16px;
      font-weight: 600;
      color: var(--primary);
    }

    .panel-body {
      padding: 16px;
      overflow-y: auto;
      max-height: 80vh;
    }

    .panel-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      padding: 12px 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Side Panel */
    .side-panel {
      position: fixed;
      top: var(--header-height);
      bottom: var(--toolbar-height);
      width: 280px;
      background: var(--panel-bg);
      border-right: var(--panel-border);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: var(--z-panel);
      transition: transform var(--transition-normal);
      display: flex;
      flex-direction: column;
    }

    .side-panel-left {
      left: 0;
      transform: translateX(-100%);
    }

    .side-panel-left.active {
      transform: translateX(0);
    }

    .side-panel-right {
      right: 0;
      transform: translateX(100%);
    }

    .side-panel-right.active {
      transform: translateX(0);
    }

    .side-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .side-panel-title {
      font-family: 'Montserrat', sans-serif;
      font-size: 16px;
      font-weight: 600;
      color: var(--primary);
    }

    .side-panel-body {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .side-panel-footer {
      padding: 12px 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Node Editor */
    .node-editor {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      width: 90%;
      max-width: 350px;
      background: var(--panel-bg);
      border-radius: var(--radius-lg);
      border: var(--panel-border);
      box-shadow: var(--shadow-lg);
      z-index: var(--z-modal);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: none;
      opacity: 0;
      max-height: 90vh;
      overflow-y: auto;
    }

    .node-editor.active {
      display: block;
      animation: modal-in var(--transition-normal) forwards;
    }

    @keyframes modal-in {
      to { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* Form Elements */
    .form-group {
      margin-bottom: 16px;
    }

    .form-label {
      display: block;
      margin-bottom: 6px;
      font-size: 14px;
      color: var(--foreground);
      font-weight: 500;
    }

    .form-input {
      width: 100%;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(58, 134, 255, 0.3);
      border-radius: var(--radius-md);
      color: var(--foreground);
      font-family: 'Inter', sans-serif;
      font-size: 14px;
    }

    .form-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .form-select {
      width: 100%;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(58, 134, 255, 0.3);
      border-radius: var(--radius-md);
      color: var(--foreground);
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 16px;
    }

    .form-select:focus {
      outline: none;
      border-color: var(--primary);
    }

    .color-options {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .color-option {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      transition: transform var(--transition-fast);
      border: 2px solid transparent;
    }

    .color-option:hover {
      transform: scale(1.1);
    }

    .color-option.selected {
      border-color: white;
    }

    /* Toast */
    .toast-container {
      position: fixed;
      bottom: calc(var(--toolbar-height) + 8px);
      right: 8px;
      z-index: var(--z-toast);
      max-width: 90%;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .toast {
      padding: 10px 16px;
      background: var(--panel-bg);
      border-left: 4px solid var(--primary);
      border-radius: var(--radius-md);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: var(--shadow-md);
      display: flex;
      align-items: center;
      gap: 8px;
      animation: toast-in var(--transition-normal) forwards, toast-out var(--transition-normal) 3s forwards;
      opacity: 0;
      transform: translateX(50px);
      max-width: 100%;
      word-break: break-word;
      font-size: 14px;
    }

    .toast.success {
      border-left-color: var(--success);
    }

    .toast.warning {
      border-left-color: var(--warning);
    }

    .toast.error {
      border-left-color: var(--accent);
    }

    @keyframes toast-in {
      to { opacity: 1; transform: translateX(0); }
    }

    @keyframes toast-out {
      to { opacity: 0; transform: translateX(50px); }
    }

    /* Gallery */
    .gallery {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--background);
      z-index: var(--z-modal);
      padding: 16px;
      display: none;
      flex-direction: column;
      gap: 16px;
    }

    .gallery.active {
      display: flex;
    }

    .gallery-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 16px;
      overflow-y: auto;
      padding: 8px;
      flex: 1;
    }

    .gallery-item {
      background: var(--panel-bg);
      border: var(--panel-border);
      border-radius: var(--radius-md);
      overflow: hidden;
      transition: transform var(--transition-normal), box-shadow var(--transition-normal);
      cursor: pointer;
      position: relative;
    }

    .gallery-item:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-lg);
    }

    .gallery-item-preview {
      height: 120px;
      background: var(--background-light);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .gallery-item-info {
      padding: 12px;
    }

    .gallery-item-title {
      font-family: 'Montserrat', sans-serif;
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .gallery-item-date {
      font-size: 12px;
      color: var(--foreground-muted);
    }

    .gallery-item-actions {
      position: absolute;
      top: 8px;
      right: 8px;
      display: flex;
      gap: 4px;
    }

    /* Mini Map */
    .mini-map {
      position: absolute;
      bottom: calc(var(--toolbar-height) + 8px);
      left: 8px;
      width: 120px;
      height: 120px;
      background: var(--panel-bg);
      border: var(--panel-border);
      border-radius: var(--radius-md);
      overflow: hidden;
      z-index: var(--z-panel);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      display: none;
      box-shadow: var(--shadow-md);
    }

    .mini-map.active {
      display: block;
    }

    .mini-map-content {
      position: relative;
      width: 100%;
      height: 100%;
    }

    .mini-map-node {
      position: absolute;
      border-radius: 50%;
      background-color: var(--node-color);
    }

    .mini-map-viewport {
      position: absolute;
      border: 1px solid var(--primary);
      background: rgba(58, 134, 255, 0.1);
      pointer-events: none;
    }

    /* Search */
    .search-container {
      position: absolute;
      top: calc(var(--header-height) + 8px);
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 300px;
      z-index: var(--z-panel);
      display: none;
    }

    .search-container.active {
      display: block;
    }

    .search-input {
      width: 100%;
      padding: 8px 12px;
      padding-left: 36px;
      background: var(--panel-bg);
      border: var(--panel-border);
      border-radius: var(--radius-md);
      color: var(--foreground);
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }

    .search-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .search-icon {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--foreground-muted);
      pointer-events: none;
    }

    .search-results {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      margin-top: 4px;
      background: var(--panel-bg);
      border: var(--panel-border);
      border-radius: var(--radius-md);
      max-height: 200px;
      overflow-y: auto;
      display: none;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: var(--shadow-md);
    }

    .search-results.active {
      display: block;
    }

    .search-result {
      padding: 8px 12px;
      cursor: pointer;
      transition: background var(--transition-fast);
      font-size: 14px;
    }

    .search-result:hover {
      background: rgba(58, 134, 255, 0.1);
    }

    .search-highlight {
      color: var(--primary);
      font-weight: 500;
    }

    /* Context Menu */
    .context-menu {
      position: absolute;
      background: var(--panel-bg);
      border: var(--panel-border);
      border-radius: var(--radius-md);
      min-width: 180px;
      z-index: var(--z-panel);
      display: none;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: var(--shadow-md);
      overflow: hidden;
    }

    .context-menu.active {
      display: block;
    }

    .context-menu-item {
      padding: 8px 12px;
      cursor: pointer;
      transition: background var(--transition-fast);
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }

    .context-menu-item:hover {
      background: rgba(58, 134, 255, 0.1);
    }

    .context-menu-separator {
      height: 1px;
      background: rgba(255, 255, 255, 0.1);
      margin: 4px 0;
    }

    /* Mode Indicator */
    .mode-indicator {
      position: fixed;
      top: calc(var(--header-height) + 8px);
      left: 50%;
      transform: translateX(-50%);
      background: var(--panel-bg);
      border: var(--panel-border);
      border-radius: 20px;
      padding: 4px 12px;
      font-size: 13px;
      color: var(--primary);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      z-index: var(--z-panel);
      display: none;
      box-shadow: var(--shadow-sm);
    }

    .mode-indicator.active {
      display: block;
      animation: fade-in-out 2s forwards;
    }

    @keyframes fade-in-out {
      0% { opacity: 0; }
      20% { opacity: 1; }
      80% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Quick Actions */
    .quick-actions {
      position: fixed;
      right: 8px;
      bottom: calc(var(--toolbar-height) + 8px);
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: var(--z-panel);
    }

    .quick-action {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--panel-bg);
      border: var(--panel-border);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all var(--transition-fast);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      box-shadow: var(--shadow-sm);
      color: var(--foreground);
    }

    .quick-action:hover {
      background: rgba(58, 134, 255, 0.1);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      margin-bottom: 16px;
      overflow-x: auto;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    .tabs::-webkit-scrollbar {
      display: none;
    }

    .tab {
      padding: 8px 16px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all var(--transition-fast);
      white-space: nowrap;
      font-size: 14px;
      color: var(--foreground-muted);
    }

    .tab.active {
      border-bottom-color: var(--primary);
      color: var(--primary);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Loading Animation */
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--background);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .cosmic-loader {
      width: 80px;
      height: 80px;
      position: relative;
    }

    .cosmic-loader .planet {
      position: absolute;
      width: 40px;
      height: 40px;
      background: radial-gradient(circle at 30% 30%, var(--primary) 0%, var(--background) 100%);
      border-radius: 50%;
      top: 20px;
      left: 20px;
      box-shadow: 0 0 20px rgba(58, 134, 255, 0.4);
    }

    .cosmic-loader .orbit {
      position: absolute;
      width: 80px;
      height: 80px;
      border: 1px solid rgba(58, 134, 255, 0.2);
      border-radius: 50%;
      animation: rotate 2s linear infinite;
    }

    .cosmic-loader .satellite {
      position: absolute;
      width: 12px;
      height: 12px;
      background: var(--secondary);
      border-radius: 50%;
      top: -6px;
      left: 34px;
      box-shadow: 0 0 10px rgba(139, 92, 246, 0.6);
    }

    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    /* Responsive */
    @media (max-width: 768px) {
      .mindmap-title {
        width: 120px;
      }
      
      .side-panel {
        width: 260px;
      }
    }

    @media (max-width: 480px) {
      .mindmap-title {
        width: 100px;
      }
      
      .side-panel {
        width: 85%;
      }
      
      .node-editor {
        width: 95%;
      }
    }

    /* Utility Classes */
    .hidden {
      display: none !important;
    }

    .flex {
      display: flex;
    }

    .flex-col {
      flex-direction: column;
    }

    .items-center {
      align-items: center;
    }

    .justify-between {
      justify-content: space-between;
    }

    .gap-2 {
      gap: 8px;
    }

    .gap-4 {
      gap: 16px;
    }

    .mt-2 {
      margin-top: 8px;
    }

    .mb-2 {
      margin-bottom: 8px;
    }

    .mb-4 {
      margin-bottom: 16px;
    }

    .w-full {
      width: 100%;
    }

    .text-sm {
      font-size: 14px;
    }

    .text-xs {
      font-size: 12px;
    }

    .text-muted {
      color: var(--foreground-muted);
    }

    .text-primary {
      color: var(--primary);
    }

    /* SVG Icons */
    .icon {
      width: 20px;
      height: 20px;
      stroke-width: 2;
      stroke: currentColor;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .icon-sm {
      width: 16px;
      height: 16px;
    }

    .icon-lg {
      width: 24px;
      height: 24px;
    }

    /* Tooltip */
    .tooltip {
      position: relative;
    }

    .tooltip::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--panel-bg);
      color: var(--foreground);
      padding: 4px 8px;
      border-radius: var(--radius-sm);
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-fast);
      pointer-events: none;
      margin-bottom: 4px;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      border: var(--panel-border);
      z-index: 10;
    }

    .tooltip:hover::after {
      opacity: 1;
      visibility: visible;
    }

    /* Keyboard Shortcuts */
    .kbd {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-sm);
      padding: 2px 6px;
      font-family: monospace;
      font-size: 12px;
      min-width: 20px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }
  </style>
</head>
<body>
  <!-- Loading Screen -->
  <div class="loading-screen" id="loading-screen">
    <div class="cosmic-loader">
      <div class="planet"></div>
      <div class="orbit">
        <div class="satellite"></div>
      </div>
    </div>
  </div>

  <div class="app-container">
    <!-- Cosmic Background -->
    <div class="cosmic-background" id="cosmic-background"></div>

    <!-- Main Canvas -->
    <div id="mindmap-canvas"></div>

    <!-- Header -->
    <div class="header" id="header">
      <div class="header-left">
        <button class="btn btn-icon tooltip" id="home-btn" data-tooltip="Home">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
            <polyline points="9 22 9 12 15 12 15 22"></polyline>
          </svg>
        </button>
        <div class="logo">Cosmic Map</div>
      </div>
      <div class="header-center">
        <input type="text" class="mindmap-title" id="mindmap-title" value="My Cosmic Universe" placeholder="Map title...">
      </div>
      <div class="header-right">
        <button class="btn btn-icon tooltip" id="toggle-header" data-tooltip="Toggle Header">
          <svg class="icon" viewBox="0 0 24 24">
            <polyline points="18 15 12 9 6 15"></polyline>
          </svg>
        </button>
        <button class="btn btn-icon tooltip" id="menu-btn" data-tooltip="Menu">
          <svg class="icon" viewBox="0 0 24 24">
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
          </svg>
        </button>
      </div>
    </div>

    <!-- Mode Indicator -->
    <div class="mode-indicator" id="mode-indicator">
      Mode: Default
    </div>

    <!-- Search -->
    <div class="search-container" id="search-container">
      <svg class="icon search-icon" viewBox="0 0 24 24">
        <circle cx="11" cy="11" r="8"></circle>
        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      </svg>
      <input type="text" class="search-input" id="search-input" placeholder="Search nodes...">
      <div class="search-results" id="search-results">
        <!-- Search results will be added dynamically -->
      </div>
    </div>

    <!-- Mini Map -->
    <div class="mini-map" id="mini-map">
      <div class="mini-map-content" id="mini-map-content">
        <!-- Mini map content will be added dynamically -->
      </div>
    </div>

    <!-- Quick Actions -->
    <div class="quick-actions" id="quick-actions">
      <button class="quick-action tooltip" id="search-btn" data-tooltip="Search">
        <svg class="icon" viewBox="0 0 24 24">
          <circle cx="11" cy="11" r="8"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
        </svg>
      </button>
      <button class="quick-action tooltip" id="toggle-minimap" data-tooltip="Toggle Mini-map">
        <svg class="icon" viewBox="0 0 24 24">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          <circle cx="8.5" cy="8.5" r="1.5"></circle>
          <polyline points="21 15 16 10 5 21"></polyline>
        </svg>
      </button>
      <button class="quick-action tooltip" id="quick-save" data-tooltip="Quick Save">
        <svg class="icon" viewBox="0 0 24 24">
          <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
          <polyline points="17 21 17 13 7 13 7 21"></polyline>
          <polyline points="7 3 7 8 15 8"></polyline>
        </svg>
      </button>
      <button class="quick-action tooltip" id="zoom-in" data-tooltip="Zoom In">
        <svg class="icon" viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="10"></circle>
          <line x1="12" y1="8" x2="12" y2="16"></line>
          <line x1="8" y1="12" x2="16" y2="12"></line>
        </svg>
      </button>
      <button class="quick-action tooltip" id="zoom-out" data-tooltip="Zoom Out">
        <svg class="icon" viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="10"></circle>
          <line x1="8" y1="12" x2="16" y2="12"></line>
        </svg>
      </button>
      <button class="quick-action tooltip" id="reset-view" data-tooltip="Reset View">
        <svg class="icon" viewBox="0 0 24 24">
          <path d="M23 4v6h-6"></path>
          <path d="M1 20v-6h6"></path>
          <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
        </svg>
      </button>
    </div>

    <!-- Toolbar -->
    <div class="toolbar" id="toolbar">
      <div class="toolbar-inner">
        <div class="toolbar-group">
          <button class="btn btn-icon tooltip" id="add-sun" data-tooltip="Add Central Idea">
            <svg class="icon" viewBox="0 0 24 24">
              <circle cx="12" cy="12" r="5"></circle>
              <line x1="12" y1="1" x2="12" y2="3"></line>
              <line x1="12" y1="21" x2="12" y2="23"></line>
              <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
              <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
              <line x1="1" y1="12" x2="3" y2="12"></line>
              <line x1="21" y1="12" x2="23" y2="12"></line>
              <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
              <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
          </button>
          <button class="btn btn-icon tooltip" id="add-planet" data-tooltip="Add Main Idea">
            <svg class="icon" viewBox="0 0 24 24">
              <circle cx="12" cy="12" r="10"></circle>
              <path d="M8 12a4 4 0 0 1 8 0"></path>
            </svg>
          </button>
          <button class="btn btn-icon tooltip" id="add-moon" data-tooltip="Add Sub-Idea">
            <svg class="icon" viewBox="0 0 24 24">
              <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
          </button>
          <button class="btn btn-icon tooltip" id="add-asteroid" data-tooltip="Add Quick Note">
            <svg class="icon" viewBox="0 0 24 24">
              <circle cx="12" cy="12" r="3"></circle>
              <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
          </button>
          <button class="btn btn-icon tooltip" id="add-blackhole" data-tooltip="Add Completed Task">
            <svg class="icon" viewBox="0 0 24 24">
              <circle cx="12" cy="12" r="10"></circle>
              <circle cx="12" cy="12" r="4"></circle>
            </svg>
          </button>
        </div>
        <div class="toolbar-group">
          <button class="btn btn-icon tooltip" id="connect-mode" data-tooltip="Connect Nodes">
            <svg class="icon" viewBox="0 0 24 24">
              <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              <polyline points="15 3 21 3 21 9"></polyline>
              <line x1="10" y1="14" x2="21" y2="3"></line>
            </svg>
          </button>
          <button class="btn btn-icon tooltip" id="delete-mode" data-tooltip="Delete Mode">
            <svg class="icon" viewBox="0 0 24 24">
              <polyline points="3 6 5 6 21 6"></polyline>
              <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
          </button>
          <button class="btn btn-icon tooltip" id="auto-layout" data-tooltip="Auto Layout">
            <svg class="icon" viewBox="0 0 24 24">
              <rect x="3" y="3" width="7" height="7"></rect>
              <rect x="14" y="3" width="7" height="7"></rect>
              <rect x="14" y="14" width="7" height="7"></rect>
              <rect x="3" y="14" width="7" height="7"></rect>
            </svg>
          </button>
        </div>
        <div class="toolbar-group">
          <button class="btn btn-icon tooltip" id="open-gallery" data-tooltip="My Mindmaps">
            <svg class="icon" viewBox="0 0 24 24">
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
              <circle cx="8.5" cy="8.5" r="1.5"></circle>
              <polyline points="21 15 16 10 5 21"></polyline>
            </svg>
          </button>
          <button class="btn btn-icon tooltip" id="export-options" data-tooltip="Export">
            <svg class="icon" viewBox="0 0 24 24">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="7 10 12 15 17 10"></polyline>
              <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
          </button>
          <button class="btn btn-icon tooltip" id="open-settings" data-tooltip="Settings">
            <svg class="icon" viewBox="0 0 24 24">
              <circle cx="12" cy="12" r="3"></circle>
              <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
          </button>
          <button class="btn btn-icon tooltip" id="help-btn" data-tooltip="Help">
            <svg class="icon" viewBox="0 0 24 24">
              <circle cx="12" cy="12" r="10"></circle>
              <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
              <line x1="12" y1="17" x2="12.01" y2="17"></line>
            </svg>
          </button>
        </div>
        <button class="btn btn-icon tooltip" id="toggle-toolbar" data-tooltip="Toggle Toolbar">
          <svg class="icon" viewBox="0 0 24 24">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>
        </button>
      </div>
    </div>

    <!-- Node Editor -->
    <div class="node-editor panel" id="node-editor">
      <div class="panel-header">
        <h3 class="panel-title">Node Properties</h3>
        <button class="btn btn-icon" id="close-editor">
          <svg class="icon" viewBox="0 0 24 24">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="panel-body">
        <div class="form-group">
          <label class="form-label" for="node-text">Label</label>
          <input type="text" class="form-input" id="node-text" placeholder="Enter node text...">
        </div>
        <div class="form-group">
          <label class="form-label" for="node-description">Description</label>
          <textarea class="form-input" id="node-description" rows="3" placeholder="Enter description..."></textarea>
        </div>
        <div class="form-group">
          <label class="form-label" for="node-type">Type</label>
          <select class="form-select" id="node-type">
            <option value="sun">Central Idea (Sun)</option>
            <option value="planet">Main Idea (Planet)</option>
            <option value="moon">Sub-Idea (Moon)</option>
            <option value="asteroid">Quick Note (Asteroid)</option>
            <option value="blackhole">Completed Task (Black Hole)</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label" for="node-importance">Importance</label>
          <select class="form-select" id="node-importance">
            <option value="normal">Normal</option>
            <option value="high">High</option>
            <option value="critical">Critical</option>
            <option value="low">Low</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label">Color</label>
          <div class="color-options" id="color-options">
            <div class="color-option selected" style="background: #ff9500;" data-color="#ff9500"></div>
            <div class="color-option" style="background: #3a86ff;" data-color="#3a86ff"></div>
            <div class="color-option" style="background: #8b5cf6;" data-color="#8b5cf6"></div>
            <div class="color-option" style="background: #f43f5e;" data-color="#f43f5e"></div>
            <div class="color-option" style="background: #10b981;" data-color="#10b981"></div>
            <div class="color-option" style="background: #f59e0b;" data-color="#f59e0b"></div>
            <div class="color-option" style="background: #64748b;" data-color="#64748b"></div>
            <div class="color-option" style="background: #020617;" data-color="#020617"></div>
          </div>
        </div>
      </div>
      <div class="panel-footer">
        <button class="btn btn-danger" id="delete-node">Delete</button>
        <button class="btn btn-primary" id="save-node">Save</button>
      </div>
    </div>

    <!-- Gallery -->
    <div class="gallery" id="gallery">
      <div class="panel-header">
        <h2 class="panel-title">My Mindmaps</h2>
        <button class="btn btn-icon" id="close-gallery">
          <svg class="icon" viewBox="0 0 24 24">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="gallery-grid" id="gallery-grid">
        <!-- Gallery items will be added dynamically -->
      </div>
    </div>

    <!-- Settings Panel -->
    <div class="side-panel side-panel-right" id="settings-panel">
      <div class="side-panel-header">
        <h2 class="side-panel-title">Settings</h2>
        <button class="btn btn-icon" id="close-settings">
          <svg class="icon" viewBox="0 0 24 24">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="side-panel-body">
        <div class="tabs">
          <div class="tab active" data-tab="visual">Visual</div>
          <div class="tab" data-tab="behavior">Behavior</div>
          <div class="tab" data-tab="advanced">Advanced</div>
        </div>
        
        <div class="tab-content active" id="tab-visual">
          <div class="form-group flex items-center justify-between">
            <label class="form-label mb-0">Show Node Pulsation</label>
            <label class="switch">
              <input type="checkbox" id="setting-node-pulse" checked>
              <span class="slider"></span>
            </label>
          </div>
          <div class="form-group flex items-center justify-between">
            <label class="form-label mb-0">Show Background Stars</label>
            <label class="switch">
              <input type="checkbox" id="setting-show-stars" checked>
              <span class="slider"></span>
            </label>
          </div>
          <div class="form-group flex items-center justify-between">
            <label class="form-label mb-0">Show Background Nebulae</label>
            <label class="switch">
              <input type="checkbox" id="setting-show-nebulae" checked>
              <span class="slider"></span>
            </label>
          </div>
          <div class="form-group flex items-center justify-between">
            <label class="form-label mb-0">Show Tooltips</label>
            <label class="switch">
              <input type="checkbox" id="setting-show-tooltips" checked>
              <span class="slider"></span>
            </label>
          </div>
          <div class="form-group">
            <label class="form-label">Interface Theme</label>
            <select class="form-select" id="setting-theme">
              <option value="dark">Dark (Default)</option>
              <option value="light">Light</option>
              <option value="system">System Preference</option>
            </select>
          </div>
        </div>
        
        <div class="tab-content" id="tab-behavior">
          <div class="form-group flex items-center justify-between">
            <label class="form-label mb-0">Auto-Save (Every 5 min)</label>
            <label class="switch">
              <input type="checkbox" id="setting-auto-save" checked>
              <span class="slider"></span>
            </label>
          </div>
          <div class="form-group flex items-center justify-between">
            <label class="form-label mb-0">Show Mini-map</label>
            <label class="switch">
              <input type="checkbox" id="setting-show-minimap">
              <span class="slider"></span>
            </label>
          </div>
          <div class="form-group flex items-center justify-between">
            <label class="form-label mb-0">Enable Node Gravity</label>
            <label class="switch">
              <input type="checkbox" id="setting-node-gravity" checked>
              <span class="slider"></span>
            </label>
          </div>
          <div class="form-group flex items-center justify-between">
            <label class="form-label mb-0">Collapse UI When Inactive</label>
            <label class="switch">
              <input type="checkbox" id="setting-collapse-ui" checked>
              <span class="slider"></span>
            </label>
          </div>
          <div class="form-group">
            <label class="form-label">Double-Tap Speed (ms)</label>
            <select class="form-select" id="setting-double-tap">
              <option value="200">Fast (200ms)</option>
              <option value="300" selected>Normal (300ms)</option>
              <option value="500">Slow (500ms)</option>
            </select>
          </div>
        </div>
        
        <div class="tab-content" id="tab-advanced">
          <div class="form-group">
            <label class="form-label">Auto-Layout Algorithm</label>
            <select class="form-select" id="setting-layout-algo">
              <option value="radial">Radial (Default)</option>
              <option value="force">Force-Directed</option>
              <option value="hierarchical">Hierarchical</option>
            </select>
          </div>
          <div class="form-group">
            <label class="form-label">Connection Style</label>
            <select class="form-select" id="setting-connection-style">
              <option value="straight">Straight</option>
              <option value="curved" selected>Curved</option>
              <option value="orthogonal">Orthogonal</option>
            </select>
          </div>
          <div class="form-group">
            <button class="btn btn-outline w-full" id="export-settings">Export Settings</button>
          </div>
          <div class="form-group">
            <button class="btn btn-outline w-full" id="import-settings">Import Settings</button>
          </div>
          <div class="form-group">
            <button class="btn btn-danger w-full" id="clear-data">Clear All Local Data</button>
          </div>
        </div>
      </div>
      <div class="side-panel-footer">
        <button class="btn btn-outline" id="reset-settings">Reset to Default</button>
        <button class="btn btn-primary" id="save-settings">Save Settings</button>
      </div>
    </div>

    <!-- Help Panel -->
    <div class="side-panel side-panel-right" id="help-panel">
      <div class="side-panel-header">
        <h2 class="side-panel-title">Help & Tips</h2>
        <button class="btn btn-icon" id="close-help">
          <svg class="icon" viewBox="0 0 24 24">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="side-panel-body">
        <div class="tabs">
          <div class="tab active" data-tab="basics">Basics</div>
          <div class="tab" data-tab="mobile">Mobile</div>
          <div class="tab" data-tab="shortcuts">Shortcuts</div>
          <div class="tab" data-tab="tips">Pro Tips</div>
        </div>
        
        <div class="tab-content active" id="help-basics">
          <div class="mb-4">
            <h3 class="text-primary mb-2">Creating Nodes</h3>
            <p class="text-sm">Select a node type from the toolbar and then tap anywhere on the canvas to create it.</p>
          </div>
          <div class="mb-4">
            <h3 class="text-primary mb-2">Editing Nodes</h3>
            <p class="text-sm">Double-tap on any node to open the editor where you can change its text, description, type, and color.</p>
          </div>
          <div class="mb-4">
            <h3 class="text-primary mb-2">Connecting Nodes</h3>
            <p class="text-sm">Tap the connect button in the toolbar, then tap a source node followed by a target node to create a connection.</p>
          </div>
          <div class="mb-4">
            <h3 class="text-primary mb-2">Navigation</h3>
            <p class="text-sm">Drag the canvas to pan around. Use pinch gestures or the zoom buttons to zoom in and out.</p>
          </div>
        </div>
        
        <div class="tab-content" id="help-mobile">
          <div class="mb-4">
            <h3 class="text-primary mb-2">Mobile Controls</h3>
            <ul class="text-sm">
              <li class="mb-2"> Tap and drag to move nodes or pan the canvas</li>
              <li class="mb-2"> Double-tap a node to edit it</li>
              <li class="mb-2"> Long-press on empty space for context menu</li>
              <li class="mb-2"> Pinch to zoom in and out</li>
              <li class="mb-2"> Swipe on header/toolbar edges to collapse/expand</li>
            </ul>
          </div>
          <div class="mb-4">
            <h3 class="text-primary mb-2">Space Optimization</h3>
            <ul class="text-sm">
              <li class="mb-2"> Header and toolbar auto-collapse when not in use</li>
              <li class="mb-2"> Tap the edge of collapsed UI to expand it</li>
              <li class="mb-2"> Use the mini-map for quick navigation</li>
              <li class="mb-2"> Quick actions panel provides essential tools</li>
            </ul>
          </div>
        </div>
        
        <div class="tab-content" id="help-shortcuts">
          <div class="mb-4">
            <h3 class="text-primary mb-2">Keyboard Shortcuts</h3>
            <div class="flex justify-between mb-2">
              <span class="text-sm">Create Sun</span>
              <span class="kbd">S</span>
            </div>
            <div class="flex justify-between mb-2">
              <span class="text-sm">Create Planet</span>
              <span class="kbd">P</span>
            </div>
            <div class="flex justify-between mb-2">
              <span class="text-sm">Create Moon</span>
              <span class="kbd">M</span>
            </div>
            <div class="flex justify-between mb-2">
              <span class="text-sm">Delete Selected</span>
              <span class="kbd">Del</span>
            </div>
            <div class="flex justify-between mb-2">
              <span class="text-sm">Save</span>
              <div class="flex gap-2">
                <span class="kbd">Ctrl</span>
                <span class="kbd">S</span>
              </div>
            </div>
            <div class="flex justify-between mb-2">
              <span class="text-sm">Zoom In</span>
              <span class="kbd">+</span>
            </div>
            <div class="flex justify-between mb-2">
              <span class="text-sm">Zoom Out</span>
              <span class="kbd">-</span>
            </div>
            <div class="flex justify-between mb-2">
              <span class="text-sm">Reset View</span>
              <span class="kbd">0</span>
            </div>
            <div class="flex justify-between mb-2">
              <span class="text-sm">Search</span>
              <span class="kbd">F</span>
            </div>
          </div>
        </div>
        
        <div class="tab-content" id="help-tips">
          <div class="mb-4">
            <h3 class="text-primary mb-2">Organization Tips</h3>
            <ul class="text-sm">
              <li class="mb-2"> Use Suns for main topics, Planets for key points, and Moons for details</li>
              <li class="mb-2"> Color-code related ideas for better visual organization</li>
              <li class="mb-2"> Use the Black Hole node type for completed tasks</li>
              <li class="mb-2"> Create Asteroids for quick notes that don't fit into your main structure</li>
            </ul>
          </div>
          <div class="mb-4">
            <h3 class="text-primary mb-2">Advanced Features</h3>
            <ul class="text-sm">
              <li class="mb-2"> Long-press on empty space to open the context menu</li>
              <li class="mb-2"> Use the search function to quickly find nodes</li>
              <li class="mb-2"> Export your mindmap as JSON to share with others</li>
              <li class="mb-2"> Enable node gravity in settings to automatically organize your mindmap</li>
              <li class="mb-2"> Use auto-layout to arrange your nodes in a clean structure</li>
            </ul>
          </div>
        </div>
      </div>
      <div class="side-panel-footer">
        <button class="btn btn-primary w-full" id="help-close-btn">Got it</button>
      </div>
    </div>

    <!-- Export Panel -->
    <div class="side-panel side-panel-right" id="export-panel">
      <div class="side-panel-header">
        <h2 class="side-panel-title">Export Options</h2>
        <button class="btn btn-icon" id="close-export">
          <svg class="icon" viewBox="0 0 24 24">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="side-panel-body">
        <div class="form-group">
          <button class="btn btn-outline w-full flex items-center justify-between" id="export-image">
            <span>Export as PNG</span>
            <svg class="icon icon-sm" viewBox="0 0 24 24">
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
              <circle cx="8.5" cy="8.5" r="1.5"></circle>
              <polyline points="21 15 16 10 5 21"></polyline>
            </svg>
          </button>
        </div>
        <div class="form-group">
          <button class="btn btn-outline w-full flex items-center justify-between" id="export-svg">
            <span>Export as SVG</span>
            <svg class="icon icon-sm" viewBox="0 0 24 24">
              <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
              <path d="M2 17l10 5 10-5"></path>
              <path d="M2 12l10 5 10-5"></path>
            </svg>
          </button>
        </div>
        <div class="form-group">
          <button class="btn btn-outline w-full flex items-center justify-between" id="export-json">
            <span>Export as JSON</span>
            <svg class="icon icon-sm" viewBox="0 0 24 24">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
              <polyline points="14 2 14 8 20 8"></polyline>
              <line x1="16" y1="13" x2="8" y2="13"></line>
              <line x1="16" y1="17" x2="8" y2="17"></line>
              <polyline points="10 9 9 9 8 9"></polyline>
            </svg>
          </button>
        </div>
        <div class="form-group">
          <button class="btn btn-outline w-full flex items-center justify-between" id="export-pdf">
            <span>Export as PDF</span>
            <svg class="icon icon-sm" viewBox="0 0 24 24">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
              <polyline points="14 2 14 8 20 8"></polyline>
              <line x1="16" y1="13" x2="8" y2="13"></line>
              <line x1="16" y1="17" x2="8" y2="17"></line>
              <polyline points="10 9 9 9 8 9"></polyline>
            </svg>
          </button>
        </div>
        <div class="form-group">
          <label class="form-label">Import from File</label>
          <div class="flex gap-2">
            <input type="file" id="import-file" accept=".json" class="hidden">
            <button class="btn btn-outline flex-1" id="import-json">Choose File</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="context-menu">
      <!-- Context menu items will be added dynamically -->
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toast-container"></div>
  </div>

  <script>
    // Main application class
    class CosmicMindmap {
      constructor() {
        this.canvas = document.getElementById('mindmap-canvas');
        this.nodes = [];
        this.connections = [];
        this.selectedNode = null;
        this.draggedNode = null;
        this.scale = 1;
        this.offset = { x: 0, y: 0 };
        this.isDragging = false;
        this.dragStart = { x: 0, y: 0 };
        this.mode = 'default'; // default, connect, delete, add-sun, add-planet, etc.
        this.connectSource = null;
        this.currentMindmapId = this.generateId();
        this.mindmapTitle = 'My Cosmic Universe';
        this.lastTap = 0; // For double tap detection
        this.longPressTimer = null; // For long press detection
        this.touchStartPos = { x: 0, y: 0 }; // For touch movement detection
        this.settings = this.loadSettings();
        this.autoSaveInterval = null;
        this.searchActive = false;
        this.minimapActive = this.settings.showMinimap;
        this.modeIndicatorTimeout = null;
        this.headerCollapsed = false;
        this.toolbarCollapsed = false;
        this.pinchStartDistance = null;
        this.pinchStartScale = null;
        this.inactivityTimer = null;
        this.isUICollapsed = false;
        this.activePanel = null;
        
        this.initializeBackground();
        this.initializeEventListeners();
        this.setupHeader();
        this.setupToolbar();
        this.setupQuickActions();
        this.setupNodeEditor();
        this.setupGallery();
        this.setupSettings();
        this.setupHelp();
        this.setupExport();
        this.setupSearch();
        this.setupMiniMap();
        this.setupContextMenu();
        this.setupWelcomeModal();
        this.setupInactivityDetection();
        
        // Center the view
        this.centerView();
        
        // Setup auto-save if enabled
        if (this.settings.autoSave) {
          this.startAutoSave();
        }
        
        // Apply tooltips setting
        this.applyTooltipsSetting();
      }
      
      // Load settings from local storage
      loadSettings() {
        const defaultSettings = {
          nodePulse: true,
          showStars: true,
          showNebulae: true,
          autoSave: true,
          showMinimap: false,
          nodeGravity: true,
          showTooltips: true,
          collapseUI: true,
          theme: 'dark',
          doubleTapSpeed: 300,
          layoutAlgorithm: 'radial',
          connectionStyle: 'curved'
        };
        
        const savedSettings = JSON.parse(localStorage.getItem('cosmic_mindmap_settings'));
        return savedSettings ? { ...defaultSettings, ...savedSettings } : defaultSettings;
      }
      
      // Save settings to local storage
      saveSettings() {
        localStorage.setItem('cosmic_mindmap_settings', JSON.stringify(this.settings));
        this.applySettings();
        this.showToast('Settings saved', 'success');
      }
      
      // Apply current settings
      applySettings() {
        // Apply node pulse setting
        const nodes = document.querySelectorAll('.node');
        if (this.settings.nodePulse) {
          nodes.forEach(node => {
            node.style.animation = '';
          });
        } else {
          nodes.forEach(node => {
            node.style.animation = 'none';
          });
        }
        
        // Apply stars visibility
        const stars = document.querySelectorAll('.star');
        stars.forEach(star => {
          star.style.display = this.settings.showStars ? 'block' : 'none';
        });
        
        // Apply nebulae visibility
        const nebulae = document.querySelectorAll('.nebula');
        nebulae.forEach(nebula => {
          nebula.style.display = this.settings.showNebulae ? 'block' : 'none';
        });
        
        // Apply auto-save setting
        if (this.settings.autoSave) {
          this.startAutoSave();
        } else {
          this.stopAutoSave();
        }
        
        // Apply mini-map setting
        this.minimapActive = this.settings.showMinimap;
        document.getElementById('mini-map').classList.toggle('active', this.minimapActive);
        if (this.minimapActive) {
          this.updateMiniMap();
        }
        
        // Apply tooltips setting
        this.applyTooltipsSetting();
        
        // Apply theme setting
        this.applyTheme();
      }
      
      // Apply theme
      applyTheme() {
        // This is a placeholder for theme implementation
        // In a real implementation, you would change CSS variables or add/remove classes
      }
      
      // Apply tooltips setting
      applyTooltipsSetting() {
        const tooltips = document.querySelectorAll('.tooltip');
        tooltips.forEach(tooltip => {
          if (this.settings.showTooltips) {
            tooltip.classList.add('tooltip');
          } else {
            tooltip.classList.remove('tooltip');
          }
        });
      }
      
      // Start auto-save interval
      startAutoSave() {
        if (this.autoSaveInterval) {
          clearInterval(this.autoSaveInterval);
        }
        this.autoSaveInterval = setInterval(() => {
          this.saveMindmap();
          this.showToast('Auto-saved', 'success');
        }, 5 * 60 * 1000); // 5 minutes
      }
      
      // Stop auto-save interval
      stopAutoSave() {
        if (this.autoSaveInterval) {
          clearInterval(this.autoSaveInterval);
          this.autoSaveInterval = null;
        }
      }
      
      // Setup inactivity detection
      setupInactivityDetection() {
        if (!this.settings.collapseUI) return;
        
        const resetInactivityTimer = () => {
          if (this.inactivityTimer) {
            clearTimeout(this.inactivityTimer);
          }
          
          if (this.isUICollapsed) {
            this.expandUI();
          }
          
          this.inactivityTimer = setTimeout(() => {
            if (!this.activePanel) {
              this.collapseUI();
            }
          }, 5000); // Collapse after 5 seconds of inactivity
        };
        
        // Reset timer on user interaction
        ['mousemove', 'mousedown', 'keydown', 'touchstart', 'wheel'].forEach(event => {
          document.addEventListener(event, resetInactivityTimer);
        });
        
        // Initial setup
        resetInactivityTimer();
      }
      
      // Collapse UI elements
      collapseUI() {
        if (this.activePanel) return;
        
        const header = document.getElementById('header');
        const toolbar = document.getElementById('toolbar');
        
        header.classList.add('collapsed');
        toolbar.classList.add('collapsed');
        this.isUICollapsed = true;
      }
      
      // Expand UI elements
      expandUI() {
        const header = document.getElementById('header');
        const toolbar = document.getElementById('toolbar');
        
        header.classList.remove('collapsed');
        toolbar.classList.remove('collapsed');
        this.isUICollapsed = false;
      }
      
      // Initialize cosmic background with stars and nebulae
      initializeBackground() {
        const background = document.getElementById('cosmic-background');
        
        // Create stars
        for (let i = 0; i < 200; i++) {
          const star = document.createElement('div');
          star.className = 'star';
          star.style.width = `${Math.random() * 2 + 1}px`;
          star.style.height = star.style.width;
          star.style.left = `${Math.random() * 100}%`;
          star.style.top = `${Math.random() * 100}%`;
          star.style.animationDelay = `${Math.random() * 4}s`;
          star.style.display = this.settings.showStars ? 'block' : 'none';
          background.appendChild(star);
        }
        
        // Create nebulae
        for (let i = 0; i < 5; i++) {
          const nebula = document.createElement('div');
          nebula.className = 'nebula';
          nebula.style.width = `${Math.random() * 300 + 200}px`;
          nebula.style.height = nebula.style.width;
          nebula.style.left = `${Math.random() * 100}%`;
          nebula.style.top = `${Math.random() * 100}%`;
          nebula.style.background = this.getRandomNebulaGradient();
          nebula.style.animationDelay = `${Math.random() * 5}s`;
          nebula.style.display = this.settings.showNebulae ? 'block' : 'none';
          background.appendChild(nebula);
        }
      }
      
      // Get random nebula gradient
      getRandomNebulaGradient() {
        const colors = [
          'rgba(58, 134, 255, 0.15)',
          'rgba(139, 92, 246, 0.15)',
          'rgba(244, 63, 94, 0.15)',
          'rgba(16, 185, 129, 0.15)'
        ];
        const color1 = colors[Math.floor(Math.random() * colors.length)];
        const color2 = 'transparent';
        return `radial-gradient(circle, ${color1} 0%, ${color2} 70%)`;
      }
      
      // Initialize event listeners
      initializeEventListeners() {
        // Canvas mouse event listeners
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.canvas.addEventListener('wheel', this.handleWheel.bind(this));
        
        // Canvas touch event listeners
        this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
        this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
        this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
        
        // Title input
        document.getElementById('mindmap-title').addEventListener('change', (e) => {
          this.mindmapTitle = e.target.value;
        });
        
        // Window resize
        window.addEventListener('resize', this.handleResize.bind(this));
        
        // Keyboard shortcuts
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        
        // Context menu
        document.addEventListener('click', (e) => {
          const contextMenu = document.getElementById('context-menu');
          if (!contextMenu.contains(e.target)) {
            contextMenu.classList.remove('active');
          }
        });
        
        // Import file handler
        document.getElementById('import-file').addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
              try {
                const data = JSON.parse(event.target.result);
                if (data.nodes && data.connections) {
                  this.importMindmap(data);
                } else {
                  this.showToast('Invalid mindmap file format', 'error');
                }
              } catch (error) {
                this.showToast('Error parsing file', 'error');
              }
            };
            reader.readAsText(file);
          }
        });
        
        // Home button
        document.getElementById('home-btn').addEventListener('click', () => {
          window.location.href = 'index.html';
        });
      }
      
      // Setup header
      setupHeader() {
        // Toggle header collapse
        document.getElementById('toggle-header').addEventListener('click', () => {
          const header = document.getElementById('header');
          header.classList.toggle('collapsed');
          this.headerCollapsed = header.classList.contains('collapsed');
          
          // Update icon
          const icon = document.getElementById('toggle-header').querySelector('svg');
          if (this.headerCollapsed) {
            icon.innerHTML = '<polyline points="6 9 12 15 18 9"></polyline>';
          } else {
            icon.innerHTML = '<polyline points="18 15 12 9 6 15"></polyline>';
          }
        });
        
        // Menu button
        document.getElementById('menu-btn').addEventListener('click', () => {
          this.togglePanel('export-panel', false);
          this.togglePanel('help-panel', false);
          this.togglePanel('settings-panel', false);
          
          const exportPanel = document.getElementById('export-panel');
          const helpPanel = document.getElementById('help-panel');
          const settingsPanel = document.getElementById('settings-panel');
          
          if (!exportPanel.classList.contains('active') && 
              !helpPanel.classList.contains('active') && 
              !settingsPanel.classList.contains('active')) {
            this.togglePanel('settings-panel', true);
          }
        });
      }
      
      // Setup toolbar
      setupToolbar() {
        // Node creation buttons
        document.getElementById('add-sun').addEventListener('click', () => {
          this.setMode('add-sun');
        });
        
        document.getElementById('add-planet').addEventListener('click', () => {
          this.setMode('add-planet');
        });
        
        document.getElementById('add-moon').addEventListener('click', () => {
          this.setMode('add-moon');
        });
        
        document.getElementById('add-asteroid').addEventListener('click', () => {
          this.setMode('add-asteroid');
        });
        
        document.getElementById('add-blackhole').addEventListener('click', () => {
          this.setMode('add-blackhole');
        });
        
        // Tool buttons
        document.getElementById('connect-mode').addEventListener('click', () => {
          this.setMode(this.mode === 'connect' ? 'default' : 'connect');
        });
        
        document.getElementById('delete-mode').addEventListener('click', () => {
          this.setMode(this.mode === 'delete' ? 'default' : 'delete');
        });
        
        document.getElementById('auto-layout').addEventListener('click', () => {
          this.autoLayout();
        });
        
        // Gallery and settings
        document.getElementById('open-gallery').addEventListener('click', () => {
          this.openGallery();
        });
        
        document.getElementById('export-options').addEventListener('click', () => {
          this.togglePanel('export-panel');
        });
        
        document.getElementById('open-settings').addEventListener('click', () => {
          this.togglePanel('settings-panel');
        });
        
        document.getElementById('help-btn').addEventListener('click', () => {
          this.togglePanel('help-panel');
        });
        
        // Toggle toolbar collapse
        document.getElementById('toggle-toolbar').addEventListener('click', () => {
          const toolbar = document.getElementById('toolbar');
          toolbar.classList.toggle('collapsed');
          this.toolbarCollapsed = toolbar.classList.contains('collapsed');
          
          // Update icon
          const icon = document.getElementById('toggle-toolbar').querySelector('svg');
          if (this.toolbarCollapsed) {
            icon.innerHTML = '<polyline points="6 15 12 9 18 15"></polyline>';
          } else {
            icon.innerHTML = '<polyline points="6 9 12 15 18 9"></polyline>';
          }
        });
      }
      
      // Setup quick actions
      setupQuickActions() {
        document.getElementById('search-btn').addEventListener('click', () => {
          this.toggleSearch();
        });
        
        document.getElementById('toggle-minimap').addEventListener('click', () => {
          this.toggleMiniMap();
        });
        
        document.getElementById('quick-save').addEventListener('click', () => {
          this.saveMindmap();
        });
        
        document.getElementById('zoom-in').addEventListener('click', () => {
          this.zoom(1.2);
        });
        
        document.getElementById('zoom-out').addEventListener('click', () => {
          this.zoom(0.8);
        });
        
        document.getElementById('reset-view').addEventListener('click', () => {
          this.resetView();
        });
      }
      
      // Toggle panel visibility
      togglePanel(panelId, forceState = null) {
        const panel = document.getElementById(panelId);
        const isActive = forceState !== null ? forceState : !panel.classList.contains('active');
        
        // Close all panels first
        document.querySelectorAll('.side-panel').forEach(p => {
          p.classList.remove('active');
        });
        
        // Set active panel or clear if closing
        this.activePanel = isActive ? panelId : null;
        
        // Toggle the requested panel
        if (isActive) {
          panel.classList.add('active');
          
          // Expand UI if collapsed
          if (this.isUICollapsed) {
            this.expandUI();
          }
        }
      }
      
      // Handle keyboard shortcuts
      handleKeyDown(e) {
        // Skip if inside input or textarea
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
          return;
        }
        
        switch (e.key) {
          case 's':
            if (e.ctrlKey || e.metaKey) {
              e.preventDefault();
              this.saveMindmap();
            } else if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
              this.setMode('add-sun');
            }
            break;
            
          case 'p':
            if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
              this.setMode('add-planet');
            }
            break;
            
          case 'm':
            if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
              this.setMode('add-moon');
            }
            break;
            
          case 'a':
            if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
              this.setMode('add-asteroid');
            }
            break;
            
          case 'c':
            if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
              this.setMode(this.mode === 'connect' ? 'default' : 'connect');
            }
            break;
            
          case 'Delete':
            if (this.selectedNode) {
              this.deleteNode(this.selectedNode.id);
              document.getElementById('node-editor').classList.remove('active');
              this.showToast('Node deleted');
            }
            break;
            
          case 'Escape':
            this.setMode('default');
            document.getElementById('node-editor').classList.remove('active');
            document.getElementById('search-container').classList.remove('active');
            document.getElementById('context-menu').classList.remove('active');
            this.togglePanel('export-panel', false);
            this.togglePanel('help-panel', false);
            this.togglePanel('settings-panel', false);
            break;
            
          case '+':
          case '=':
            this.zoom(1.2);
            break;
            
          case '-':
            this.zoom(0.8);
            break;
            
          case '0':
            this.resetView();
            break;
            
          case 'f':
            if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
              this.toggleSearch();
            }
            break;
        }
      }
      
      // Set mode and update UI
      setMode(mode) {
        this.mode = mode;
        this.updateToolbarState();
        this.showModeIndicator();
      }
      
      // Show mode indicator
      showModeIndicator() {
        const modeIndicator = document.getElementById('mode-indicator');
        let modeText = 'Mode: ';
        
        switch (this.mode) {
          case 'default':
            modeText += 'Default';
            break;
          case 'add-sun':
            modeText += 'Add Central Idea';
            break;
          case 'add-planet':
            modeText += 'Add Main Idea';
            break;
          case 'add-moon':
            modeText += 'Add Sub-Idea';
            break;
          case 'add-asteroid':
            modeText += 'Add Quick Note';
            break;
          case 'add-blackhole':
            modeText += 'Add Completed Task';
            break;
          case 'connect':
            modeText += 'Connect Nodes';
            break;
          case 'delete':
            modeText += 'Delete';
            break;
          default:
            modeText += this.mode.charAt(0).toUpperCase() + this.mode.slice(1);
        }
        
        modeIndicator.textContent = modeText;
        modeIndicator.classList.add('active');
        
        // Clear previous timeout
        if (this.modeIndicatorTimeout) {
          clearTimeout(this.modeIndicatorTimeout);
        }
        
        // Hide after 2 seconds
        this.modeIndicatorTimeout = setTimeout(() => {
          modeIndicator.classList.remove('active');
        }, 2000);
      }
      
      // Update toolbar state based on current mode
      updateToolbarState() {
        const buttons = document.querySelectorAll('.toolbar-inner .btn-icon');
        buttons.forEach(btn => btn.classList.remove('active'));
        
        switch (this.mode) {
          case 'add-sun':
            document.getElementById('add-sun').classList.add('active');
            break;
          case 'add-planet':
            document.getElementById('add-planet').classList.add('active');
            break;
          case 'add-moon':
            document.getElementById('add-moon').classList.add('active');
            break;
          case 'add-asteroid':
            document.getElementById('add-asteroid').classList.add('active');
            break;
          case 'add-blackhole':
            document.getElementById('add-blackhole').classList.add('active');
            break;
          case 'connect':
            document.getElementById('connect-mode').classList.add('active');
            break;
          case 'delete':
            document.getElementById('delete-mode').classList.add('active');
            break;
        }
      }
      
      // Handle mouse down event
      handleMouseDown(e) {
        if (e.button !== 0) return; // Only left mouse button
        
        const rect = this.canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / this.scale - this.offset.x;
        const y = (e.clientY - rect.top) / this.scale - this.offset.y;
        
        // Check if clicking on a node
        const clickedNode = this.findNodeAt(x, y);
        
        if (clickedNode) {
          // Handle node click based on current mode
          switch (this.mode) {
            case 'default':
              this.selectNode(clickedNode);
              this.draggedNode = clickedNode;
              break;
              
            case 'connect':
              if (!this.connectSource) {
                this.connectSource = clickedNode;
                this.showToast('Select target node to connect');
              } else {
                this.createConnection(this.connectSource.id, clickedNode.id);
                this.connectSource = null;
                this.showToast('Connection created', 'success');
              }
              break;
              
            case 'delete':
              this.deleteNode(clickedNode.id);
              this.showToast('Node deleted');
              break;
              
            default:
              this.selectNode(clickedNode);
              this.draggedNode = clickedNode;
          }
        } else {
          // Handle canvas click based on current mode
          switch (this.mode) {
            case 'add-sun':
              this.createNode({
                x, y,
                text: 'Central Idea',
                type: 'sun',
                color: '#ff9500',
                importance: 'normal'
              });
              this.setMode('default');
              break;
              
            case 'add-planet':
              this.createNode({
                x, y,
                text: 'Main Idea',
                type: 'planet',
                color: '#3a86ff',
                importance: 'normal'
              });
              this.setMode('default');
              break;
              
            case 'add-moon':
              this.createNode({
                x, y,
                text: 'Sub Idea',
                type: 'moon',
                color: '#94a3b8',
                importance: 'normal'
              });
              this.setMode('default');
              break;
              
            case 'add-asteroid':
              this.createNode({
                x, y,
                text: 'Quick Note',
                type: 'asteroid',
                color: '#cbd5e1',
                importance: 'low'
              });
              this.setMode('default');
              break;
              
            case 'add-blackhole':
              this.createNode({
                x, y,
                text: 'Completed Task',
                type: 'blackhole',
                color: '#020617',
                importance: 'normal'
              });
              this.setMode('default');
              break;
              
            case 'connect':
              this.connectSource = null;
              break;
              
            default:
              // Start canvas dragging
              this.isDragging = true;
              this.dragStart = { x: e.clientX, y: e.clientY };
              this.deselectNode();
              
              // Show context menu on right click
              if (e.button === 2) {
                this.showContextMenu(e.clientX, e.clientY, 'canvas');
              }
          }
        }
      }
      
      // Handle touch start event
      handleTouchStart(e) {
        e.preventDefault(); // Prevent default to avoid scrolling
        
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          const rect = this.canvas.getBoundingClientRect();
          const x = (touch.clientX - rect.left) / this.scale - this.offset.x;
          const y = (touch.clientY - rect.top) / this.scale - this.offset.y;
          
          this.touchStartPos = { x: touch.clientX, y: touch.clientY };
          
          // Check if touching a node
          const touchedNode = this.findNodeAt(x, y);
          
          if (touchedNode) {
            // Handle node touch based on current mode
            switch (this.mode) {
              case 'default':
                this.selectNode(touchedNode);
                this.draggedNode = touchedNode;
                
                // Setup for double tap detection
                const now = Date.now();
                const doubleTapSpeed = parseInt(this.settings.doubleTapSpeed) || 300;
                if (now - this.lastTap < doubleTapSpeed) {
                  // Double tap detected
                  this.openNodeEditor(touchedNode);
                }
                this.lastTap = now;
                
                // Setup long press detection
                this.longPressTimer = setTimeout(() => {
                  this.showContextMenu(touch.clientX, touch.clientY, 'node', touchedNode);
                }, 800);
                break;
                
              case 'connect':
                if (!this.connectSource) {
                  this.connectSource = touchedNode;
                  this.showToast('Select target node to connect');
                } else {
                  this.createConnection(this.connectSource.id, touchedNode.id);
                  this.connectSource = null;
                  this.showToast('Connection created', 'success');
                }
                break;
                
              case 'delete':
                this.deleteNode(touchedNode.id);
                this.showToast('Node deleted');
                break;
                
              default:
                this.selectNode(touchedNode);
                this.draggedNode = touchedNode;
            }
          } else {
            // Handle canvas touch based on current mode
            switch (this.mode) {
              case 'add-sun':
                this.createNode({
                  x, y,
                  text: 'Central Idea',
                  type: 'sun',
                  color: '#ff9500',
                  importance: 'normal'
                });
                this.setMode('default');
                break;
                
              case 'add-planet':
                this.createNode({
                  x, y,
                  text: 'Main Idea',
                  type: 'planet',
                  color: '#3a86ff',
                  importance: 'normal'
                });
                this.setMode('default');
                break;
                
              case 'add-moon':
                this.createNode({
                  x, y,
                  text: 'Sub Idea',
                  type: 'moon',
                  color: '#94a3b8',
                  importance: 'normal'
                });
                this.setMode('default');
                break;
                
              case 'add-asteroid':
                this.createNode({
                  x, y,
                  text: 'Quick Note',
                  type: 'asteroid',
                  color: '#cbd5e1',
                  importance: 'low'
                });
                this.setMode('default');
                break;
                
              case 'add-blackhole':
                this.createNode({
                  x, y,
                  text: 'Completed Task',
                  type: 'blackhole',
                  color: '#020617',
                  importance: 'normal'
                });
                this.setMode('default');
                break;
                
              case 'connect':
                this.connectSource = null;
                break;
                
              default:
                // Start canvas dragging
                this.isDragging = true;
                this.dragStart = { x: touch.clientX, y: touch.clientY };
                this.deselectNode();
                
                // Setup long press detection for context menu
                this.longPressTimer = setTimeout(() => {
                  this.showContextMenu(touch.clientX, touch.clientY, 'canvas');
                }, 800);
            }
          }
        } else if (e.touches.length === 2) {
          // Handle pinch zoom
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          this.pinchStartDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );
          this.pinchStartScale = this.scale;
        }
      }
      
      // Handle touch move event
      handleTouchMove(e) {
        e.preventDefault(); // Prevent default to avoid scrolling
        
        // Clear long press timer if movement detected
        if (this.longPressTimer) {
          clearTimeout(this.longPressTimer);
          this.longPressTimer = null;
        }
        
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          const rect = this.canvas.getBoundingClientRect();
          const x = (touch.clientX - rect.left) / this.scale - this.offset.x;
          const y = (touch.clientY - rect.top) / this.scale - this.offset.y;
          
          // Check if movement is significant enough to be considered a drag
          const dx = touch.clientX - this.touchStartPos.x;
          const dy = touch.clientY - this.touchStartPos.y;
          const moveDistance = Math.sqrt(dx * dx + dy * dy);
          
          if (moveDistance > 5) { // Threshold to consider it a drag
            // Drag node
            if (this.draggedNode) {
              this.draggedNode.x = x;
              this.draggedNode.y = y;
              this.renderMindmap();
            }
            
            // Drag canvas
            else if (this.isDragging) {
              const dx = touch.clientX - this.dragStart.x;
              const dy = touch.clientY - this.dragStart.y;
              
              this.offset.x += dx / this.scale;
              this.offset.y += dy / this.scale;
              
              this.dragStart = { x: touch.clientX, y: touch.clientY };
              this.renderMindmap();
            }
          }
        } else if (e.touches.length === 2) {
          // Handle pinch zoom
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );
          
          if (this.pinchStartDistance && this.pinchStartDistance > 0) {
            const pinchRatio = currentDistance / this.pinchStartDistance;
            const newScale = this.pinchStartScale * pinchRatio;
            
            // Calculate center of pinch
            const centerX = (touch1.clientX + touch2.clientX) / 2;
            const centerY = (touch1.clientY + touch2.clientY) / 2;
            
            const rect = this.canvas.getBoundingClientRect();
            const worldX = (centerX - rect.left) / this.scale - this.offset.x;
            const worldY = (centerY - rect.top) / this.scale - this.offset.y;
            
            this.scale = Math.max(0.2, Math.min(3, newScale));
            
            // Adjust offset to zoom toward pinch center
            this.offset.x = (centerX - rect.left) / this.scale - worldX;
            this.offset.y = (centerY - rect.top) / this.scale - worldY;
            
            this.renderMindmap();
          }
        }
      }
      
      // Handle touch end event
      handleTouchEnd(e) {
        // Clear long press timer
        if (this.longPressTimer) {
          clearTimeout(this.longPressTimer);
          this.longPressTimer = null;
        }
        
        this.draggedNode = null;
        this.isDragging = false;
        this.pinchStartDistance = null;
      }
      
      // Handle mouse move event
      handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / this.scale - this.offset.x;
        const y = (e.clientY - rect.top) / this.scale - this.offset.y;
        
        // Drag node
        if (this.draggedNode) {
          this.draggedNode.x = x;
          this.draggedNode.y = y;
          this.renderMindmap();
        }
        
        // Drag canvas
        else if (this.isDragging) {
          const dx = e.clientX - this.dragStart.x;
          const dy = e.clientY - this.dragStart.y;
          
          this.offset.x += dx / this.scale;
          this.offset.y += dy / this.scale;
          
          this.dragStart = { x: e.clientX, y: e.clientY };
          this.renderMindmap();
        }
      }
      
      // Handle mouse up event
      handleMouseUp() {
        this.draggedNode = null;
        this.isDragging = false;
      }
      
      // Handle mouse wheel event for zooming
      handleWheel(e) {
        e.preventDefault();
        
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Convert mouse position to world space before scaling
        const worldX = mouseX / this.scale - this.offset.x;
        const worldY = mouseY / this.scale - this.offset.y;
        
        // Zoom factor
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        this.scale *= zoomFactor;
        
        // Limit zoom level
        this.scale = Math.max(0.2, Math.min(3, this.scale));
        
        // Adjust offset to zoom toward mouse position
        this.offset.x = mouseX / this.scale - worldX;
        this.offset.y = mouseY / this.scale - worldY;
        
        this.renderMindmap();
      }
      
      // Handle window resize
      handleResize() {
        this.renderMindmap();
        if (this.minimapActive) {
          this.updateMiniMap();
        }
      }
      
      // Setup node editor
      setupNodeEditor() {
        const editor = document.getElementById('node-editor');
        const closeBtn = document.getElementById('close-editor');
        const saveBtn = document.getElementById('save-node');
        const deleteBtn = document.getElementById('delete-node');
        const colorOptions = document.querySelectorAll('.color-option');
        
        closeBtn.addEventListener('click', () => {
          editor.classList.remove('active');
        });
        
        saveBtn.addEventListener('click', () => {
          if (this.selectedNode) {
            const nodeText = document.getElementById('node-text').value;
            const nodeDescription = document.getElementById('node-description').value;
            const nodeType = document.getElementById('node-type').value;
            const nodeImportance = document.getElementById('node-importance').value;
            const selectedColor = document.querySelector('.color-option.selected').getAttribute('data-color');
            
            this.updateNode(this.selectedNode.id, {
              text: nodeText,
              description: nodeDescription,
              type: nodeType,
              importance: nodeImportance,
              color: selectedColor
            });
            
            editor.classList.remove('active');
            this.showToast('Node updated', 'success');
          }
        });
        
        deleteBtn.addEventListener('click', () => {
          if (this.selectedNode) {
            this.deleteNode(this.selectedNode.id);
            editor.classList.remove('active');
            this.showToast('Node deleted');
          }
        });
        
        colorOptions.forEach(option => {
          option.addEventListener('click', () => {
            colorOptions.forEach(opt => opt.classList.remove('selected'));
            option.classList.add('selected');
          });
        });
      }
      
      // Open node editor for a specific node
      openNodeEditor(node) {
        const editor = document.getElementById('node-editor');
        document.getElementById('node-text').value = node.text;
        document.getElementById('node-description').value = node.description || '';
        document.getElementById('node-type').value = node.type;
        document.getElementById('node-importance').value = node.importance || 'normal';
        
        // Select the right color
        const colorOptions = document.querySelectorAll('.color-option');
        colorOptions.forEach(option => {
          option.classList.remove('selected');
          if (option.getAttribute('data-color') === node.color) {
            option.classList.add('selected');
          }
        });
        
        editor.classList.add('active');
      }
      
      // Setup gallery
      setupGallery() {
        document.getElementById('close-gallery').addEventListener('click', () => {
          document.getElementById('gallery').classList.remove('active');
        });
      }
      
      // Setup settings
      setupSettings() {
        // Initialize settings form
        document.getElementById('setting-node-pulse').checked = this.settings.nodePulse;
        document.getElementById('setting-show-stars').checked = this.settings.showStars;
        document.getElementById('setting-show-nebulae').checked = this.settings.showNebulae;
        document.getElementById('setting-auto-save').checked = this.settings.autoSave;
        document.getElementById('setting-show-minimap').checked = this.settings.showMinimap;
        document.getElementById('setting-node-gravity').checked = this.settings.nodeGravity;
        document.getElementById('setting-show-tooltips').checked = this.settings.showTooltips;
        document.getElementById('setting-collapse-ui').checked = this.settings.collapseUI;
        document.getElementById('setting-theme').value = this.settings.theme;
        document.getElementById('setting-double-tap').value = this.settings.doubleTapSpeed || '300';
        document.getElementById('setting-layout-algo').value = this.settings.layoutAlgorithm || 'radial';
        document.getElementById('setting-connection-style').value = this.settings.connectionStyle || 'curved';
        
        // Close button
        document.getElementById('close-settings').addEventListener('click', () => {
          this.togglePanel('settings-panel', false);
        });
        
        // Save button
        document.getElementById('save-settings').addEventListener('click', () => {
          this.settings.nodePulse = document.getElementById('setting-node-pulse').checked;
          this.settings.showStars = document.getElementById('setting-show-stars').checked;
          this.settings.showNebulae = document.getElementById('setting-show-nebulae').checked;
          this.settings.autoSave = document.getElementById('setting-auto-save').checked;
          this.settings.showMinimap = document.getElementById('setting-show-minimap').checked;
          this.settings.nodeGravity = document.getElementById('setting-node-gravity').checked;
          this.settings.showTooltips = document.getElementById('setting-show-tooltips').checked;
          this.settings.collapseUI = document.getElementById('setting-collapse-ui').checked;
          this.settings.theme = document.getElementById('setting-theme').value;
          this.settings.doubleTapSpeed = document.getElementById('setting-double-tap').value;
          this.settings.layoutAlgorithm = document.getElementById('setting-layout-algo').value;
          this.settings.connectionStyle = document.getElementById('setting-connection-style').value;
          
          this.saveSettings();
          this.togglePanel('settings-panel', false);
        });
        
        // Reset button
        document.getElementById('reset-settings').addEventListener('click', () => {
          if (confirm('Reset all settings to default?')) {
            this.settings = {
              nodePulse: true,
              showStars: true,
              showNebulae: true,
              autoSave: true,
              showMinimap: false,
              nodeGravity: true,
              showTooltips: true,
              collapseUI: true,
              theme: 'dark',
              doubleTapSpeed: '300',
              layoutAlgorithm: 'radial',
              connectionStyle: 'curved'
            };
            
            // Update form
            document.getElementById('setting-node-pulse').checked = true;
            document.getElementById('setting-show-stars').checked = true;
            document.getElementById('setting-show-nebulae').checked = true;
            document.getElementById('setting-auto-save').checked = true;
            document.getElementById('setting-show-minimap').checked = false;
            document.getElementById('setting-node-gravity').checked = true;
            document.getElementById('setting-show-tooltips').checked = true;
            document.getElementById('setting-collapse-ui').checked = true;
            document.getElementById('setting-theme').value = 'dark';
            document.getElementById('setting-double-tap').value = '300';
            document.getElementById('setting-layout-algo').value = 'radial';
            document.getElementById('setting-connection-style').value = 'curved';
            
            this.saveSettings();
            this.showToast('Settings reset to default', 'success');
          }
        });
        
        // Export settings
        document.getElementById('export-settings').addEventListener('click', () => {
          const dataStr = JSON.stringify(this.settings, null, 2);
          const blob = new Blob([dataStr], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          
          const link = document.createElement('a');
          link.download = 'cosmic-mindmap-settings.json';
          link.href = url;
          link.click();
          
          URL.revokeObjectURL(url);
          this.showToast('Settings exported', 'success');
        });
        
        // Import settings
        document.getElementById('import-settings').addEventListener('click', () => {
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = '.json';
          
          input.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (event) => {
                try {
                  const importedSettings = JSON.parse(event.target.result);
                  this.settings = { ...this.settings, ...importedSettings };
                  
                  // Update form
                  document.getElementById('setting-node-pulse').checked = this.settings.nodePulse;
                  document.getElementById('setting-show-stars').checked = this.settings.showStars;
                  document.getElementById('setting-show-nebulae').checked = this.settings.showNebulae;
                  document.getElementById('setting-auto-save').checked = this.settings.autoSave;
                  document.getElementById('setting-show-minimap').checked = this.settings.showMinimap;
                  document.getElementById('setting-node-gravity').checked = this.settings.nodeGravity;
                  document.getElementById('setting-show-tooltips').checked = this.settings.showTooltips;
                  document.getElementById('setting-collapse-ui').checked = this.settings.collapseUI;
                  document.getElementById('setting-theme').value = this.settings.theme || 'dark';
                  document.getElementById('setting-double-tap').value = this.settings.doubleTapSpeed || '300';
                  document.getElementById('setting-layout-algo').value = this.settings.layoutAlgorithm || 'radial';
                  document.getElementById('setting-connection-style').value = this.settings.connectionStyle || 'curved';
                  
                  this.saveSettings();
                  this.showToast('Settings imported', 'success');
                } catch (error) {
                  this.showToast('Error importing settings', 'error');
                }
              };
              reader.readAsText(file);
            }
          };
          
          input.click();
        });
        
        // Clear all data
        document.getElementById('clear-data').addEventListener('click', () => {
          if (confirm('Are you sure you want to clear all local data? This will delete all your mindmaps and settings.')) {
            localStorage.clear();
            this.showToast('All data cleared. Reloading...', 'warning');
            setTimeout(() => {
              window.location.reload();
            }, 1500);
          }
        });
        
        // Tab switching
        const tabs = document.querySelectorAll('#settings-panel .tab');
        tabs.forEach(tab => {
          tab.addEventListener('click', () => {
            // Deactivate all tabs
            tabs.forEach(t => t.classList.remove('active'));
            document.querySelectorAll('#settings-panel .tab-content').forEach(c => c.classList.remove('active'));
            
            // Activate selected tab
            tab.classList.add('active');
            document.getElementById(`tab-${tab.getAttribute('data-tab')}`).classList.add('active');
          });
        });
      }
      
      // Setup help
      setupHelp() {
        // Close button
        document.getElementById('close-help').addEventListener('click', () => {
          this.togglePanel('help-panel', false);
        });
        
        // Close button in footer
        document.getElementById('help-close-btn').addEventListener('click', () => {
          this.togglePanel('help-panel', false);
        });
        
        // Tab switching
        const tabs = document.querySelectorAll('#help-panel .tab');
        tabs.forEach(tab => {
          tab.addEventListener('click', () => {
            // Deactivate all tabs
            tabs.forEach(t => t.classList.remove('active'));
            document.querySelectorAll('#help-panel .tab-content').forEach(c => c.classList.remove('active'));
            
            // Activate selected tab
            tab.classList.add('active');
            document.getElementById(`help-${tab.getAttribute('data-tab')}`).classList.add('active');
          });
        });
      }
      
      // Setup export
      setupExport() {
        // Close button
        document.getElementById('close-export').addEventListener('click', () => {
          this.togglePanel('export-panel', false);
        });
        
        // Export as PNG
        document.getElementById('export-image').addEventListener('click', () => {
          this.exportAsImage();
          this.togglePanel('export-panel', false);
        });
        
        // Export as SVG
        document.getElementById('export-svg').addEventListener('click', () => {
          this.exportAsSVG();
          this.togglePanel('export-panel', false);
        });
        
        // Export as JSON
        document.getElementById('export-json').addEventListener('click', () => {
          this.exportAsJSON();
          this.togglePanel('export-panel', false);
        });
        
        // Export as PDF
        document.getElementById('export-pdf').addEventListener('click', () => {
          this.showToast('PDF export coming soon', 'warning');
          this.togglePanel('export-panel', false);
        });
        
        // Import JSON
        document.getElementById('import-json').addEventListener('click', () => {
          document.getElementById('import-file').click();
        });
        
        // Import file handler
        document.getElementById('import-file').addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
              try {
                const data = JSON.parse(event.target.result);
                if (data.nodes && data.connections) {
                  this.importMindmap(data);
                  this.togglePanel('export-panel', false);
                } else {
                  this.showToast('Invalid mindmap file format', 'error');
                }
              } catch (error) {
                this.showToast('Error parsing file', 'error');
              }
            };
            reader.readAsText(file);
          }
        });
      }
      
      // Setup search
      setupSearch() {
        const searchContainer = document.getElementById('search-container');
        const searchInput = document.getElementById('search-input');
        const searchResults = document.getElementById('search-results');
        
        searchInput.addEventListener('input', () => {
          const query = searchInput.value.trim().toLowerCase();
          
          if (query.length < 2) {
            searchResults.classList.remove('active');
            return;
          }
          
          // Clear previous results
          while (searchResults.firstChild) {
            searchResults.removeChild(searchResults.firstChild);
          }
          
          // Find matching nodes
          const matches = this.nodes.filter(node => 
            node.text.toLowerCase().includes(query) || 
            (node.description && node.description.toLowerCase().includes(query))
          );
          
          if (matches.length === 0) {
            const noResults = document.createElement('div');
            noResults.className = 'search-result';
            noResults.textContent = 'No results found';
            searchResults.appendChild(noResults);
          } else {
            matches.forEach(node => {
              const result = document.createElement('div');
              result.className = 'search-result';
              
              // Highlight matching text
              const highlightedText = node.text.replace(
                new RegExp(`(${query})`, 'gi'),
                '<span class="search-highlight">$1</span>'
              );
              
              result.innerHTML = highlightedText;
              
              result.addEventListener('click', () => {
                this.focusNode(node);
                searchResults.classList.remove('active');
                searchContainer.classList.remove('active');
                this.searchActive = false;
              });
              
              searchResults.appendChild(result);
            });
          }
          
          searchResults.classList.add('active');
        });
        
        // Close search results when clicking outside
        document.addEventListener('click', (e) => {
          if (!searchContainer.contains(e.target) && !document.getElementById('search-btn').contains(e.target)) {
            searchResults.classList.remove('active');
            if (this.searchActive) {
              searchContainer.classList.remove('active');
              this.searchActive = false;
            }
          }
        });
      }
      
      // Toggle search visibility
      toggleSearch() {
        const searchContainer = document.getElementById('search-container');
        this.searchActive = !this.searchActive;
        searchContainer.classList.toggle('active', this.searchActive);
        
        if (this.searchActive) {
          document.getElementById('search-input').focus();
        } else {
          document.getElementById('search-results').classList.remove('active');
        }
      }
      
      // Setup mini map
      setupMiniMap() {
        const miniMap = document.getElementById('mini-map');
        miniMap.classList.toggle('active', this.minimapActive);
        
        if (this.minimapActive) {
          this.updateMiniMap();
        }
      }
      
      // Toggle mini map visibility
      toggleMiniMap() {
        this.minimapActive = !this.minimapActive;
        document.getElementById('mini-map').classList.toggle('active', this.minimapActive);
        this.settings.showMinimap = this.minimapActive;
        this.saveSettings();
        
        if (this.minimapActive) {
          this.updateMiniMap();
        }
      }
      
      // Update mini map
      updateMiniMap() {
        const miniMapContent = document.getElementById('mini-map-content');
        
        // Clear previous content
        while (miniMapContent.firstChild) {
          miniMapContent.removeChild(miniMapContent.firstChild);
        }
        
        if (this.nodes.length === 0) return;
        
        // Calculate bounds of all nodes
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        
        this.nodes.forEach(node => {
          minX = Math.min(minX, node.x - node.radius);
          minY = Math.min(minY, node.y - node.radius);
          maxX = Math.max(maxX, node.x + node.radius);
          maxY = Math.max(maxY, node.y + node.radius);
        });
        
        // Add padding
        minX -= 50;
        minY -= 50;
        maxX += 50;
        maxY += 50;
        
        const worldWidth = maxX - minX;
        const worldHeight = maxY - minY;
        
        // Calculate scale factor to fit in mini map
        const miniMapWidth = miniMapContent.clientWidth;
        const miniMapHeight = miniMapContent.clientHeight;
        const scaleX = miniMapWidth / worldWidth;
        const scaleY = miniMapHeight / worldHeight;
        const scale = Math.min(scaleX, scaleY);
        
        // Draw connections
        this.connections.forEach(connection => {
          const sourceNode = this.nodes.find(n => n.id === connection.source);
          const targetNode = this.nodes.find(n => n.id === connection.target);
          
          if (sourceNode && targetNode) {
            const line = document.createElement('div');
            line.style.position = 'absolute';
            line.style.height = '1px';
            line.style.background = 'rgba(58, 134, 255, 0.5)';
            
            const x1 = (sourceNode.x - minX) * scale;
            const y1 = (sourceNode.y - minY) * scale;
            const x2 = (targetNode.x - minX) * scale;
            const y2 = (targetNode.y - minY) * scale;
            
            const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            
            line.style.width = `${length}px`;
            line.style.left = `${x1}px`;
            line.style.top = `${y1}px`;
            line.style.transformOrigin = '0 0';
            line.style.transform = `rotate(${angle}deg)`;
            
            miniMapContent.appendChild(line);
          }
        });
        
        // Draw nodes
        this.nodes.forEach(node => {
          const miniNode = document.createElement('div');
          miniNode.className = 'mini-map-node';
          
          const x = (node.x - minX) * scale;
          const y = (node.y - minY) * scale;
          const radius = node.radius * scale * 0.8; // Slightly smaller for better visibility
          
          miniNode.style.left = `${x - radius}px`;
          miniNode.style.top = `${y - radius}px`;
          miniNode.style.width = `${radius * 2}px`;
          miniNode.style.height = `${radius * 2}px`;
          miniNode.style.setProperty('--node-color', node.color);
          
          miniMapContent.appendChild(miniNode);
        });
        
        // Draw viewport rectangle
        const viewport = document.createElement('div');
        viewport.className = 'mini-map-viewport';
        
        const canvasWidth = this.canvas.clientWidth;
        const canvasHeight = this.canvas.clientHeight;
        
        const viewMinX = -this.offset.x * this.scale;
        const viewMinY = -this.offset.y * this.scale;
        const viewMaxX = viewMinX + canvasWidth;
        const viewMaxY = viewMinY + canvasHeight;
        
        const viewLeft = Math.max(0, (viewMinX - minX) * scale);
        const viewTop = Math.max(0, (viewMinY - minY) * scale);
        const viewRight = Math.min(miniMapWidth, (viewMaxX - minX) * scale);
        const viewBottom = Math.min(miniMapHeight, (viewMaxY - minY) * scale);
        
        viewport.style.left = `${viewLeft}px`;
        viewport.style.top = `${viewTop}px`;
        viewport.style.width = `${viewRight - viewLeft}px`;
        viewport.style.height = `${viewBottom - viewTop}px`;
        
        miniMapContent.appendChild(viewport);
      }
      
      // Setup context menu
      setupContextMenu() {
        const contextMenu = document.getElementById('context-menu');
        
        // Prevent default context menu
        this.canvas.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          const rect = this.canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / this.scale - this.offset.x;
          const y = (e.clientY - rect.top) / this.scale - this.offset.y;
          
          const clickedNode = this.findNodeAt(x, y);
          
          if (clickedNode) {
            this.showContextMenu(e.clientX, e.clientY, 'node', clickedNode);
          } else {
            this.showContextMenu(e.clientX, e.clientY, 'canvas');
          }
        });
      }
      
      // Show context menu
      showContextMenu(x, y, type, node = null) {
        const contextMenu = document.getElementById('context-menu');
        
        // Clear previous items
        while (contextMenu.firstChild) {
          contextMenu.removeChild(contextMenu.firstChild);
        }
        
        if (type === 'node' && node) {
          // Node context menu items
          this.addContextMenuItem(contextMenu, 'Edit Node', () => {
            this.selectNode(node);
            this.openNodeEditor(node);
          });
          
          this.addContextMenuItem(contextMenu, 'Delete Node', () => {
            this.deleteNode(node.id);
            this.showToast('Node deleted');
          });
          
          this.addContextMenuSeparator(contextMenu);
          
          this.addContextMenuItem(contextMenu, 'Connect From Here', () => {
            this.setMode('connect');
            this.connectSource = node;
            this.showToast('Select target node to connect');
          });
          
          this.addContextMenuItem(contextMenu, 'Add Child Node', () => {
            const childX = node.x + node.radius * 2;
            const childY = node.y;
            
            const childNode = this.createNode({
              x: childX,
              y: childY,
              text: 'New Node',
              type: node.type === 'sun' ? 'planet' : 'moon',
              color: node.type === 'sun' ? '#3a86ff' : '#94a3b8',
              importance: 'normal'
            });
            
            this.createConnection(node.id, childNode.id);
          });
          
          if (node.type !== 'sun') {
            this.addContextMenuItem(contextMenu, 'Convert to Central Idea', () => {
              this.updateNode(node.id, { type: 'sun', color: '#ff9500' });
            });
          }
          
          if (node.type !== 'planet') {
            this.addContextMenuItem(contextMenu, 'Convert to Main Idea', () => {
              this.updateNode(node.id, { type: 'planet', color: '#3a86ff' });
            });
          }
          
          if (node.type !== 'moon') {
            this.addContextMenuItem(contextMenu, 'Convert to Sub-Idea', () => {
              this.updateNode(node.id, { type: 'moon', color: '#94a3b8' });
            });
          }
          
          if (node.type !== 'blackhole') {
            this.addContextMenuItem(contextMenu, 'Mark as Completed', () => {
              this.updateNode(node.id, { type: 'blackhole', color: '#020617' });
            });
          }
        } else {
          // Canvas context menu items
          this.addContextMenuItem(contextMenu, 'Add Central Idea', () => {
            this.setMode('add-sun');
          });
          
          this.addContextMenuItem(contextMenu, 'Add Main Idea', () => {
            this.setMode('add-planet');
          });
          
          this.addContextMenuItem(contextMenu, 'Add Sub-Idea', () => {
            this.setMode('add-moon');
          });
          
          this.addContextMenuItem(contextMenu, 'Add Quick Note', () => {
            this.setMode('add-asteroid');
          });
          
          this.addContextMenuSeparator(contextMenu);
          
          this.addContextMenuItem(contextMenu, 'Auto Layout', () => {
            this.autoLayout();
          });
          
          this.addContextMenuItem(contextMenu, 'Reset View', () => {
            this.resetView();
          });
          
          this.addContextMenuItem(contextMenu, 'Save Mindmap', () => {
            this.saveMindmap();
          });
        }
        
        // Position and show menu
        contextMenu.style.left = `${x}px`;
        contextMenu.style.top = `${y}px`;
        
        // Adjust position if menu would go off screen
        const rect = contextMenu.getBoundingClientRect();
        if (rect.right > window.innerWidth) {
          contextMenu.style.left = `${x - rect.width}px`;
        }
        if (rect.bottom > window.innerHeight) {
          contextMenu.style.top = `${y - rect.height}px`;
        }
        
        contextMenu.classList.add('active');
      }
      
      // Add context menu item
      addContextMenuItem(menu, text, callback) {
        const item = document.createElement('div');
        item.className = 'context-menu-item';
        item.textContent = text;
        item.addEventListener('click', () => {
          callback();
          menu.classList.remove('active');
        });
        menu.appendChild(item);
      }
      
      // Add context menu separator
      addContextMenuSeparator(menu) {
        const separator = document.createElement('div');
        separator.className = 'context-menu-separator';
        menu.appendChild(separator);
      }
      
      // Setup welcome modal
      setupWelcomeModal() {
        const loadingScreen = document.getElementById('loading-screen');
        
        // Simulate loading
        setTimeout(() => {
          loadingScreen.style.display = 'none';
          this.loadLastMindmap();
        }, 1000);
      }
      
      // Zoom the canvas
      zoom(factor) {
        const centerX = this.canvas.clientWidth / 2;
        const centerY = this.canvas.clientHeight / 2;
        
        // Convert center position to world space before scaling
        const worldX = centerX / this.scale - this.offset.x;
        const worldY = centerY / this.scale - this.offset.y;
        
        this.scale *= factor;
        
        // Limit zoom level
        this.scale = Math.max(0.2, Math.min(3, this.scale));
        
        // Adjust offset to zoom toward center
        this.offset.x = centerX / this.scale - worldX;
        this.offset.y = centerY / this.scale - worldY;
        
        this.renderMindmap();
      }
      
      // Reset view to center
      resetView() {
        this.scale = 1;
        this.centerView();
      }
      
      // Center the view
      centerView() {
        const centerX = this.canvas.clientWidth / 2;
        const centerY = this.canvas.clientHeight / 2;
        
        this.offset.x = centerX / this.scale;
        this.offset.y = centerY / this.scale;
        
        this.renderMindmap();
      }
      
      // Focus on a specific node
      focusNode(node) {
        const centerX = this.canvas.clientWidth / 2;
        const centerY = this.canvas.clientHeight / 2;
        
        this.offset.x = centerX / this.scale - node.x;
        this.offset.y = centerY / this.scale - node.y;
        
        this.selectNode(node);
        this.renderMindmap();
      }
      
      // Find node at position
      findNodeAt(x, y) {
        for (let i = this.nodes.length - 1; i >= 0; i--) {
          const node = this.nodes[i];
          const dx = x - node.x;
          const dy = y - node.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= node.radius) {
            return node;
          }
        }
        return null;
      }
      
      // Select a node
      selectNode(node) {
        this.deselectNode();
        this.selectedNode = node;
        node.selected = true;
        this.renderMindmap();
      }
      
      // Deselect current node
      deselectNode() {
        if (this.selectedNode) {
          this.selectedNode.selected = false;
          this.selectedNode = null;
          this.renderMindmap();
        }
      }
      
      // Create a new node
      createNode(options) {
        const node = {
          id: this.generateId(),
          x: options.x,
          y: options.y,
          text: options.text || 'New Node',
          description: options.description || '',
          type: options.type || 'planet',
          color: options.color || '#3a86ff',
          importance: options.importance || 'normal',
          radius: this.getNodeRadius(options.type, options.importance),
          selected: false,
          createdAt: new Date().toISOString()
        };
        
        this.nodes.push(node);
        this.renderMindmap();
        this.showToast('Node created', 'success');
        
        if (this.minimapActive) {
          this.updateMiniMap();
        }
        
        return node;
      }
      
      // Get node radius based on type and importance
      getNodeRadius(type, importance) {
        let baseRadius;
        
        switch (type) {
          case 'sun':
            baseRadius = 50;
            break;
          case 'planet':
            baseRadius = 35;
            break;
          case 'moon':
            baseRadius = 20;
            break;
          case 'asteroid':
            baseRadius = 12;
            break;
          case 'blackhole':
            baseRadius = 25;
            break;
          default:
            baseRadius = 30;
        }
        
        // Adjust for importance
        switch (importance) {
          case 'high':
            return baseRadius * 1.2;
          case 'critical':
            return baseRadius * 1.4;
          case 'low':
            return baseRadius * 0.8;
          default:
            return baseRadius;
        }
      }
      
      // Update a node
      updateNode(id, updates) {
        const node = this.nodes.find(n => n.id === id);
        if (node) {
          Object.assign(node, updates);
          
          // Update radius based on type and importance
          if (updates.type || updates.importance) {
            node.radius = this.getNodeRadius(
              updates.type || node.type,
              updates.importance || node.importance
            );
          }
          
          this.renderMindmap();
          
          if (this.minimapActive) {
            this.updateMiniMap();
          }
        }
      }
      
      // Delete a node
      deleteNode(id) {
        const index = this.nodes.findIndex(n => n.id === id);
        if (index !== -1) {
          this.nodes.splice(index, 1);
          
          // Delete all connections involving this node
          this.connections = this.connections.filter(
            c => c.source !== id && c.target !== id
          );
          
          this.renderMindmap();
          
          if (this.minimapActive) {
            this.updateMiniMap();
          }
        }
      }
      
      // Create a connection between nodes
      createConnection(sourceId, targetId) {
        // Prevent duplicate connections
        const exists = this.connections.some(
          c => (c.source === sourceId && c.target === targetId) || 
               (c.source === targetId && c.target === sourceId)
        );
        
        if (!exists && sourceId !== targetId) {
          const sourceNode = this.nodes.find(n => n.id === sourceId);
          const targetNode = this.nodes.find(n => n.id === targetId);
          
          if (sourceNode && targetNode) {
            // Determine connection strength based on node types
            let strength = 'normal';
            
            if (sourceNode.type === 'sun' && targetNode.type === 'planet') {
              strength = 'strong';
            } else if (sourceNode.type === 'planet' && targetNode.type === 'moon') {
              strength = 'normal';
            } else if (targetNode.type === 'asteroid') {
              strength = 'weak';
            }
            
            this.connections.push({
              id: this.generateId(),
              source: sourceId,
              target: targetId,
              strength: strength
            });
            
            this.renderMindmap();
            
            if (this.minimapActive) {
              this.updateMiniMap();
            }
          }
        }
      }
      
      // Delete a connection
      deleteConnection(id) {
        const index = this.connections.findIndex(c => c.id === id);
        if (index !== -1) {
          this.connections.splice(index, 1);
          this.renderMindmap();
          
          if (this.minimapActive) {
            this.updateMiniMap();
          }
        }
      }
      
      // Apply gravitational forces to nodes
      applyGravity() {
        if (!this.settings.nodeGravity) return;
        
        // Find sun nodes (central ideas)
        const suns = this.nodes.filter(node => node.type === 'sun');
        
        // If no suns, use the first node as center
        const centers = suns.length > 0 ? suns : [this.nodes[0]];
        
        if (!centers || centers.length === 0) return;
        
        // Apply gravity
        this.nodes.forEach(node => {
          if (centers.includes(node)) return; // Skip center nodes
          
          // Find connected nodes
          const connections = this.connections.filter(
            c => c.source === node.id || c.target === node.id
          );
          
          if (connections.length === 0) return; // Skip unconnected nodes
          
          // Calculate gravitational pull from connected nodes
          let totalForceX = 0;
          let totalForceY = 0;
          
          connections.forEach(connection => {
            const connectedId = connection.source === node.id ? connection.target : connection.source;
            const connectedNode = this.nodes.find(n => n.id === connectedId);
            
            if (connectedNode) {
              const dx = connectedNode.x - node.x;
              const dy = connectedNode.y - node.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance > connectedNode.radius + node.radius + 20) {
                // Calculate optimal distance based on node types
                let optimalDistance;
                
                if (connectedNode.type === 'sun' && node.type === 'planet') {
                  optimalDistance = connectedNode.radius + node.radius + 100;
                } else if (connectedNode.type === 'planet' && node.type === 'moon') {
                  optimalDistance = connectedNode.radius + node.radius + 60;
                } else {
                  optimalDistance = connectedNode.radius + node.radius + 80;
                }
                
                // Calculate force (stronger if too far, weaker if close to optimal)
                const forceMagnitude = (distance - optimalDistance) * 0.01;
                
                // Add to total force
                if (distance > 0) {
                  totalForceX += (dx / distance) * forceMagnitude;
                  totalForceY += (dy / distance) * forceMagnitude;
                }
              }
            }
          });
          
          // Apply force (limited to prevent chaotic movement)
          const maxForce = 2;
          node.x += Math.max(-maxForce, Math.min(maxForce, totalForceX));
          node.y += Math.max(-maxForce, Math.min(maxForce, totalForceY));
        });
      }
      
      // Auto layout the mindmap
      autoLayout() {
        const algorithm = this.settings.layoutAlgorithm || 'radial';
        
        switch (algorithm) {
          case 'radial':
            this.applyRadialLayout();
            break;
          case 'force':
            this.applyForceLayout();
            break;
          case 'hierarchical':
            this.applyHierarchicalLayout();
            break;
          default:
            this.applyRadialLayout();
        }
        
        this.renderMindmap();
        this.resetView();
        this.showToast('Auto layout applied', 'success');
      }
      
      // Apply radial layout
      applyRadialLayout() {
        // Find sun nodes (central ideas)
        const suns = this.nodes.filter(node => node.type === 'sun');
        
        if (suns.length === 0 && this.nodes.length > 0) {
          // If no suns, convert the first node to a sun
          this.updateNode(this.nodes[0].id, { type: 'sun', color: '#ff9500' });
          suns.push(this.nodes[0]);
        }
        
        if (suns.length === 0) {
          this.showToast('No nodes to layout', 'warning');
          return;
        }
        
        // Position suns in the center
        const centerX = 0;
        const centerY = 0;
        
        if (suns.length === 1) {
          // Single sun in the center
          suns[0].x = centerX;
          suns[0].y = centerY;
          
          // Find direct children (planets)
          const planets = this.findDirectChildren(suns[0].id);
          
          // Position planets in a circle around the sun
          const planetRadius = suns[0].radius + 150;
          const planetAngleStep = (2 * Math.PI) / Math.max(planets.length, 1);
          
          planets.forEach((planet, i) => {
            const angle = i * planetAngleStep;
            planet.x = centerX + planetRadius * Math.cos(angle);
            planet.y = centerY + planetRadius * Math.sin(angle);
            
            // Find moons for this planet
            const moons = this.findDirectChildren(planet.id);
            
            // Position moons in a smaller circle around the planet
            const moonRadius = planet.radius + 80;
            const moonAngleStep = (2 * Math.PI) / Math.max(moons.length, 1);
            
            moons.forEach((moon, j) => {
              const moonAngle = j * moonAngleStep;
              moon.x = planet.x + moonRadius * Math.cos(moonAngle);
              moon.y = planet.y + moonRadius * Math.sin(moonAngle);
            });
          });
        } else {
          // Multiple suns - arrange them in a circle
          const sunRadius = 200;
          const sunAngleStep = (2 * Math.PI) / suns.length;
          
          suns.forEach((sun, i) => {
            const angle = i * sunAngleStep;
            sun.x = centerX + sunRadius * Math.cos(angle);
            sun.y = centerY + sunRadius * Math.sin(angle);
            
            // Position planets for each sun
            const planets = this.findDirectChildren(sun.id);
            const planetRadius = sun.radius + 120;
            const planetAngleStep = (2 * Math.PI) / Math.max(planets.length, 1);
            
            planets.forEach((planet, j) => {
              const planetAngle = angle + (j * planetAngleStep);
              planet.x = sun.x + planetRadius * Math.cos(planetAngle);
              planet.y = sun.y + planetRadius * Math.sin(planetAngle);
              
              // Position moons
              const moons = this.findDirectChildren(planet.id);
              const moonRadius = planet.radius + 60;
              const moonAngleStep = (2 * Math.PI) / Math.max(moons.length, 1);
              
              moons.forEach((moon, k) => {
                const moonAngle = planetAngle + (k * moonAngleStep);
                moon.x = planet.x + moonRadius * Math.cos(moonAngle);
                moon.y = planet.y + moonRadius * Math.sin(moonAngle);
              });
            });
          });
        }
        
        // Position any remaining nodes (asteroids, etc.)
        const remainingNodes = this.nodes.filter(node => 
          !suns.includes(node) && 
          !this.connections.some(c => c.source === node.id || c.target === node.id)
        );
        
        const asteroidRadius = 300;
        const asteroidAngleStep = (2 * Math.PI) / Math.max(remainingNodes.length, 1);
        
        remainingNodes.forEach((node, i) => {
          const angle = i * asteroidAngleStep;
          node.x = centerX + asteroidRadius * Math.cos(angle);
          node.y = centerY + asteroidRadius * Math.sin(angle);
        });
      }
      
      // Apply force-directed layout
      applyForceLayout() {
        // This is a simplified force-directed layout
        // In a real implementation, this would be more sophisticated
        
        // Initialize random positions if needed
        this.nodes.forEach(node => {
          if (!node.x && !node.y) {
            node.x = (Math.random() - 0.5) * 500;
            node.y = (Math.random() - 0.5) * 500;
          }
        });
        
        // Run simulation
        for (let i = 0; i < 100; i++) {
          // Calculate repulsive forces between all nodes
          this.nodes.forEach(node1 => {
            let fx = 0;
            let fy = 0;
            
            this.nodes.forEach(node2 => {
              if (node1 !== node2) {
                const dx = node1.x - node2.x;
                const dy = node1.y - node2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                  // Repulsive force
                  const force = 1000 / (distance * distance);
                  fx += (dx / distance) * force;
                  fy += (dy / distance) * force;
                }
              }
            });
            
            // Store forces
            node1.fx = fx;
            node1.fy = fy;
          });
          
          // Calculate attractive forces along connections
          this.connections.forEach(connection => {
            const sourceNode = this.nodes.find(n => n.id === connection.source);
            const targetNode = this.nodes.find(n => n.id === connection.target);
            
            if (sourceNode && targetNode) {
              const dx = sourceNode.x - targetNode.x;
              const dy = sourceNode.y - targetNode.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance > 0) {
                // Attractive force
                const force = distance / 10;
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                
                sourceNode.fx -= fx;
                sourceNode.fy -= fy;
                targetNode.fx += fx;
                targetNode.fy += fy;
              }
            }
          });
          
          // Apply forces
          this.nodes.forEach(node => {
            node.x += Math.min(10, Math.max(-10, node.fx || 0));
            node.y += Math.min(10, Math.max(-10, node.fy || 0));
          });
        }
      }
      
      // Apply hierarchical layout
      applyHierarchicalLayout() {
        // Find root nodes (suns or nodes without incoming connections)
        const rootNodes = this.nodes.filter(node => 
          node.type === 'sun' || 
          !this.connections.some(c => c.target === node.id)
        );
        
        if (rootNodes.length === 0 && this.nodes.length > 0) {
          rootNodes.push(this.nodes[0]);
        }
        
        if (rootNodes.length === 0) {
          this.showToast('No nodes to layout', 'warning');
          return;
        }
        
        // Calculate levels for each node
        const levels = {};
        const visited = new Set();
        
        const calculateLevels = (nodeId, level) => {
          if (visited.has(nodeId)) return;
          visited.add(nodeId);
          
          levels[nodeId] = level;
          
          // Find children
          const children = this.connections
            .filter(c => c.source === nodeId)
            .map(c => c.target);
          
          children.forEach(childId => {
            calculateLevels(childId, level + 1);
          });
        };
        
        rootNodes.forEach(node => {
          calculateLevels(node.id, 0);
        });
        
        // Group nodes by level
        const nodesByLevel = {};
        this.nodes.forEach(node => {
          const level = levels[node.id] || 0;
          if (!nodesByLevel[level]) {
            nodesByLevel[level] = [];
          }
          nodesByLevel[level].push(node);
        });
        
        // Position nodes by level
        const levelHeight = 150;
        const nodeSpacing = 120;
        
        Object.entries(nodesByLevel).forEach(([level, nodes]) => {
          const levelY = parseInt(level) * levelHeight;
          const levelWidth = nodes.length * nodeSpacing;
          const startX = -levelWidth / 2 + nodeSpacing / 2;
          
          nodes.forEach((node, i) => {
            node.y = levelY;
            node.x = startX + i * nodeSpacing;
          });
        });
      }
      
      // Find direct children of a node
      findDirectChildren(nodeId) {
        const childrenIds = this.connections
          .filter(c => c.source === nodeId)
          .map(c => c.target);
        
        return this.nodes.filter(node => childrenIds.includes(node.id));
      }
      
      // Render the mindmap
      renderMindmap() {
        // Apply gravity if enabled
        if (this.settings.nodeGravity) {
          this.applyGravity();
        }
        
        // Clear canvas
        while (this.canvas.firstChild) {
          this.canvas.removeChild(this.canvas.firstChild);
        }
        
        // Render connections
        this.connections.forEach(connection => {
          const sourceNode = this.nodes.find(n => n.id === connection.source);
          const targetNode = this.nodes.find(n => n.id === connection.target);
          
          if (sourceNode && targetNode) {
            const connectionEl = document.createElement('div');
            connectionEl.className = `connection ${connection.strength || 'normal'}`;
            
            // Calculate connection position and rotation
            const dx = targetNode.x - sourceNode.x;
            const dy = targetNode.y - sourceNode.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            // Position and rotate
            connectionEl.style.width = `${distance}px`;
            connectionEl.style.left = `${(sourceNode.x * this.scale) + (this.offset.x * this.scale)}px`;
            connectionEl.style.top = `${(sourceNode.y * this.scale) + (this.offset.y * this.scale)}px`;
            connectionEl.style.transform = `rotate(${angle}deg)`;
            
            this.canvas.appendChild(connectionEl);
          }
        });
        
        // Render nodes
        this.nodes.forEach(node => {
          const nodeEl = document.createElement('div');
          nodeEl.className = `node ${node.type}`;
          if (node.selected) nodeEl.classList.add('selected');
          
          // Set node style
          nodeEl.style.width = `${node.radius * 2 * this.scale}px`;
          nodeEl.style.height = `${node.radius * 2 * this.scale}px`;
          nodeEl.style.left = `${(node.x - node.radius) * this.scale + (this.offset.x * this.scale)}px`;
          nodeEl.style.top = `${(node.y - node.radius) * this.scale + (this.offset.y * this.scale)}px`;
          nodeEl.style.setProperty('--node-color', node.color);
          
          // Disable animation if setting is off
          if (!this.settings.nodePulse) {
            nodeEl.style.animation = 'none';
          }
          
          // Node label
          const labelEl = document.createElement('div');
          labelEl.className = 'node-label';
          labelEl.textContent = node.text;
          nodeEl.appendChild(labelEl);
          
          // Double click to edit
          nodeEl.addEventListener('dblclick', () => {
            this.selectNode(node);
            this.openNodeEditor(node);
          });
          
          this.canvas.appendChild(nodeEl);
        });
        
        // Update mini map if active
        if (this.minimapActive) {
          this.updateMiniMap();
        }
      }
      
      // Create a new mindmap
      createNewMindmap() {
        this.nodes = [];
        this.connections = [];
        this.selectedNode = null;
        this.currentMindmapId = this.generateId();
        this.mindmapTitle = 'My Cosmic Universe';
        document.getElementById('mindmap-title').value = this.mindmapTitle;
        
        this.resetView();
        this.showToast('New mindmap created', 'success');
      }
      
      // Save mindmap to local storage
      saveMindmap() {
        const mindmap = {
          id: this.currentMindmapId,
          title: this.mindmapTitle,
          nodes: this.nodes,
          connections: this.connections,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        
        // Get existing mindmaps
        let mindmaps = JSON.parse(localStorage.getItem('cosmic_mindmaps') || '[]');
        
        // Update if exists, otherwise add new
        const index = mindmaps.findIndex(m => m.id === this.currentMindmapId);
        if (index !== -1) {
          mindmaps[index] = mindmap;
        } else {
          mindmaps.push(mindmap);
        }
        
        localStorage.setItem('cosmic_mindmaps', JSON.stringify(mindmaps));
        localStorage.setItem('last_mindmap_id', this.currentMindmapId);
        
        this.showToast('Mindmap saved', 'success');
      }
      
      // Load mindmap from local storage
      loadMindmap(id) {
        const mindmaps = JSON.parse(localStorage.getItem('cosmic_mindmaps') || '[]');
        const mindmap = mindmaps.find(m => m.id === id);
        
        if (mindmap) {
          this.currentMindmapId = mindmap.id;
          this.mindmapTitle = mindmap.title;
          this.nodes = mindmap.nodes;
          this.connections = mindmap.connections;
          
          document.getElementById('mindmap-title').value = this.mindmapTitle;
          this.resetView();
          this.showToast('Mindmap loaded', 'success');
          
          return true;
        }
        
        return false;
      }
      
      // Load last used mindmap
      loadLastMindmap() {
        const lastId = localStorage.getItem('last_mindmap_id');
        if (lastId) {
          if (!this.loadMindmap(lastId)) {
            this.createNewMindmap();
          }
        } else {
          this.createNewMindmap();
        }
      }
      
      // Import mindmap from JSON data
      importMindmap(data) {
        if (data.nodes && data.connections) {
          this.nodes = data.nodes;
          this.connections = data.connections;
          this.currentMindmapId = data.id || this.generateId();
          this.mindmapTitle = data.title || 'Imported Mindmap';
          
          document.getElementById('mindmap-title').value = this.mindmapTitle;
          this.resetView();
          this.showToast('Mindmap imported successfully', 'success');
        }
      }
      
      // Open gallery
      openGallery() {
        const gallery = document.getElementById('gallery');
        const galleryGrid = document.getElementById('gallery-grid');
        
        // Clear gallery
        while (galleryGrid.firstChild) {
          galleryGrid.removeChild(galleryGrid.firstChild);
        }
        
        // Get mindmaps from local storage
        const mindmaps = JSON.parse(localStorage.getItem('cosmic_mindmaps') || '[]');
        
        if (mindmaps.length === 0) {
          const emptyMessage = document.createElement('div');
          emptyMessage.textContent = 'No saved mindmaps yet. Create and save your first cosmic mindmap!';
          emptyMessage.style.gridColumn = '1 / -1';
          emptyMessage.style.textAlign = 'center';
          emptyMessage.style.padding = '40px';
          emptyMessage.style.color = 'var(--foreground-muted)';
          galleryGrid.appendChild(emptyMessage);
        } else {
          // Sort by date (newest first)
          mindmaps.sort((a, b) => new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt));
          
          // Create gallery items
          mindmaps.forEach(mindmap => {
            const item = document.createElement('div');
            item.className = 'gallery-item';
            
            const preview = document.createElement('div');
            preview.className = 'gallery-item-preview';
            
            // Create mini preview of the mindmap
            this.createMiniPreview(preview, mindmap);
            
            // Add actions
            const actions = document.createElement('div');
            actions.className = 'gallery-item-actions';
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'btn btn-icon';
            deleteBtn.innerHTML = '<svg class="icon icon-sm" viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>';
            deleteBtn.title = 'Delete';
            deleteBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              if (confirm('Delete this mindmap? This action cannot be undone.')) {
                this.deleteMindmapFromGallery(mindmap.id);
              }
            });
            
            actions.appendChild(deleteBtn);
            preview.appendChild(actions);
            
            const info = document.createElement('div');
            info.className = 'gallery-item-info';
            
            const title = document.createElement('div');
            title.className = 'gallery-item-title';
            title.textContent = mindmap.title;
            title.title = mindmap.title;
            
            const date = document.createElement('div');
            date.className = 'gallery-item-date';
            date.textContent = new Date(mindmap.updatedAt || mindmap.createdAt).toLocaleDateString();
            
            info.appendChild(title);
            info.appendChild(date);
            
            item.appendChild(preview);
            item.appendChild(info);
            
            // Click to load
            item.addEventListener('click', () => {
              this.loadMindmap(mindmap.id);
              gallery.classList.remove('active');
            });
            
            galleryGrid.appendChild(item);
          });
        }
        
        gallery.classList.add('active');
      }
      
      // Delete mindmap from gallery
      deleteMindmapFromGallery(id) {
        let mindmaps = JSON.parse(localStorage.getItem('cosmic_mindmaps') || '[]');
        mindmaps = mindmaps.filter(m => m.id !== id);
        localStorage.setItem('cosmic_mindmaps', JSON.stringify(mindmaps));
        
        // If deleted the current mindmap, create a new one
        if (id === this.currentMindmapId) {
          this.createNewMindmap();
        }
        
        // If deleted the last mindmap, update last_mindmap_id
        if (id === localStorage.getItem('last_mindmap_id')) {
          if (mindmaps.length > 0) {
            localStorage.setItem('last_mindmap_id', mindmaps[0].id);
          } else {
            localStorage.removeItem('last_mindmap_id');
          }
        }
        
        this.showToast('Mindmap deleted', 'success');
        this.openGallery(); // Refresh gallery
      }
      
      // Create mini preview of mindmap for gallery
      createMiniPreview(container, mindmap) {
        // Create a simplified version of the mindmap for preview
        const maxNodes = Math.min(10, mindmap.nodes.length);
        
        // Draw connections first
        for (let i = 0; i < Math.min(15, mindmap.connections.length); i++) {
          const connection = mindmap.connections[i];
          const sourceNode = mindmap.nodes.find(n => n.id === connection.source);
          const targetNode = mindmap.nodes.find(n => n.id === connection.target);
          
          if (sourceNode && targetNode) {
            const line = document.createElement('div');
            line.style.position = 'absolute';
            line.style.height = '1px';
            line.style.background = 'rgba(58, 134, 255, 0.3)';
            line.style.width = '30px';
            line.style.left = `${30 + Math.random() * 60}px`;
            line.style.top = `${30 + Math.random() * 60}px`;
            line.style.transform = `rotate(${Math.random() * 360}deg)`;
            
            container.appendChild(line);
          }
        }
        
        // Then draw nodes
        for (let i = 0; i < maxNodes; i++) {
          const node = mindmap.nodes[i];
          const nodeEl = document.createElement('div');
          nodeEl.style.position = 'absolute';
          nodeEl.style.width = `${node.type === 'sun' ? 20 : node.type === 'planet' ? 12 : 6}px`;
          nodeEl.style.height = nodeEl.style.width;
          nodeEl.style.borderRadius = '50%';
          nodeEl.style.background = node.color || '#3a86ff';
          nodeEl.style.boxShadow = `0 0 5px ${node.color || '#3a86ff'}`;
          
          // Position based on node type
          if (node.type === 'sun') {
            nodeEl.style.left = '50%';
            nodeEl.style.top = '50%';
            nodeEl.style.transform = 'translate(-50%, -50%)';
          } else {
            // Position randomly for preview
            nodeEl.style.left = `${20 + Math.random() * 80}px`;
            nodeEl.style.top = `${20 + Math.random() * 80}px`;
          }
          
          container.appendChild(nodeEl);
        }
      }
      
      // Export mindmap as image
      exportAsImage() {
        // Create a temporary canvas for rendering
        const tempCanvas = document.createElement('canvas');
        const ctx = tempCanvas.getContext('2d');
        
        // Set canvas size
        tempCanvas.width = this.canvas.clientWidth;
        tempCanvas.height = this.canvas.clientHeight;
        
        // Draw background
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        
        // Draw stars
        if (this.settings.showStars) {
          for (let i = 0; i < 100; i++) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            const x = Math.random() * tempCanvas.width;
            const y = Math.random() * tempCanvas.height;
            const radius = Math.random() * 1.5 + 0.5;
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // Draw connections
        this.connections.forEach(connection => {
          const sourceNode = this.nodes.find(n => n.id === connection.source);
          const targetNode = this.nodes.find(n => n.id === connection.target);
          
          if (sourceNode && targetNode) {
            ctx.strokeStyle = connection.strength === 'strong' ? 'rgba(58, 134, 255, 0.7)' : 
                              connection.strength === 'weak' ? 'rgba(58, 134, 255, 0.3)' : 
                              'rgba(58, 134, 255, 0.5)';
            ctx.lineWidth = connection.strength === 'strong' ? 3 : 
                           connection.strength === 'weak' ? 1 : 2;
            ctx.beginPath();
            ctx.moveTo(
              sourceNode.x * this.scale + this.offset.x * this.scale,
              sourceNode.y * this.scale + this.offset.y * this.scale
            );
            ctx.lineTo(
              targetNode.x * this.scale + this.offset.x * this.scale,
              targetNode.y * this.scale + this.offset.y * this.scale
            );
            ctx.stroke();
          }
        });
        
        // Draw nodes
        this.nodes.forEach(node => {
          // Draw node
          const gradient = ctx.createRadialGradient(
            node.x * this.scale + this.offset.x * this.scale,
            node.y * this.scale + this.offset.y * this.scale,
            0,
            node.x * this.scale + this.offset.x * this.scale,
            node.y * this.scale + this.offset.y * this.scale,
            node.radius * this.scale
          );
          gradient.addColorStop(0, node.color);
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(
            node.x * this.scale + this.offset.x * this.scale,
            node.y * this.scale + this.offset.y * this.scale,
            node.radius * this.scale,
            0,
            Math.PI * 2
          );
          ctx.fill();
          
          // Draw node text
          ctx.fillStyle = 'white';
          ctx.font = '12px Inter';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(
            node.text,
            node.x * this.scale + this.offset.x * this.scale,
            node.y * this.scale + this.offset.y * this.scale
          );
        });
        
        // Draw title
        ctx.fillStyle = 'white';
        ctx.font = 'bold 16px Montserrat';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText(this.mindmapTitle, 20, 20);
        
        // Create download link
        const link = document.createElement('a');
        link.download = `${this.mindmapTitle.replace(/\s+/g, '-').toLowerCase()}.png`;
        link.href = tempCanvas.toDataURL('image/png');
        link.click();
        
        this.showToast('Image exported successfully', 'success');
      }
      
      // Export mindmap as SVG
      exportAsSVG() {
        // Create SVG element
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        const width = this.canvas.clientWidth;
        const height = this.canvas.clientHeight;
        
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        
        // Add background
        const background = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        background.setAttribute('width', width);
        background.setAttribute('height', height);
        background.setAttribute('fill', '#0f172a');
        svg.appendChild(background);
        
        // Add connections
        this.connections.forEach(connection => {
          const sourceNode = this.nodes.find(n => n.id === connection.source);
          const targetNode = this.nodes.find(n => n.id === connection.target);
          
          if (sourceNode && targetNode) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', sourceNode.x * this.scale + this.offset.x * this.scale);
            line.setAttribute('y1', sourceNode.y * this.scale + this.offset.y * this.scale);
            line.setAttribute('x2', targetNode.x * this.scale + this.offset.x * this.scale);
            line.setAttribute('y2', targetNode.y * this.scale + this.offset.y * this.scale);
            
            const strokeColor = connection.strength === 'strong' ? 'rgba(58, 134, 255, 0.7)' : 
                               connection.strength === 'weak' ? 'rgba(58, 134, 255, 0.3)' : 
                               'rgba(58, 134, 255, 0.5)';
            const strokeWidth = connection.strength === 'strong' ? 3 : 
                              connection.strength === 'weak' ? 1 : 2;
            
            line.setAttribute('stroke', strokeColor);
            line.setAttribute('stroke-width', strokeWidth);
            svg.appendChild(line);
          }
        });
        
        // Add nodes
        this.nodes.forEach(node => {
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('cx', node.x * this.scale + this.offset.x * this.scale);
          circle.setAttribute('cy', node.y * this.scale + this.offset.y * this.scale);
          circle.setAttribute('r', node.radius * this.scale);
          
          // Create radial gradient
          const gradientId = `gradient-${node.id}`;
          const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
          gradient.setAttribute('id', gradientId);
          gradient.setAttribute('cx', '30%');
          gradient.setAttribute('cy', '30%');
          gradient.setAttribute('r', '70%');
          
          const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
          stop1.setAttribute('offset', '0%');
          stop1.setAttribute('stop-color', node.color);
          
          const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
          stop2.setAttribute('offset', '100%');
          stop2.setAttribute('stop-color', 'rgba(0, 0, 0, 0.5)');
          
          gradient.appendChild(stop1);
          gradient.appendChild(stop2);
          
          const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
          defs.appendChild(gradient);
          svg.appendChild(defs);
          
          circle.setAttribute('fill', `url(#${gradientId})`);
          svg.appendChild(circle);
          
          // Add node text
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', node.x * this.scale + this.offset.x * this.scale);
          text.setAttribute('y', node.y * this.scale + this.offset.y * this.scale);
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('dominant-baseline', 'middle');
          text.setAttribute('fill', 'white');
          text.setAttribute('font-family', 'Inter, sans-serif');
          text.setAttribute('font-size', '12px');
          text.textContent = node.text;
          svg.appendChild(text);
        });
        
        // Add title
        const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        title.setAttribute('x', 20);
        title.setAttribute('y', 30);
        title.setAttribute('fill', 'white');
        title.setAttribute('font-family', 'Montserrat, sans-serif');
        title.setAttribute('font-size', '16px');
        title.setAttribute('font-weight', 'bold');
        title.textContent = this.mindmapTitle;
        svg.appendChild(title);
        
        // Convert SVG to string
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(svg);
        
        // Create download link
        const blob = new Blob([svgString], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.download = `${this.mindmapTitle.replace(/\s+/g, '-').toLowerCase()}.svg`;
        link.href = url;
        link.click();
        
        URL.revokeObjectURL(url);
        this.showToast('SVG exported successfully', 'success');
      }
      
      // Export mindmap as JSON
      exportAsJSON() {
        const data = {
          id: this.currentMindmapId,
          title: this.mindmapTitle,
          nodes: this.nodes,
          connections: this.connections,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        
        const dataStr = JSON.stringify(data, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const link = document.createElement('a');
        link.download = `${this.mindmapTitle.replace(/\s+/g, '-').toLowerCase()}.json`;
        link.href = url;
        link.click();
        
        URL.revokeObjectURL(url);
        this.showToast('JSON exported successfully', 'success');
      }
      
      // Show toast notification
      showToast(message, type = 'default') {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        
        container.appendChild(toast);
        
        // Remove after animation completes
        setTimeout(() => {
          if (container.contains(toast)) {
            container.removeChild(toast);
          }
        }, 3500);
      }
      
      // Generate unique ID
      generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
      }
    }
    
    // Initialize the application when the DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      window.cosmicMindmap = new CosmicMindmap();
    });
  </script>
</body>
</html>
