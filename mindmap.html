<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Mindmap</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            overflow: hidden;
            background-color: #050520;
            color: #fff;
            height: 100vh;
            width: 100vw;
        }

        /* Canvas Container */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiPgogIDxkZWZzPgogICAgPHJhZGlhbEdyYWRpZW50IGlkPSJzcGFjZSIgY3g9IjUwJSIgY3k9IjUwJSIgcj0iNTAlIiBmeD0iNTAlIiBmeT0iNTAlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzEwMTAzMDsiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6IzA1MDUyMDsiIC8+CiAgICA8L3JhZGlhbEdyYWRpZW50PgogIDwvZGVmcz4KICA8cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSJ1cmwoI3NwYWNlKSIgLz4KPC9zdmc+');
        }

        /* Stars Background */
        #stars {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Mars Background */
        #mars-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            opacity: 0.3;
            z-index: 2;
        }

        /* Canvas */
        #mindmap-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 3;
            cursor: grab;
            touch-action: none; /* Prevent default touch actions */
        }

        #mindmap-canvas:active {
            cursor: grabbing;
        }

        /* UI Elements */
        .ui-container {
            position: absolute;
            z-index: 10;
            pointer-events: none;
            width: 100%;
            height: 100%;
        }

        /* Toolbar */
        .toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(20, 20, 40, 0.8);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
            transition: all 0.3s ease;
            border: 1px solid rgba(100, 100, 255, 0.2);
        }

        .toolbar button {
            background: none;
            border: none;
            color: #fff;
            font-size: 18px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(60, 60, 100, 0.3);
        }

        .toolbar button:hover {
            background: rgba(80, 80, 150, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }

        .toolbar button.active {
            background: rgba(100, 100, 200, 0.7);
            box-shadow: 0 0 10px rgba(100, 100, 255, 0.7);
        }

        .toolbar .separator {
            width: 1px;
            background: rgba(255, 255, 255, 0.2);
            margin: 0 5px;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            right: 20px;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(20, 20, 40, 0.8);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
            border: 1px solid rgba(100, 100, 255, 0.2);
        }

        .zoom-controls button {
            background: none;
            border: none;
            color: #fff;
            font-size: 18px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(60, 60, 100, 0.3);
        }

        .zoom-controls button:hover {
            background: rgba(80, 80, 150, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }

        .zoom-level {
            text-align: center;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            font-weight: bold;
        }

        /* Menu */
        .menu {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 40, 0.8);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 1px solid rgba(100, 100, 255, 0.2);
        }

        .menu button {
            background: none;
            border: none;
            color: #fff;
            padding: 8px 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(60, 60, 100, 0.3);
            text-align: left;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .menu button:hover {
            background: rgba(80, 80, 150, 0.5);
            transform: translateX(3px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }

        .menu button svg {
            width: 18px;
            height: 18px;
        }

        /* Node Editor */
        .node-editor {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 30, 60, 0.95);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.7);
            width: 320px;
            max-width: 90%;
            pointer-events: auto;
            display: none;
            z-index: 100;
            border: 1px solid rgba(100, 100, 255, 0.3);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -55%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }

        .node-editor h3 {
            margin-bottom: 20px;
            font-size: 20px;
            color: #fff;
            text-align: center;
            text-shadow: 0 0 10px rgba(100, 100, 255, 0.5);
        }

        .node-editor input, .node-editor textarea {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: rgba(40, 40, 80, 0.5);
            border: 1px solid rgba(100, 100, 200, 0.3);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .node-editor input:focus, .node-editor textarea:focus {
            border-color: rgba(100, 100, 255, 0.6);
            box-shadow: 0 0 10px rgba(100, 100, 255, 0.3);
            outline: none;
        }

        .node-editor textarea {
            min-height: 120px;
            resize: vertical;
        }

        .color-options {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .color-option {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            border: 2px solid white;
        }

        .node-editor-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        .node-editor button {
            padding: 10px 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
            font-size: 14px;
        }

        .node-editor .save-btn {
            background: #4a6cff;
            color: white;
        }

        .node-editor .save-btn:hover {
            background: #3a5cef;
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }

        .node-editor .cancel-btn {
            background: rgba(80, 80, 120, 0.3);
            color: #ddd;
        }

        .node-editor .cancel-btn:hover {
            background: rgba(100, 100, 150, 0.4);
            transform: translateY(-2px);
        }

        .node-editor .delete-btn {
            background: #ff4a6c;
            color: white;
        }

        .node-editor .delete-btn:hover {
            background: #ef3a5c;
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }

        /* File Menu */
        .file-menu {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(30, 30, 60, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.7);
            width: 280px;
            max-width: 90%;
            pointer-events: auto;
            display: none;
            z-index: 100;
            border: 1px solid rgba(100, 100, 255, 0.3);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .file-menu h3 {
            margin-bottom: 15px;
            font-size: 18px;
            color: #fff;
            text-align: center;
            text-shadow: 0 0 10px rgba(100, 100, 255, 0.5);
        }

        .file-menu input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: rgba(40, 40, 80, 0.5);
            border: 1px solid rgba(100, 100, 200, 0.3);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .file-menu input:focus {
            border-color: rgba(100, 100, 255, 0.6);
            box-shadow: 0 0 10px rgba(100, 100, 255, 0.3);
            outline: none;
        }

        .file-menu-buttons {
            display: flex;
            justify-content: space-between;
        }

        .file-menu button {
            padding: 10px 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
            font-size: 14px;
        }

        .file-menu .save-btn {
            background: #4a6cff;
            color: white;
        }

        .file-menu .save-btn:hover {
            background: #3a5cef;
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }

        .file-menu .cancel-btn {
            background: rgba(80, 80, 120, 0.3);
            color: #ddd;
        }

        .file-menu .cancel-btn:hover {
            background: rgba(100, 100, 150, 0.4);
            transform: translateY(-2px);
        }

        .saved-maps {
            margin-top: 20px;
            max-height: 250px;
            overflow-y: auto;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 15px;
        }

        .saved-maps::-webkit-scrollbar {
            width: 6px;
        }

        .saved-maps::-webkit-scrollbar-track {
            background: rgba(30, 30, 60, 0.5);
            border-radius: 3px;
        }

        .saved-maps::-webkit-scrollbar-thumb {
            background: rgba(100, 100, 255, 0.5);
            border-radius: 3px;
        }

        .saved-map-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            background: rgba(60, 60, 100, 0.3);
            transition: all 0.2s ease;
        }

        .saved-map-item:hover {
            background: rgba(80, 80, 150, 0.5);
            transform: translateX(3px);
        }

        .saved-map-item button {
            padding: 5px 10px;
            font-size: 12px;
            margin: 0 2px;
        }

        /* Help Modal */
        .help-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 30, 60, 0.95);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.7);
            width: 550px;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            pointer-events: auto;
            display: none;
            z-index: 100;
            border: 1px solid rgba(100, 100, 255, 0.3);
            animation: scaleIn 0.3s ease;
        }

        @keyframes scaleIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .help-modal::-webkit-scrollbar {
            width: 6px;
        }

        .help-modal::-webkit-scrollbar-track {
            background: rgba(30, 30, 60, 0.5);
            border-radius: 3px;
        }

        .help-modal::-webkit-scrollbar-thumb {
            background: rgba(100, 100, 255, 0.5);
            border-radius: 3px;
        }

        .help-modal h2 {
            margin-bottom: 25px;
            color: #fff;
            text-align: center;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(100, 100, 255, 0.5);
        }

        .help-section {
            margin-bottom: 25px;
            background: rgba(40, 40, 80, 0.3);
            padding: 15px;
            border-radius: 10px;
        }

        .help-section h3 {
            margin-bottom: 12px;
            color: #4a6cff;
            font-size: 18px;
        }

        .help-section p {
            margin-bottom: 12px;
            line-height: 1.6;
            color: #ddd;
        }

        .help-section ul {
            margin-left: 20px;
            margin-bottom: 12px;
        }

        .help-section li {
            margin-bottom: 8px;
            color: #ddd;
            line-height: 1.4;
        }

        .help-modal button {
            padding: 10px 20px;
            background: #4a6cff;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: block;
            margin: 10px auto 0;
            font-weight: bold;
            font-size: 14px;
        }

        .help-modal button:hover {
            background: #3a5cef;
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }

        /* Context Menu */
        .context-menu {
            position: absolute;
            background: rgba(30, 30, 60, 0.95);
            backdrop-filter: blur(10px);
            padding: 8px 0;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7);
            z-index: 100;
            display: none;
            min-width: 180px;
            border: 1px solid rgba(100, 100, 255, 0.3);
            animation: fadeIn 0.2s ease;
        }

        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .context-menu-item:hover {
            background: rgba(80, 80, 150, 0.5);
        }

        .context-menu-separator {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: 5px 0;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(30, 30, 60, 0.95);
            backdrop-filter: blur(10px);
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7);
            color: white;
            z-index: 1000;
            transform: translateY(-100px);
            opacity: 0;
            transition: all 0.3s ease;
            border: 1px solid rgba(100, 100, 255, 0.3);
            font-weight: 500;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-left: 4px solid #4CAF50;
        }

        .toast.error {
            border-left: 4px solid #F44336;
        }

        .toast.info {
            border-left: 4px solid #2196F3;
        }

        /* Add Child Button */
        .add-child-button {
            position: absolute;
            width: 24px;
            height: 24px;
            background: rgba(100, 100, 200, 0.7);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 3;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .add-child-button:hover {
            transform: scale(1.2);
            background: rgba(100, 100, 255, 0.9);
            box-shadow: 0 0 15px rgba(100, 100, 255, 0.7);
        }

        .add-child-button svg {
            width: 16px;
            height: 16px;
            color: white;
        }

        /* Improved Node Design */
        .node {
            position: absolute;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s ease;
            cursor: pointer;
            overflow: hidden;
        }

        .node:hover {
            transform: scale(1.05);
        }

        .node-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            text-align: center;
        }

        /* Autosave Indicator */
        .autosave-indicator {
            position: absolute;
            bottom: 20px;
            right: 80px;
            background: rgba(20, 20, 40, 0.8);
            backdrop-filter: blur(10px);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            border: 1px solid rgba(100, 100, 255, 0.2);
            font-weight: 500;
        }

        .autosave-indicator.show {
            opacity: 1;
        }

        /* Loading Indicator */
        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 3px solid rgba(100, 100, 255, 0.3);
            border-radius: 50%;
            border-top-color: #4a6cff;
            animation: spin 1s linear infinite;
            display: none;
            z-index: 1000;
        }

        @keyframes spin {
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Keyboard Shortcuts Display */
        .keyboard-shortcuts {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 20, 40, 0.8);
            backdrop-filter: blur(10px);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
            border: 1px solid rgba(100, 100, 255, 0.2);
            display: flex;
            gap: 10px;
        }

        .keyboard-shortcut {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .key {
            background: rgba(60, 60, 100, 0.5);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            border: 1px solid rgba(100, 100, 255, 0.3);
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .toolbar {
                bottom: 10px;
                padding: 8px 15px;
            }

            .toolbar button {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }

            .zoom-controls {
                right: 10px;
                bottom: 10px;
            }

            .menu {
                top: 10px;
                left: 10px;
            }

            .node-editor {
                width: 300px;
                padding: 20px;
            }
            
            .keyboard-shortcuts {
                display: none; /* Hide on mobile */
            }
        }
    </style>
</head>
<body>
    <!-- Canvas Container -->
    <div id="canvas-container">
        <!-- Stars Background -->
        <canvas id="stars"></canvas>
        
        <!-- Mars Background -->
        <div id="mars-background"></div>
        
        <!-- Mindmap Canvas -->
        <canvas id="mindmap-canvas"></canvas>
    </div>

    <!-- UI Elements -->
    <div class="ui-container">
        <!-- Menu -->
        <div class="menu">
            <button id="new-map-btn">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 5v14M5 12h14"></path>
                </svg>
                New Map
            </button>
            <button id="open-map-btn">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M5 3h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z"></path>
                    <polyline points="9 10 12 7 15 10"></polyline>
                    <line x1="12" y1="7" x2="12" y2="17"></line>
                </svg>
                Open Map
            </button>
            <button id="export-map-btn">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                Export as Image
            </button>
            <button id="help-btn">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                    <line x1="12" y1="17" x2="12.01" y2="17"></line>
                </svg>
                Help
            </button>
            <button id="go-to-index-btn">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                    <polyline points="9 22 9 12 15 12 15 22"></polyline>
                </svg>
                Home
            </button>
        </div>

        <!-- Toolbar -->
        <div class="toolbar">
            <button id="select-tool" class="active" title="Select Tool">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path>
                </svg>
            </button>
            <button id="add-node-tool" title="Add Node">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="16"></line>
                    <line x1="8" y1="12" x2="16" y2="12"></line>
                </svg>
            </button>
            <div class="separator"></div>
            <button id="center-view-btn" title="Center View">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="22" y1="12" x2="18" y2="12"></line>
                    <line x1="6" y1="12" x2="2" y2="12"></line>
                    <line x1="12" y1="6" x2="12" y2="2"></line>
                    <line x1="12" y1="22" x2="12" y2="18"></line>
                </svg>
            </button>
        </div>

        <!-- Zoom Controls -->
        <div class="zoom-controls">
            <button id="zoom-in-btn" title="Zoom In">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    <line x1="11" y1="8" x2="11" y2="14"></line>
                    <line x1="8" y1="11" x2="14" y2="11"></line>
                </svg>
            </button>
            <div class="zoom-level" id="zoom-level">100%</div>
            <button id="zoom-out-btn" title="Zoom Out">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    <line x1="8" y1="11" x2="14" y2="11"></line>
                </svg>
            </button>
        </div>

        <!-- Keyboard Shortcuts -->
        <div class="keyboard-shortcuts">
            <div class="keyboard-shortcut">
                <span class="key">Space</span>
                <span>Center</span>
            </div>
            <div class="keyboard-shortcut">
                <span class="key">Del</span>
                <span>Delete</span>
            </div>
            <div class="keyboard-shortcut">
                <span class="key">Dbl Click</span>
                <span>Edit</span>
            </div>
        </div>

        <!-- Autosave Indicator -->
        <div class="autosave-indicator" id="autosave-indicator">Autosaving...</div>
    </div>

    <!-- Node Editor -->
    <div class="node-editor" id="node-editor">
        <h3>Edit Node</h3>
        <input type="text" id="node-title" placeholder="Node Title">
        <textarea id="node-content" placeholder="Node Content (optional)"></textarea>
        <div class="color-options" id="color-options">
            <div class="color-option selected" style="background-color: #4a6cff;" data-color="#4a6cff"></div>
            <div class="color-option" style="background-color: #ff4a6c;" data-color="#ff4a6c"></div>
            <div class="color-option" style="background-color: #4aff8c;" data-color="#4aff8c"></div>
            <div class="color-option" style="background-color: #ff9f4a;" data-color="#ff9f4a"></div>
            <div class="color-option" style="background-color: #cb4aff;" data-color="#cb4aff"></div>
            <div class="color-option" style="background-color: #4aecff;" data-color="#4aecff"></div>
            <div class="color-option" style="background-color: #ffec4a;" data-color="#ffec4a"></div>
            <div class="color-option" style="background-color: #ff4aec;" data-color="#ff4aec"></div>
        </div>
        <div class="node-editor-buttons">
            <button class="cancel-btn" id="node-cancel-btn">Cancel</button>
            <button class="delete-btn" id="node-delete-btn">Delete</button>
            <button class="save-btn" id="node-save-btn">Save</button>
        </div>
    </div>

    <!-- File Menu -->
    <div class="file-menu" id="file-menu">
        <h3 id="file-menu-title">Open Mindmap</h3>
        <input type="text" id="map-name" placeholder="Enter mindmap name">
        <div class="file-menu-buttons">
            <button class="cancel-btn" id="file-cancel-btn">Cancel</button>
            <button class="save-btn" id="file-save-btn">Save</button>
        </div>
        <div class="saved-maps" id="saved-maps">
            <!-- Saved maps will be populated here -->
        </div>
    </div>

    <!-- Help Modal -->
    <div class="help-modal" id="help-modal">
        <h2>Cosmic Mindmap Help</h2>
        
        <div class="help-section">
            <h3>Basic Controls</h3>
            <ul>
                <li><strong>Pan:</strong> Click and drag on empty space</li>
                <li><strong>Zoom:</strong> Use mouse wheel or zoom buttons</li>
                <li><strong>Select Node:</strong> Click on a node</li>
                <li><strong>Move Node:</strong> Drag a selected node</li>
                <li><strong>Edit Node:</strong> Double-click on a node</li>
            </ul>
        </div>
        
        <div class="help-section">
            <h3>Creating Content</h3>
            <ul>
                <li><strong>Add Child Node:</strong> Click the "+" button that appears when hovering over a node</li>
                <li><strong>Add Root Node:</strong> Select the Add Node tool and click on the canvas</li>
                <li><strong>Edit Node:</strong> Double-click on a node to edit its content and color</li>
                <li><strong>Delete Node:</strong> Select a node and press Delete key, or edit the node and click Delete</li>
            </ul>
        </div>
        
        <div class="help-section">
            <h3>Managing Mindmaps</h3>
            <ul>
                <li><strong>Autosave:</strong> Your mindmap is automatically saved as you work</li>
                <li><strong>Export as Image:</strong> Click "Export as Image" to download your mindmap as a PNG file</li>
                <li><strong>Open Map:</strong> Load a previously saved mindmap</li>
                <li><strong>New Map:</strong> Start a fresh mindmap (your current one is saved first)</li>
            </ul>
        </div>
        
        <div class="help-section">
            <h3>Tips</h3>
            <p>
                Create a central idea first, then add child nodes by clicking the "+" button that appears when hovering over nodes.
                Use different colors to categorize related concepts.
                Double-click the background to quickly add a new root node at that location.
            </p>
        </div>
        
        <button id="close-help-btn">Close</button>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="context-menu">
        <div class="context-menu-item" id="context-add-node">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="16"></line>
                <line x1="8" y1="12" x2="16" y2="12"></line>
            </svg>
            Add Node
        </div>
        <div class="context-menu-item" id="context-edit-node">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </svg>
            Edit Node
        </div>
        <div class="context-menu-item" id="context-delete-node">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
            Delete Node
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="context-add-child">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                <circle cx="8.5" cy="7" r="4"></circle>
                <line x1="20" y1="8" x2="20" y2="14"></line>
                <line x1="23" y1="11" x2="17" y2="11"></line>
            </svg>
            Add Child Node
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="context-center-view">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="22" y1="12" x2="18" y2="12"></line>
                <line x1="6" y1="12" x2="2" y2="12"></line>
                <line x1="12" y1="6" x2="12" y2="2"></line>
                <line x1="12" y1="22" x2="12" y2="18"></line>
            </svg>
            Center View
        </div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <!-- Loading Indicator -->
    <div class="loading-indicator" id="loading-indicator"></div>

    <script>
        // Constants
        const NODE_RADIUS = 60;
        const NODE_FONT = 'bold 14px Arial';
        const CONNECTION_WIDTH = 3;
        const MIN_ZOOM = 0.2;
        const MAX_ZOOM = 3;
        const ZOOM_STEP = 0.1;
        const DOUBLE_CLICK_TIME = 300; // ms
        const CHILD_BUTTON_RADIUS = 12;
        const AUTOSAVE_DELAY = 2000; // ms
        const LOCAL_STORAGE_KEY = 'cosmicMindmap_autosave';
        const ANIMATION_FRAME_RATE = 60; // fps
        const NODE_COLORS = [
            '#4a6cff', '#ff4a6c', '#4aff8c', '#ff9f4a', 
            '#cb4aff', '#4aecff', '#ffec4a', '#ff4aec'
        ];
        
        // Main application class
        class CosmicMindmap {
            constructor() {
                // Canvas setup
                this.canvas = document.getElementById('mindmap-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.starsCanvas = document.getElementById('stars');
                this.starsCtx = this.starsCanvas.getContext('2d');
                this.marsBackground = document.getElementById('mars-background');
                
                // State variables
                this.nodes = [];
                this.selectedNode = null;
                this.hoveredNode = null;
                this.draggedNode = null;
                this.isPanning = false;
                this.activeTool = 'select';
                this.zoom = 1;
                this.offset = { x: 0, y: 0 };
                this.dragStart = { x: 0, y: 0 };
                this.lastClick = 0;
                this.currentMapName = 'Autosaved Map';
                this.stars = [];
                this.childButtons = [];
                this.autosaveTimeout = null;
                this.autosaveIndicator = document.getElementById('autosave-indicator');
                this.animationFrameId = null;
                this.isAnimating = false;
                this.loadingIndicator = document.getElementById('loading-indicator');
                this.lastFrameTime = 0;
                this.fps = 60;
                this.frameInterval = 1000 / this.fps;
                
                // UI elements
                this.nodeEditor = document.getElementById('node-editor');
                this.fileMenu = document.getElementById('file-menu');
                this.helpModal = document.getElementById('help-modal');
                this.contextMenu = document.getElementById('context-menu');
                this.toast = document.getElementById('toast');
                
                // Initialize
                this.initCanvas();
                this.initMarsBackground();
                this.initStars();
                this.initEventListeners();
                this.loadAutosavedMap();
                
                // Start animation loop
                this.startAnimationLoop();
            }
            
            // Initialize canvas dimensions
            initCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            // Resize canvas to fill window
            resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = window.innerWidth * dpr;
                this.canvas.height = window.innerHeight * dpr;
                this.canvas.style.width = `${window.innerWidth}px`;
                this.canvas.style.height = `${window.innerHeight}px`;
                this.ctx.scale(dpr, dpr);
                
                this.starsCanvas.width = window.innerWidth * dpr;
                this.starsCanvas.height = window.innerHeight * dpr;
                this.starsCanvas.style.width = `${window.innerWidth}px`;
                this.starsCanvas.style.height = `${window.innerHeight}px`;
                this.starsCtx.scale(dpr, dpr);
                
                this.render();
                this.renderStars();
            }
            
            // Initialize Mars background
            initMarsBackground() {
                // Try to load Mars image
                const marsImage = new Image();
                marsImage.onload = () => {
                    this.marsBackground.style.backgroundImage = `url('${marsImage.src}')`;
                };
                marsImage.onerror = () => {
                    // Fallback to generated Mars
                    this.marsBackground.style.backgroundImage = `url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MDAiIGhlaWdodD0iNTAwIiB2aWV3Qm94PSIwIDAgNTAwIDUwMCI+CiAgPGNpcmNsZSBjeD0iMjUwIiBjeT0iMjUwIiByPSIyMDAiIGZpbGw9IiNlMjcyM2IiLz4KICA8Y2lyY2xlIGN4PSIxNzAiIGN5PSIxODAiIHI9IjQwIiBmaWxsPSIjYzQ1MDIzIi8+CiAgPGNpcmNsZSBjeD0iMzMwIiBjeT0iMjgwIiByPSI2MCIgZmlsbD0iI2M0NTAyMyIvPgogIDxjaXJjbGUgY3g9IjI0MCIgY3k9IjM0MCIgcj0iMzAiIGZpbGw9IiNjNDUwMjMiLz4KICA8Y2lyY2xlIGN4PSIyODAiIGN5PSIxNTAiIHI9IjUwIiBmaWxsPSIjYzQ1MDIzIi8+Cjwvc3ZnPg==')`;
                };
                marsImage.src = 'mars.png';
            }
            
            // Create starfield background
            initStars() {
                const numStars = Math.floor((window.innerWidth * window.innerHeight) / 800);
                this.stars = [];
                
                for (let i = 0; i < numStars; i++) {
                    this.stars.push({
                        x: Math.random() * this.starsCanvas.width,
                        y: Math.random() * this.starsCanvas.height,
                        radius: Math.random() * 1.5,
                        alpha: Math.random(),
                        cycle: Math.random() * 100,
                        twinkleSpeed: Math.random() * 0.02 + 0.01
                    });
                }
                
                this.renderStars();
                this.animateStars();
            }
            
            // Render stars on canvas
            renderStars() {
                this.starsCtx.clearRect(0, 0, this.starsCanvas.width, this.starsCanvas.height);
                
                for (const star of this.stars) {
                    this.starsCtx.beginPath();
                    this.starsCtx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                    this.starsCtx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
                    this.starsCtx.fill();
                }
            }
            
            // Animate stars twinkling
            animateStars() {
                for (const star of this.stars) {
                    star.cycle += star.twinkleSpeed;
                    star.alpha = 0.5 + 0.5 * Math.sin(star.cycle);
                }
                
                this.renderStars();
                requestAnimationFrame(() => this.animateStars());
            }
            
            // Start animation loop for smooth rendering
            startAnimationLoop() {
                const loop = (timestamp) => {
                    // Calculate delta time for consistent animations
                    const deltaTime = timestamp - this.lastFrameTime;
                    
                    // Only render if we're animating or enough time has passed
                    if (this.isAnimating || deltaTime >= this.frameInterval) {
                        this.render();
                        this.lastFrameTime = timestamp;
                    }
                    
                    this.animationFrameId = requestAnimationFrame(loop);
                };
                
                this.animationFrameId = requestAnimationFrame(loop);
            }
            
            // Set up all event listeners
            initEventListeners() {
                // Mouse events on canvas
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.handleMouseUp());
                this.canvas.addEventListener('mouseleave', () => this.handleMouseUp());
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    this.showContextMenu(e);
                });
                
                // Touch events for mobile
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                this.canvas.addEventListener('touchend', () => this.handleTouchEnd());
                
                // Keyboard events
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                
                // Tool buttons
                document.getElementById('select-tool').addEventListener('click', () => this.setTool('select'));
                document.getElementById('add-node-tool').addEventListener('click', () => this.setTool('add-node'));
                document.getElementById('center-view-btn').addEventListener('click', () => this.centerView());
                
                // Zoom controls
                document.getElementById('zoom-in-btn').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoom-out-btn').addEventListener('click', () => this.zoomOut());
                
                // Menu buttons
                document.getElementById('new-map-btn').addEventListener('click', () => this.newMap());
                document.getElementById('open-map-btn').addEventListener('click', () => this.openMapMenu());
                document.getElementById('export-map-btn').addEventListener('click', () => this.exportAsImage());
                document.getElementById('help-btn').addEventListener('click', () => this.showHelpModal());
                document.getElementById('go-to-index-btn').addEventListener('click', () => window.location.href = 'index.html');
                
                // Node editor
                document.getElementById('node-save-btn').addEventListener('click', () => this.saveNodeEdit());
                document.getElementById('node-cancel-btn').addEventListener('click', () => this.closeNodeEditor());
                document.getElementById('node-delete-btn').addEventListener('click', () => this.deleteSelectedNode());
                
                // Color options
                const colorOptions = document.querySelectorAll('.color-option');
                colorOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        colorOptions.forEach(opt => opt.classList.remove('selected'));
                        option.classList.add('selected');
                    });
                });
                
                // File menu
                document.getElementById('file-save-btn').addEventListener('click', () => this.saveMap());
                document.getElementById('file-cancel-btn').addEventListener('click', () => this.closeFileMenu());
                
                // Help modal
                document.getElementById('close-help-btn').addEventListener('click', () => this.closeHelpModal());
                
                // Context menu
                document.getElementById('context-add-node').addEventListener('click', () => this.contextAddNode());
                document.getElementById('context-edit-node').addEventListener('click', () => this.contextEditNode());
                document.getElementById('context-delete-node').addEventListener('click', () => this.contextDeleteNode());
                document.getElementById('context-add-child').addEventListener('click', () => this.contextAddChildNode());
                document.getElementById('context-center-view').addEventListener('click', () => this.contextCenterView());
                
                // Close context menu when clicking elsewhere
                document.addEventListener('click', (e) => {
                    if (!this.contextMenu.contains(e.target)) {
                        this.hideContextMenu();
                    }
                });
                
                // Handle window blur/focus
                window.addEventListener('blur', () => {
                    this.isPanning = false;
                    this.draggedNode = null;
                    this.isAnimating = false;
                });
                
                window.addEventListener('focus', () => {
                    this.render();
                });
                
                // Handle beforeunload to ensure autosave
                window.addEventListener('beforeunload', () => {
                    this.autosave(true); // Force immediate save
                });
            }
            
            // Show loading indicator
            showLoading() {
                this.loadingIndicator.style.display = 'block';
            }
            
            // Hide loading indicator
            hideLoading() {
                this.loadingIndicator.style.display = 'none';
            }
            
            // Load autosaved map or create default
            loadAutosavedMap() {
                this.showLoading();
                
                setTimeout(() => {
                    const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
                    
                    if (savedData) {
                        try {
                            const parsedData = JSON.parse(savedData);
                            this.nodes = parsedData.nodes || [];
                            this.currentMapName = parsedData.name || 'Autosaved Map';
                            this.offset = parsedData.offset || { x: 0, y: 0 };
                            this.zoom = parsedData.zoom || 1;
                            
                            // Update zoom display
                            document.getElementById('zoom-level').textContent = `${Math.round(this.zoom * 100)}%`;
                            
                            this.render();
                            this.showToast('Autosaved map loaded', 'info');
                        } catch (e) {
                            console.error('Error loading autosaved map:', e);
                            this.createDefaultNode();
                        }
                    } else {
                        this.createDefaultNode();
                    }
                    
                    this.hideLoading();
                }, 500); // Short delay for better UX
            }
            
            // Create a default central node
            createDefaultNode() {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                
                this.nodes.push({
                    id: this.generateId(),
                    title: 'Main Idea',
                    content: 'Double-click to edit',
                    x: centerX,
                    y: centerY,
                    color: '#4a6cff',
                    isRoot: true,
                    children: []
                });
                
                this.render();
                this.autosave();
                this.showToast('Welcome to Cosmic Mindmap! Double-click on the node to edit.', 'info');
            }
            
            // Autosave the current map
            autosave(immediate = false) {
                // Clear any existing timeout
                if (this.autosaveTimeout) {
                    clearTimeout(this.autosaveTimeout);
                }
                
                const saveFunction = () => {
                    const mapData = {
                        name: this.currentMapName,
                        nodes: this.nodes,
                        offset: this.offset,
                        zoom: this.zoom,
                        date: new Date().toISOString()
                    };
                    
                    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(mapData));
                    
                    // Show and hide autosave indicator
                    this.autosaveIndicator.classList.add('show');
                    setTimeout(() => {
                        this.autosaveIndicator.classList.remove('show');
                    }, 1500);
                };
                
                if (immediate) {
                    saveFunction();
                } else {
                    // Set timeout for delayed save
                    this.autosaveTimeout = setTimeout(saveFunction, AUTOSAVE_DELAY);
                }
            }
            
            // Handle mouse down event
            handleMouseDown(e) {
                const pos = this.getCanvasPosition(e);
                
                // Check if clicked on a child button
                const childButton = this.getChildButtonAtPosition(e.clientX, e.clientY);
                if (childButton) {
                    this.addChildNode(childButton.parentNode);
                    return;
                }
                
                const node = this.getNodeAtPosition(pos.x, pos.y);
                
                // Check for double click
                const now = Date.now();
                const isDoubleClick = now - this.lastClick < DOUBLE_CLICK_TIME;
                this.lastClick = now;
                
                if (isDoubleClick) {
                    if (node) {
                        this.editNode(node);
                    } else if (this.activeTool === 'select') {
                        // Double click on empty space creates a new root node
                        this.createRootNodeAt(pos.x, pos.y);
                    }
                    return;
                }
                
                // Handle based on active tool
                switch (this.activeTool) {
                    case 'select':
                        if (node) {
                            this.selectNode(node);
                            this.draggedNode = node;
                            this.dragStart = { x: pos.x - node.x, y: pos.y - node.y };
                            // Start animation loop when dragging
                            this.isAnimating = true;
                        } else {
                            this.selectedNode = null;
                            this.isPanning = true;
                            this.dragStart = { x: pos.x - this.offset.x, y: pos.y - this.offset.y };
                            // Start animation loop when panning
                            this.isAnimating = true;
                        }
                        break;
                        
                    case 'add-node':
                        this.createRootNodeAt(pos.x, pos.y);
                        break;
                }
                
                this.render();
            }
            
            // Handle mouse move event
            handleMouseMove(e) {
                const pos = this.getCanvasPosition(e);
                
                // Update cursor based on hovered node or child button
                const hoveredNode = this.getNodeAtPosition(pos.x, pos.y);
                const childButton = this.getChildButtonAtPosition(e.clientX, e.clientY);
                
                if (childButton) {
                    this.canvas.style.cursor = 'pointer';
                } else if (hoveredNode) {
                    this.canvas.style.cursor = 'pointer';
                } else {
                    this.canvas.style.cursor = this.isPanning ? 'grabbing' : 'grab';
                }
                
                // Update hovered node
                if (this.hoveredNode !== hoveredNode) {
                    this.hoveredNode = hoveredNode;
                    this.render(); // Render when hover state changes
                }
                
                // Handle dragging node
                if (this.draggedNode) {
                    this.draggedNode.x = pos.x - this.dragStart.x;
                    this.draggedNode.y = pos.y - this.dragStart.y;
                    // No need to call render here as it's handled by animation loop
                }
                
                // Handle panning
                if (this.isPanning) {
                    this.offset.x = pos.x - this.dragStart.x;
                    this.offset.y = pos.y - this.dragStart.y;
                    // No need to call render here as it's handled by animation loop
                }
            }
            
            // Handle mouse up event
            handleMouseUp() {
                if (this.draggedNode || this.isPanning) {
                    this.autosave();
                    // Stop animation loop when done dragging/panning
                    this.isAnimating = false;
                }
                this.draggedNode = null;
                this.isPanning = false;
                this.render(); // Final render to ensure everything is drawn correctly
            }
            
            // Handle mouse wheel for zooming
            handleWheel(e) {
                e.preventDefault();
                
                const direction = e.deltaY > 0 ? -1 : 1;
                const factor = direction * ZOOM_STEP;
                
                // Calculate zoom center (mouse position)
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Calculate world position before zoom
                const worldX = (mouseX - this.offset.x) / this.zoom;
                const worldY = (mouseY - this.offset.y) / this.zoom;
                
                // Apply zoom
                const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, this.zoom + factor));
                
                if (newZoom !== this.zoom) {
                    this.zoom = newZoom;
                    
                    // Adjust offset to zoom toward mouse position
                    this.offset.x = mouseX - worldX * this.zoom;
                    this.offset.y = mouseY - worldY * this.zoom;
                    
                    // Update zoom display
                    document.getElementById('zoom-level').textContent = `${Math.round(this.zoom * 100)}%`;
                    
                    this.render();
                    this.autosave();
                }
            }
            
            // Handle touch start event
            handleTouchStart(e) {
                e.preventDefault(); // Prevent default touch actions
                
                if (e.touches.length === 1) {
                    // Convert touch to mouse event
                    const touch = e.touches[0];
                    const mouseEvent = {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        preventDefault: () => {}
                    };
                    this.handleMouseDown(mouseEvent);
                } else if (e.touches.length === 2) {
                    // Start pinch zoom
                    this.pinchStart = this.getPinchDistance(e);
                    this.pinchZoom = this.zoom;
                    this.pinchCenter = this.getPinchCenter(e);
                }
            }
            
            // Handle touch move event
            handleTouchMove(e) {
                e.preventDefault(); // Prevent default touch actions
                
                if (e.touches.length === 1) {
                    // Convert touch to mouse event
                    const touch = e.touches[0];
                    const mouseEvent = {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        preventDefault: () => {}
                    };
                    this.handleMouseMove(mouseEvent);
                } else if (e.touches.length === 2) {
                    // Handle pinch zoom
                    const currentDistance = this.getPinchDistance(e);
                    const scale = currentDistance / this.pinchStart;
                    
                    // Calculate center of pinch
                    const center = this.getPinchCenter(e);
                    
                    // Calculate world position before zoom
                    const worldX = (center.x - this.offset.x) / this.zoom;
                    const worldY = (center.y - this.offset.y) / this.zoom;
                    
                    // Apply zoom
                    const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, this.pinchZoom * scale));
                    this.zoom = newZoom;
                    
                    // Adjust offset to zoom toward pinch center
                    this.offset.x = center.x - worldX * this.zoom;
                    this.offset.y = center.y - worldY * this.zoom;
                    
                    // Update zoom display
                    document.getElementById('zoom-level').textContent = `${Math.round(this.zoom * 100)}%`;
                    
                    this.render();
                    this.autosave();
                }
            }
            
            // Handle touch end event
            handleTouchEnd() {
                this.handleMouseUp();
            }
            
            // Calculate distance between two touch points
            getPinchDistance(e) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            // Calculate center point between two touches
            getPinchCenter(e) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                return {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
            }
            
            // Handle keyboard events
            handleKeyDown(e) {
                // Delete key to remove selected node
                if ((e.key === 'Delete' || e.key === 'Backspace') && this.selectedNode) {
                    e.preventDefault();
                    this.deleteSelectedNode();
                }
                
                // Escape key to cancel operations
                if (e.key === 'Escape') {
                    this.closeNodeEditor();
                    this.closeFileMenu();
                    this.hideContextMenu();
                    this.closeHelpModal();
                }
                
                // Space to center view
                if (e.key === ' ' && !e.target.matches('input, textarea')) {
                    e.preventDefault();
                    this.centerView();
                }
                
                // Ctrl+S to save
                if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    this.autosave(true);
                    this.showToast('Map saved', 'success');
                }
                
                // Arrow keys to move selected node
                if (this.selectedNode && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                    const moveStep = 10;
                    
                    switch (e.key) {
                        case 'ArrowUp':
                            this.selectedNode.y -= moveStep;
                            break;
                        case 'ArrowDown':
                            this.selectedNode.y += moveStep;
                            break;
                        case 'ArrowLeft':
                            this.selectedNode.x -= moveStep;
                            break;
                        case 'ArrowRight':
                            this.selectedNode.x += moveStep;
                            break;
                    }
                    
                    this.render();
                    this.autosave();
                }
            }
            
            // Show context menu
            showContextMenu(e) {
                e.preventDefault();
                
                const pos = this.getCanvasPosition(e);
                const node = this.getNodeAtPosition(pos.x, pos.y);
                
                // Store context position and node
                this.contextPosition = { x: pos.x, y: pos.y };
                this.contextNode = node;
                
                // Show/hide node-specific options
                document.getElementById('context-edit-node').style.display = node ? 'flex' : 'none';
                document.getElementById('context-delete-node').style.display = node ? 'flex' : 'none';
                document.getElementById('context-add-child').style.display = node ? 'flex' : 'none';
                
                // Position and show menu
                this.contextMenu.style.left = `${e.clientX}px`;
                this.contextMenu.style.top = `${e.clientY}px`;
                this.contextMenu.style.display = 'block';
            }
            
            // Hide context menu
            hideContextMenu() {
                this.contextMenu.style.display = 'none';
            }
            
            // Context menu actions
            contextAddNode() {
                this.createRootNodeAt(this.contextPosition.x, this.contextPosition.y);
                this.hideContextMenu();
            }
            
            contextEditNode() {
                if (this.contextNode) {
                    this.editNode(this.contextNode);
                }
                this.hideContextMenu();
            }
            
            contextDeleteNode() {
                if (this.contextNode) {
                    this.deleteNode(this.contextNode);
                }
                this.hideContextMenu();
            }
            
            contextAddChildNode() {
                if (this.contextNode) {
                    this.addChildNode(this.contextNode);
                }
                this.hideContextMenu();
            }
            
            contextCenterView() {
                if (this.contextNode) {
                    this.centerViewOnNode(this.contextNode);
                } else {
                    this.centerView();
                }
                this.hideContextMenu();
            }
            
            // Set active tool
            setTool(tool) {
                this.activeTool = tool;
                
                // Update UI
                document.querySelectorAll('.toolbar button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(`${tool}-tool`).classList.add('active');
                
                this.render();
            }
            
            // Zoom in
            zoomIn() {
                const newZoom = Math.min(MAX_ZOOM, this.zoom + ZOOM_STEP);
                if (newZoom !== this.zoom) {
                    // Calculate center of screen
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    
                    // Calculate world position before zoom
                    const worldX = (centerX - this.offset.x) / this.zoom;
                    const worldY = (centerY - this.offset.y) / this.zoom;
                    
                    // Apply zoom
                    this.zoom = newZoom;
                    
                    // Adjust offset to zoom toward center
                    this.offset.x = centerX - worldX * this.zoom;
                    this.offset.y = centerY - worldY * this.zoom;
                    
                    // Update zoom display
                    document.getElementById('zoom-level').textContent = `${Math.round(this.zoom * 100)}%`;
                    
                    this.render();
                    this.autosave();
                }
            }
            
            // Zoom out
            zoomOut() {
                const newZoom = Math.max(MIN_ZOOM, this.zoom - ZOOM_STEP);
                if (newZoom !== this.zoom) {
                    // Calculate center of screen
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    
                    // Calculate world position before zoom
                    const worldX = (centerX - this.offset.x) / this.zoom;
                    const worldY = (centerY - this.offset.y) / this.zoom;
                    
                    // Apply zoom
                    this.zoom = newZoom;
                    
                    // Adjust offset to zoom toward center
                    this.offset.x = centerX - worldX * this.zoom;
                    this.offset.y = centerY - worldY * this.zoom;
                    
                    // Update zoom display
                    document.getElementById('zoom-level').textContent = `${Math.round(this.zoom * 100)}%`;
                    
                    this.render();
                    this.autosave();
                }
            }
            
            // Center view on canvas
            centerView() {
                if (this.nodes.length === 0) return;
                
                // Find bounding box of all nodes
                let bounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
                
                for (const node of this.nodes) {
                    this.calculateNodeBounds(node, bounds);
                }
                
                // Calculate center and dimensions
                const centerX = (bounds.minX + bounds.maxX) / 2;
                const centerY = (bounds.minY + bounds.maxY) / 2;
                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;
                
                // Calculate zoom to fit
                const zoomX = window.innerWidth / (width * 1.5);
                const zoomY = window.innerHeight / (height * 1.5);
                this.zoom = Math.min(Math.min(zoomX, zoomY), MAX_ZOOM);
                
                // Center view
                this.offset.x = window.innerWidth / 2 - centerX * this.zoom;
                this.offset.y = window.innerHeight / 2 - centerY * this.zoom;
                
                // Update zoom display
                document.getElementById('zoom-level').textContent = `${Math.round(this.zoom * 100)}%`;
                
                this.render();
                this.autosave();
                this.showToast('View centered', 'info');
            }
            
            // Calculate node bounds recursively
            calculateNodeBounds(node, bounds) {
                bounds.minX = Math.min(bounds.minX, node.x - NODE_RADIUS);
                bounds.minY = Math.min(bounds.minY, node.y - NODE_RADIUS);
                bounds.maxX = Math.max(bounds.maxX, node.x + NODE_RADIUS);
                bounds.maxY = Math.max(bounds.maxY, node.y + NODE_RADIUS);
                
                if (node.children) {
                    for (const child of node.children) {
                        this.calculateNodeBounds(child, bounds);
                    }
                }
            }
            
            // Center view on specific node
            centerViewOnNode(node) {
                this.offset.x = window.innerWidth / 2 - node.x * this.zoom;
                this.offset.y = window.innerHeight / 2 - node.y * this.zoom;
                this.render();
                this.autosave();
            }
            
            // Create a new root node at position
            createRootNodeAt(x, y) {
                const node = {
                    id: this.generateId(),
                    title: 'New Node',
                    content: '',
                    x: x,
                    y: y,
                    color: this.getRandomColor(),
                    isRoot: true,
                    children: []
                };
                
                this.nodes.push(node);
                this.selectNode(node);
                this.render();
                this.autosave();
                
                // Automatically open editor for new node
                this.editNode(node);
                
                return node;
            }
            
            // Get a random color from the predefined colors
            getRandomColor() {
                return NODE_COLORS[Math.floor(Math.random() * NODE_COLORS.length)];
            }
            
            // Add a child node to a parent node
            addChildNode(parentNode) {
                if (!parentNode) return;
                
                // Calculate position for new child
                const angle = this.getNextChildAngle(parentNode);
                const distance = NODE_RADIUS * 3;
                const childX = parentNode.x + Math.cos(angle) * distance;
                const childY = parentNode.y + Math.sin(angle) * distance;
                
                const childNode = {
                    id: this.generateId(),
                    title: 'New Child',
                    content: '',
                    x: childX,
                    y: childY,
                    color: parentNode.color,
                    parent: parentNode.id,
                    children: []
                };
                
                // Add child to parent's children array
                if (!parentNode.children) {
                    parentNode.children = [];
                }
                parentNode.children.push(childNode);
                
                this.selectNode(childNode);
                this.render();
                this.autosave();
                
                // Automatically open editor for new node
                this.editNode(childNode);
                
                return childNode;
            }
            
            // Calculate the next angle for a child node
            getNextChildAngle(parentNode) {
                if (!parentNode.children || parentNode.children.length === 0) {
                    return 0; // First child at 0 degrees (right)
                }
                
                // Distribute children evenly in a circle
                const childCount = parentNode.children.length;
                const angleStep = (Math.PI * 2) / Math.max(6, childCount + 1);
                return angleStep * childCount;
            }
            
            // Select a node
            selectNode(node) {
                this.selectedNode = node;
                this.render();
            }
            
            // Edit a node
            editNode(node) {
                this.selectedNode = node;
                
                // Populate editor fields
                document.getElementById('node-title').value = node.title || '';
                document.getElementById('node-content').value = node.content || '';
                
                // Select the correct color
                const colorOptions = document.querySelectorAll('.color-option');
                colorOptions.forEach(option => {
                    option.classList.remove('selected');
                    if (option.dataset.color === node.color) {
                        option.classList.add('selected');
                    }
                });
                
                // Show editor
                this.nodeEditor.style.display = 'block';
                document.getElementById('node-title').focus();
            }
            
            // Save node edit
            saveNodeEdit() {
                if (!this.selectedNode) return;
                
                const title = document.getElementById('node-title').value.trim();
                if (!title) {
                    this.showToast('Node title cannot be empty', 'error');
                    return;
                }
                
                this.selectedNode.title = title;
                this.selectedNode.content = document.getElementById('node-content').value.trim();
                
                const selectedColor = document.querySelector('.color-option.selected');
                if (selectedColor) {
                    this.selectedNode.color = selectedColor.dataset.color;
                }
                
                this.closeNodeEditor();
                this.render();
                this.autosave();
                this.showToast('Node updated', 'success');
            }
            
            // Close node editor
            closeNodeEditor() {
                this.nodeEditor.style.display = 'none';
            }
            
            // Delete selected node
            deleteSelectedNode() {
                if (this.selectedNode) {
                    this.deleteNode(this.selectedNode);
                }
            }
            
            // Delete a node and its children
            deleteNode(node) {
                // If it's a root node
                if (node.isRoot) {
                    this.nodes = this.nodes.filter(n => n.id !== node.id);
                } else {
                    // Find parent and remove from children
                    for (const rootNode of this.nodes) {
                        this.removeChildNodeRecursive(rootNode, node.id);
                    }
                }
                
                if (this.selectedNode === node) {
                    this.selectedNode = null;
                }
                
                this.closeNodeEditor();
                this.render();
                this.autosave();
                this.showToast('Node deleted', 'info');
            }
            
            // Recursively remove a child node by id
            removeChildNodeRecursive(parentNode, nodeId) {
                if (!parentNode.children) return false;
                
                // Check direct children
                const index = parentNode.children.findIndex(child => child.id === nodeId);
                if (index !== -1) {
                    parentNode.children.splice(index, 1);
                    return true;
                }
                
                // Check children's children
                for (const child of parentNode.children) {
                    if (this.removeChildNodeRecursive(child, nodeId)) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // Create a new map
            newMap() {
                // Autosave current map before creating new one
                this.autosave(true);
                
                if (this.nodes.length > 0) {
                    if (confirm('Create a new map? Your current map has been saved.')) {
                        this.nodes = [];
                        this.selectedNode = null;
                        this.currentMapName = 'Autosaved Map';
                        this.offset = { x: 0, y: 0 };
                        this.zoom = 1;
                        document.getElementById('zoom-level').textContent = '100%';
                        this.createDefaultNode();
                        this.render();
                    }
                } else {
                    this.createDefaultNode();
                }
            }
            
            // Open load map dialog
            openMapMenu() {
                document.getElementById('file-menu-title').textContent = 'Open Mindmap';
                document.getElementById('map-name').style.display = 'none';
                document.getElementById('file-save-btn').style.display = 'none';
                document.getElementById('saved-maps').style.display = 'block';
                
                // Populate saved maps
                this.populateSavedMaps();
                
                this.fileMenu.style.display = 'block';
            }
            
            // Populate saved maps list
            populateSavedMaps() {
                const savedMapsContainer = document.getElementById('saved-maps');
                savedMapsContainer.innerHTML = '';
                
                // Get autosaved map
                const autosaved = localStorage.getItem(LOCAL_STORAGE_KEY);
                
                // Get other saved maps
                const savedMaps = JSON.parse(localStorage.getItem('cosmicMindmaps') || '[]');
                
                if (!autosaved && savedMaps.length === 0) {
                    savedMapsContainer.innerHTML = '<p>No saved mindmaps found.</p>';
                    return;
                }
                
                // Add autosaved map first
                if (autosaved) {
                    try {
                        const autosavedData = JSON.parse(autosaved);
                        const mapItem = document.createElement('div');
                        mapItem.className = 'saved-map-item';
                        
                        const mapName = document.createElement('span');
                        mapName.textContent = autosavedData.name || 'Autosaved Map';
                        
                        const loadBtn = document.createElement('button');
                        loadBtn.textContent = 'Load';
                        loadBtn.className = 'save-btn';
                        loadBtn.addEventListener('click', () => {
                            this.closeFileMenu();
                            this.loadAutosavedMap();
                        });
                        
                        mapItem.appendChild(mapName);
                        mapItem.appendChild(loadBtn);
                        
                        savedMapsContainer.appendChild(mapItem);
                    } catch (e) {
                        console.error('Error parsing autosaved map:', e);
                    }
                }
                
                // Add other saved maps
                savedMaps.forEach(map => {
                    const mapItem = document.createElement('div');
                    mapItem.className = 'saved-map-item';
                    
                    const mapName = document.createElement('span');
                    mapName.textContent = map.name;
                    
                    const loadBtn = document.createElement('button');
                    loadBtn.textContent = 'Load';
                    loadBtn.className = 'save-btn';
                    loadBtn.addEventListener('click', () => this.loadMap(map));
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.deleteMap(map.name);
                    });
                    
                    mapItem.appendChild(mapName);
                    mapItem.appendChild(loadBtn);
                    mapItem.appendChild(deleteBtn);
                    
                    savedMapsContainer.appendChild(mapItem);
                });
            }
            
            // Load a map
            loadMap(mapData) {
                // Autosave current map before loading
                this.autosave(true);
                
                this.nodes = mapData.nodes;
                this.currentMapName = mapData.name;
                this.selectedNode = null;
                
                this.closeFileMenu();
                this.centerView();
                this.autosave();
                this.showToast(`Mindmap "${mapData.name}" loaded successfully`, 'success');
            }
            
            // Delete a saved map
            deleteMap(name) {
                if (confirm(`Are you sure you want to delete the mindmap "${name}"?`)) {
                    let savedMaps = JSON.parse(localStorage.getItem('cosmicMindmaps') || '[]');
                    savedMaps = savedMaps.filter(map => map.name !== name);
                    localStorage.setItem('cosmicMindmaps', JSON.stringify(savedMaps));
                    
                    this.populateSavedMaps();
                    this.showToast(`Mindmap "${name}" deleted`, 'info');
                }
            }
            
            // Close file menu
            closeFileMenu() {
                this.fileMenu.style.display = 'none';
            }
            
            // Export mindmap as image
            exportAsImage() {
                this.showLoading();
                
                setTimeout(() => {
                    // Create a temporary canvas for export
                    const exportCanvas = document.createElement('canvas');
                    const ctx = exportCanvas.getContext('2d');
                    
                    // Find bounding box of all nodes
                    let bounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
                    
                    for (const node of this.nodes) {
                        this.calculateNodeBoundsForExport(node, bounds);
                    }
                    
                    // Add padding
                    const padding = NODE_RADIUS * 2;
                    bounds.minX -= padding;
                    bounds.minY -= padding;
                    bounds.maxX += padding;
                    bounds.maxY += padding;
                    
                    // Set canvas size
                    const width = bounds.maxX - bounds.minX;
                    const height = bounds.maxY - bounds.minY;
                    exportCanvas.width = width;
                    exportCanvas.height = height;
                    
                    // Fill background
                    ctx.fillStyle = '#050520';
                    ctx.fillRect(0, 0, width, height);
                    
                    // Draw Mars background
                    const marsImg = new Image();
                    marsImg.onload = () => {
                        // Draw Mars with opacity
                        ctx.globalAlpha = 0.3;
                        ctx.drawImage(marsImg, 0, 0, width, height);
                        ctx.globalAlpha = 1;
                        
                        // Draw stars
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        for (let i = 0; i < width * height / 800; i++) {
                            const x = Math.random() * width;
                            const y = Math.random() * height;
                            const radius = Math.random() * 1.5;
                            ctx.beginPath();
                            ctx.arc(x, y, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Draw nodes and connections
                        for (const node of this.nodes) {
                            this.drawNodeForExport(ctx, node, bounds);
                        }
                        
                        // Add title
                        ctx.font = 'bold 24px Arial';
                        ctx.fillStyle = '#ffffff';
                        ctx.textAlign = 'center';
                        ctx.fillText(this.currentMapName, width / 2, 40);
                        
                        // Create download link
                        const link = document.createElement('a');
                        link.download = `${this.currentMapName.replace(/\s+/g, '-')}.png`;
                        link.href = exportCanvas.toDataURL('image/png');
                        link.click();
                        
                        this.hideLoading();
                        this.showToast('Mindmap exported as image', 'success');
                    };
                    
                    // Try to load Mars image
                    marsImg.onerror = () => {
                        // Fallback to generated Mars
                        marsImg.src = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MDAiIGhlaWdodD0iNTAwIiB2aWV3Qm94PSIwIDAgNTAwIDUwMCI+CiAgPGNpcmNsZSBjeD0iMjUwIiBjeT0iMjUwIiByPSIyMDAiIGZpbGw9IiNlMjcyM2IiLz4KICA8Y2lyY2xlIGN4PSIxNzAiIGN5PSIxODAiIHI9IjQwIiBmaWxsPSIjYzQ1MDIzIi8+CiAgPGNpcmNsZSBjeD0iMzMwIiBjeT0iMjgwIiByPSI2MCIgZmlsbD0iI2M0NTAyMyIvPgogIDxjaXJjbGUgY3g9IjI0MCIgY3k9IjM0MCIgcj0iMzAiIGZpbGw9IiNjNDUwMjMiLzIiLz4KICA8Y2lyY2xlIGN4PSIyODAiIGN5PSIxNTAiIHI9IjUwIiBmaWxsPSIjYzQ1MDIzIi8+Cjwvc3ZnPg==';
                    };
                    marsImg.src = 'mars.png';
                }, 100);
            }
            
            // Calculate node bounds for export
            calculateNodeBoundsForExport(node, bounds) {
                bounds.minX = Math.min(bounds.minX, node.x - NODE_RADIUS);
                bounds.minY = Math.min(bounds.minY, node.y - NODE_RADIUS);
                bounds.maxX = Math.max(bounds.maxX, node.x + NODE_RADIUS);
                bounds.maxY = Math.max(bounds.maxY, node.y + NODE_RADIUS);
                
                if (node.children) {
                    for (const child of node.children) {
                        this.calculateNodeBoundsForExport(child, bounds);
                    }
                }
            }
            
            // Draw node for export
            drawNodeForExport(ctx, node, bounds) {
                // Draw connections to children
                if (node.children && node.children.length > 0) {
                    for (const child of node.children) {
                        // Draw connection line
                        ctx.beginPath();
                        
                        const startX = node.x - bounds.minX;
                        const startY = node.y - bounds.minY;
                        const endX = child.x - bounds.minX;
                        const endY = child.y - bounds.minY;
                        
                        // Draw curved connection line
                        const midX = (startX + endX) / 2;
                        const midY = (startY + endY) / 2;
                        const controlX = midX;
                        const controlY = midY - 30;
                        
                        ctx.moveTo(startX, startY);
                        ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                        
                        ctx.strokeStyle = node.color || '#4a6cff';
                        ctx.lineWidth = CONNECTION_WIDTH;
                        ctx.stroke();
                        
                        // Draw child node
                        this.drawNodeForExport(ctx, child, bounds);
                    }
                }
                
                // Draw improved node design
                const x = node.x - bounds.minX;
                const y = node.y - bounds.minY;
                
                // Draw glow effect
                const gradient = ctx.createRadialGradient(x, y, NODE_RADIUS * 0.7, x, y, NODE_RADIUS * 1.3);
                gradient.addColorStop(0, node.color || '#4a6cff');
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
                
                ctx.beginPath();
                ctx.arc(x, y, NODE_RADIUS * 1.3, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Draw node circle with gradient
                const nodeGradient = ctx.createRadialGradient(x, y, 0, x, y, NODE_RADIUS);
                const color = node.color || '#4a6cff';
                const lighterColor = this.lightenColor(color, 30);
                nodeGradient.addColorStop(0, lighterColor);
                nodeGradient.addColorStop(1, color);
                
                ctx.beginPath();
                ctx.arc(x, y, NODE_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = nodeGradient;
                ctx.fill();
                
                // Add subtle border
                ctx.beginPath();
                ctx.arc(x, y, NODE_RADIUS, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw node title with better text rendering
                ctx.font = 'bold 16px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Wrap text if needed
                const words = node.title.split(' ');
                let line = '';
                let lineY = y - 10;
                const maxWidth = NODE_RADIUS * 1.6;
                
                for (let i = 0; i < words.length; i++) {
                    const testLine = line + words[i] + ' ';
                    const metrics = ctx.measureText(testLine);
                    const testWidth = metrics.width;
                    
                    if (testWidth > maxWidth && i > 0) {
                        ctx.fillText(line, x, lineY);
                        line = words[i] + ' ';
                        lineY += 20;
                    } else {
                        line = testLine;
                    }
                }
                
                ctx.fillText(line, x, lineY);
                
                // Draw content preview if available
                if (node.content && node.content.trim().length > 0) {
                    ctx.font = '12px Arial';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    
                    const contentPreview = node.content.length > 20 
                        ? node.content.substring(0, 20) + '...' 
                        : node.content;
                    
                    ctx.fillText(contentPreview, x, y + 15);
                }
            }
            
            // Show help modal
            showHelpModal() {
                this.helpModal.style.display = 'block';
            }
            
            // Close help modal
            closeHelpModal() {
                this.helpModal.style.display = 'none';
            }
            
            // Show toast notification
            showToast(message, type = 'info') {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = `toast ${type}`;
                toast.classList.add('show');
                
                // Clear any existing timeout
                if (this.toastTimeout) {
                    clearTimeout(this.toastTimeout);
                }
                
                this.toastTimeout = setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }
            
            // Get canvas position from mouse event
            getCanvasPosition(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - this.offset.x) / this.zoom;
                const y = (e.clientY - rect.top - this.offset.y) / this.zoom;
                return { x, y };
            }
            
            // Get node at position
            getNodeAtPosition(x, y) {
                // Check root nodes first
                for (let i = this.nodes.length - 1; i >= 0; i--) {
                    const node = this.nodes[i];
                    const found = this.findNodeAtPositionRecursive(node, x, y);
                    if (found) return found;
                }
                return null;
            }
            
            // Recursively find node at position
            findNodeAtPositionRecursive(node, x, y) {
                // Check if point is within this node
                const dx = node.x - x;
                const dy = node.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= NODE_RADIUS) {
                    return node;
                }
                
                // Check children
                if (node.children) {
                    for (let i = node.children.length - 1; i >= 0; i--) {
                        const found = this.findNodeAtPositionRecursive(node.children[i], x, y);
                        if (found) return found;
                    }
                }
                
                return null;
            }
            
            // Get child button at position
            getChildButtonAtPosition(x, y) {
                for (const btn of this.childButtons) {
                    const dx = btn.x - x;
                    const dy = btn.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= CHILD_BUTTON_RADIUS) {
                        return btn;
                    }
                }
                return null;
            }
            
            // Generate unique ID
            generateId() {
                return Date.now().toString(36) + Math.random().toString(36).substr(2);
            }
            
            // Lighten a color by percentage
            lightenColor(color, percent) {
                const num = parseInt(color.replace('#', ''), 16),
                      amt = Math.round(2.55 * percent),
                      R = (num >> 16) + amt,
                      G = (num >> 8 & 0x00FF) + amt,
                      B = (num & 0x0000FF) + amt;
                
                return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
            
            // Render the mindmap
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.childButtons = []; // Reset child buttons
                
                // Draw all root nodes
                for (const node of this.nodes) {
                    this.renderNodeAndChildren(node);
                }
                
                // Draw add child buttons for hovered or selected node
                if (this.hoveredNode || this.selectedNode) {
                    const node = this.hoveredNode || this.selectedNode;
                    this.drawAddChildButton(node);
                }
            }
            
            // Render a node and all its children
            renderNodeAndChildren(node) {
                // Draw connections to children first
                if (node.children && node.children.length > 0) {
                    for (const child of node.children) {
                        // Draw connection line
                        this.ctx.beginPath();
                        const startX = node.x * this.zoom + this.offset.x;
                        const startY = node.y * this.zoom + this.offset.y;
                        const endX = child.x * this.zoom + this.offset.x;
                        const endY = child.y * this.zoom + this.offset.y;
                        
                        // Draw curved connection line
                        const midX = (startX + endX) / 2;
                        const midY = (startY + endY) / 2;
                        const controlX = midX;
                        const controlY = midY - 30 * this.zoom;
                        
                        this.ctx.moveTo(startX, startY);
                        this.ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                        
                        this.ctx.strokeStyle = node.color || '#4a6cff';
                        this.ctx.lineWidth = CONNECTION_WIDTH * this.zoom;
                        this.ctx.stroke();
                        
                        // Draw child node
                        this.renderNodeAndChildren(child);
                    }
                }
                
                // Draw node
                this.drawImprovedNode(node);
            }
            
            // Draw improved node design
            drawImprovedNode(node) {
                const x = node.x * this.zoom + this.offset.x;
                const y = node.y * this.zoom + this.offset.y;
                const radius = NODE_RADIUS * this.zoom;
                
                // Draw glow effect
                if (node === this.selectedNode || node === this.hoveredNode) {
                    const gradient = this.ctx.createRadialGradient(x, y, radius * 0.7, x, y, radius * 1.3);
                    gradient.addColorStop(0, node.color || '#4a6cff');
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius * 1.3, 0, Math.PI * 2);
                    this.ctx.fillStyle = gradient;
                    this.ctx.fill();
                }
                
                // Draw node circle with gradient
                const nodeGradient = this.ctx.createRadialGradient(x, y, 0, x, y, radius);
                const color = node.color || '#4a6cff';
                const lighterColor = this.lightenColor(color, 30);
                nodeGradient.addColorStop(0, lighterColor);
                nodeGradient.addColorStop(1, color);
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                this.ctx.fillStyle = nodeGradient;
                this.ctx.fill();
                
                // Add subtle border
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 2 * this.zoom;
                this.ctx.stroke();
                
                // Draw selection indicator
                if (node === this.selectedNode) {
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius + 5 * this.zoom, 0, Math.PI * 2);
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2 * this.zoom;
                    this.ctx.stroke();
                }
                
                // Draw node title with better text rendering
                this.ctx.font = `${NODE_FONT} ${14 * this.zoom}px Arial`;
                this.ctx.fillStyle = '#ffffff';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                
                // Wrap text if needed
                const words = node.title.split(' ');
                let line = '';
                let lineY = y - 10 * this.zoom;
                const maxWidth = radius * 1.6;
                
                for (let i = 0; i < words.length; i++) {
                    const testLine = line + words[i] + ' ';
                    const metrics = this.ctx.measureText(testLine);
                    const testWidth = metrics.width;
                    
                    if (testWidth > maxWidth && i > 0) {
                        this.ctx.fillText(line, x, lineY);
                        line = words[i] + ' ';
                        lineY += 20 * this.zoom;
                    } else {
                        line = testLine;
                    }
                }
                
                this.ctx.fillText(line, x, lineY);
                
                // Draw content preview if available
                if (node.content && node.content.trim().length > 0) {
                    this.ctx.font = `${12 * this.zoom}px Arial`;
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    
                    const contentPreview = node.content.length > 20 
                        ? node.content.substring(0, 20) + '...' 
                        : node.content;
                    
                    this.ctx.fillText(contentPreview, x, y + 15 * this.zoom);
                }
            }
            
            // Draw add child button
            drawAddChildButton(node) {
                if (!node) return;
                
                const nodeX = node.x * this.zoom + this.offset.x;
                const nodeY = node.y * this.zoom + this.offset.y;
                const nodeRadius = NODE_RADIUS * this.zoom;
                
                // Position button at the right edge of the node
                const btnX = nodeX + nodeRadius + 5;
                const btnY = nodeY;
                
                // Draw button with gradient
                const gradient = this.ctx.createRadialGradient(btnX, btnY, 0, btnX, btnY, CHILD_BUTTON_RADIUS);
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(1, node.color || '#4a6cff');
                
                this.ctx.beginPath();
                this.ctx.arc(btnX, btnY, CHILD_BUTTON_RADIUS, 0, Math.PI * 2);
                this.ctx.fillStyle = gradient;
                this.ctx.fill();
                
                // Add subtle shadow
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                this.ctx.shadowBlur = 5;
                this.ctx.shadowOffsetX = 2;
                this.ctx.shadowOffsetY = 2;
                this.ctx.stroke();
                this.ctx.shadowColor = 'transparent';
                
                // Draw plus sign
                this.ctx.beginPath();
                this.ctx.moveTo(btnX - 5, btnY);
                this.ctx.lineTo(btnX + 5, btnY);
                this.ctx.moveTo(btnX, btnY - 5);
                this.ctx.lineTo(btnX, btnY + 5);
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // Store button for hit testing
                this.childButtons.push({
                    x: btnX,
                    y: btnY,
                    parentNode: node
                });
            }
        }
        
        // Initialize application when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            const app = new CosmicMindmap();
        });
    </script>
</body>
</html>
